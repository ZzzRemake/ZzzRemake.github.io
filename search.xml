<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MIT 6.S081 Lab7-9 Thread &amp; Network Driver</title>
      <link href="/2024/01/27/mit-6.s081-lab7-9-thread/"/>
      <url>/2024/01/27/mit-6.s081-lab7-9-thread/</url>
      
        <content type="html"><![CDATA[<h2 id="Lab-Thread">Lab Thread</h2><p>哈哈，贼简单，但又脑残了，怎么有人记错了栈的增长方向的，消息了。</p><h3 id="课程">课程</h3><p>有一说一，课程内容其实就帮你把Lab做一遍了。</p><p>后面有机会了补罢。</p><h3 id="Uthread-switching-between-threads-moderate">Uthread: switching between threads (moderate)</h3><p>最难的（迫真）</p><p>首先建个上下文context结构体，用结构体存必要的callee寄存器以及ra，sp， 用汇编进行switch即可。</p><p>uthread.c:</p><pre class="language-c" data-language="c"><code class="language-c">struct ucontext{  uint64 ra;  uint64 sp;  // callee-saved  uint64 s0;  uint64 s1;  uint64 s2;  uint64 s3;  uint64 s4;  uint64 s5;  uint64 s6;  uint64 s7;  uint64 s8;  uint64 s9;  uint64 s10;  uint64 s11;};struct thread {  char       stack[STACK_SIZE]; /* the thread's stack */  int        state;             /* FREE, RUNNING, RUNNABLE */  struct ucontext context;};struct thread all_thread[MAX_THREAD];struct thread *current_thread;void thread_schedule(void){       //....  if (current_thread != next_thread) {         /* switch threads?  */    next_thread-&gt;state = RUNNING;    t = current_thread;    current_thread = next_thread;    /* YOUR CODE HERE     * Invoke thread_switch to switch from t to next_thread:     * thread_switch(??, ??);     */    thread_switch((uint64)(&amp;t-&gt;context), (uint64)(&amp;next_thread-&gt;context));  } else    next_thread = 0;}void thread_create(void (*func)()){  struct thread *t;  for (t = all_thread; t &lt; all_thread + MAX_THREAD; t++) {    if (t-&gt;state == FREE) break;  }  t-&gt;state = RUNNABLE;  // YOUR CODE HERE  memset(&amp;t-&gt;context, 0, sizeof(t-&gt;context));  t-&gt;context.ra = (uint64)func;  t-&gt;context.sp = (uint64)(t-&gt;stack+STACK_SIZE-1);  // 坑： sp是反向增长。。。。令人感叹。}</code></pre><p>而汇编的内容。。。其实直接可以把<code>kernel/swtch.S</code>抄过来。</p><h3 id="Using-threads-moderate">Using threads (moderate)</h3><p>pthread的简单应用。但这里有一个优化是可以单独说的。</p><p>原题要求将一个单线程安全的哈希表改成多线程安全，若每个桶都用相同的锁，那么多线程将退化为串行执行，不能起到并行加速的效果；但若对每个桶单独加个锁，便可以做到并行加速。</p><p>因此，这部分有<code>ph_safe</code>和<code>ph_fast</code>两个测试，分别测试正确性和优化后的并行加速。</p><p>ph.c:</p><pre class="language-c" data-language="c"><code class="language-c">pthread_mutex_t entry_mutex[NBUCKET];static void put(int key, int value){  int i = key % NBUCKET;  // is the key already present?  struct entry *e = 0;  pthread_mutex_lock(&amp;entry_mutex[i]);  for (e = table[i]; e != 0; e = e-&gt;next) {    if (e-&gt;key == key)      break;  }  if(e){    // update the existing key.    e-&gt;value = value;  } else {    // the new is new.    insert(key, value, &amp;table[i], table[i]);  }  pthread_mutex_unlock(&amp;entry_mutex[i]);}</code></pre><p>再加个锁的初始化即可。</p><h3 id="Barrier-moderate">Barrier(moderate)</h3><p>pthread中的信号量简单使用。</p><p>Barrier的作用是指定所有线程执行完后才能进行下一步，相当于一个整合的作用。</p><p>barrier.c:</p><pre class="language-c" data-language="c"><code class="language-c">static void barrier(){  // YOUR CODE HERE  //  // Block until all threads have called barrier() and  // then increment bstate.round.  //  pthread_mutex_lock(&amp;bstate.barrier_mutex);  bstate.nthread++;  if(bstate.nthread == nthread){    pthread_mutex_unlock(&amp;bstate.barrier_mutex);    bstate.nthread = 0;    bstate.round++;    pthread_cond_broadcast(&amp;bstate.barrier_cond);  } else {    pthread_cond_wait(&amp;bstate.barrier_cond, &amp;bstate.barrier_mutex);  } }</code></pre><h2 id="Lab-Network-Driver">Lab Network Driver</h2><h3 id="课程-2">课程</h3><p>课程主要讲了UART设备和console如何联系、如何读写。该部分调用关系的复杂导致理解上会出现困难性，下面是简略部分：</p><p>可能的寄存器：</p><ol><li>SIE（各类中断）</li><li>SSTATUS（控制中断）</li><li>SIP 查看中断类型</li><li>SCAUSE 说明当前状态原因位中断。</li><li>STVEC usertrap等返回位置</li></ol><p>其中，STVEC和SCAUSE已经在trap里知道用处了，而其他寄存器在设备驱动中起作用。</p><p>如何让UART设备与xv6正常协同工作：</p><p>start（m mode）设置supervisor mode 中断，以及定时器初始化<br>-&gt; console初始化，配置UART芯片<br>-&gt; PLIC 初始化<br>-&gt; SCHEDULER CPU接收中断。</p><p>读写的过程可以分为top（系统调用到buffer）和bottom（buffer到下层寄存器读写代码），这两部分代码组合便是驱动的代码。</p><h4 id="write（console）">write（console）</h4><p>Top：shell-&gt; putc-&gt; write-&gt;filewrite-&gt;识别FD_DEVICE，consolewrite-&gt;获得char，uartputc-&gt;若满则sleep，否则写入buffer，调uartstart函数-&gt;写入THR</p><p>Bottom：送到后，收到中断-&gt; PLIC-&gt; devintr-&gt;plic_clai声明某个CPU获得中断（中断号）-&gt;uartintr-&gt; consoleintr(由于接受寄存器为0，这里跳过)-&gt;uartstart,</p><h4 id="read-console">read(console)</h4><p>Top：shell-&gt; read-&gt;fileread-&gt;consoleread(buffer),若空则sleep，否则读取键盘写入的buffer。</p><p>Bottom：键盘读入：中断-&gt; plic, cpu, devintr(同上)-&gt;uartgetc-&gt;consoleintr-&gt;consputc.</p><h3 id="Code-Hard">Code(Hard)</h3><p>lab的提示疑似有些太详尽了，<s>这不是直接对着写完就行吗</s></p><p>lab只需要查部分文档即可写完，且用到的也就3个寄存器和4个标志位而已。<br>之后去查了一下6.828（6.S081的前身），发现量是真的多，相当于从头开始这个lab（虽然网络协议栈给了，但提示几乎没给，只能按照逻辑顺序重新实现e1000驱动。</p><pre class="language-c" data-language="c"><code class="language-c">inte1000_transmit(struct mbuf *m){  //  // Your code here.  //  // the mbuf contains an ethernet frame; program it into  // the TX descriptor ring so that the e1000 sends it. Stash  // a pointer so that it can be freed after sending.  //  // transmit是单个frame的传送，因此多进程的时候需要acquire。  // 实际上transmit的加锁与否不会影响太多，可能这就是锁罢。但recv的锁似乎无法加，具体得看一下net.c里怎么实现的。  acquire(&amp;e1000_lock);  int index = regs[E1000_TDT];  struct tx_desc* current_tx = tx_ring + index;  // check if the ring is overflowing  if((current_tx-&gt;status &amp; E1000_TXD_STAT_DD) == 0){    return -1;  }  // free the last mbuf that was transmitted from the descriptor  if(tx_mbufs[index]){    mbuffree(tx_mbufs[index]);    tx_mbufs[index] = 0;  }  // fill in the descriptor  current_tx-&gt;addr = (uint64)m-&gt;head;  current_tx-&gt;length = m-&gt;len;  current_tx-&gt;cmd = E1000_TXD_CMD_RS | E1000_TXD_CMD_EOP;  // update E1000_TDT to wake up DMA.  regs[E1000_TDT] = (regs[E1000_TDT] + 1) % TX_RING_SIZE;  tx_mbufs[index] = m;  release(&amp;e1000_lock);  return 0;}static voide1000_recv(void){  //  // Your code here.  //  // Check for packets that have arrived from the e1000  // Create and deliver an mbuf for each packet (using net_rx()).  //    while(1){    // 同时刻多个进程进行read，因此需要while。    // ask the ring index    int index = (regs[E1000_RDT] + 1) % RX_RING_SIZE;    struct rx_desc *current_rx = rx_ring + index;    // check if available    if((current_rx-&gt;status &amp; E1000_RXD_STAT_DD) == 0){      return;    }    // update mbuf len    struct mbuf* current_mbuf = rx_mbufs[index];    current_mbuf-&gt;len = current_rx-&gt;length;    net_rx(current_mbuf);    // new mbuf    struct mbuf* next_mbuf = mbufalloc(MBUF_DEFAULT_HEADROOM);    rx_mbufs[index] = next_mbuf;    current_rx-&gt;addr = (uint64)next_mbuf-&gt;head;    current_rx-&gt;status = 0;        // update E1000_RDT    regs[E1000_RDT] = (regs[E1000_RDT] + 1) % RX_RING_SIZE;  }}</code></pre><hr><p>去看了下optional challenge，很有趣，但我没时间写了呜呜呜。</p><h2 id="Lab-File-System">Lab File System</h2><h3 id="课程-3">课程</h3><p>这部分还是有些小晕，主要是锁的部分，有的地方不用加有的地方要加。后面应该要整理一份梳理一下。</p><h3 id="Large-files-moderate">Large files (moderate)</h3><p>实现双重间接块。</p><p>改下定义：</p><pre class="language-c" data-language="c"><code class="language-c">//fs.h#define NDIRECT 11#define NINDIRECT_DOUBLE (NINDIRECT * NINDIRECT)#define MAXFILE (NDIRECT + NINDIRECT + NINDIRECT_DOUBLE)struct dinode {  short type;           // File type  short major;          // Major device number (T_DEVICE only)  short minor;          // Minor device number (T_DEVICE only)  short nlink;          // Number of links to inode in file system  uint size;            // Size of file (bytes)  uint addrs[NDIRECT+1+1];   // Data block addresses};//file.hstruct inode {  uint dev;           // Device number  uint inum;          // Inode number  int ref;            // Reference count  struct sleeplock lock; // protects everything below here  int valid;          // inode has been read from disk?  short type;         // copy of disk inode  short major;  short minor;  short nlink;  uint size;  uint addrs[NDIRECT+1+1];};</code></pre><p>bmap.c:</p><pre class="language-c" data-language="c"><code class="language-c">static uintbmap(struct inode *ip, uint bn){  uint addr, *a;  struct buf *bp;  if(bn &lt; NDIRECT){    if((addr = ip-&gt;addrs[bn]) == 0)      ip-&gt;addrs[bn] = addr = balloc(ip-&gt;dev);    return addr;  }  bn -= NDIRECT;  if(bn &lt; NINDIRECT){    // Load indirect block, allocating if necessary.    if((addr = ip-&gt;addrs[NDIRECT]) == 0)      ip-&gt;addrs[NDIRECT] = addr = balloc(ip-&gt;dev);    bp = bread(ip-&gt;dev, addr);    a = (uint*)bp-&gt;data;    if((addr = a[bn]) == 0){      a[bn] = addr = balloc(ip-&gt;dev);      log_write(bp);    }    brelse(bp);    return addr;  }  // begin  bn -= NINDIRECT;  int first_index = bn/NINDIRECT, second_index = bn%NINDIRECT;  if(bn &lt; NINDIRECT_DOUBLE){    if((addr = ip-&gt;addrs[NDIRECT+1]) == 0)      ip-&gt;addrs[NDIRECT+1] = addr = balloc(ip-&gt;dev);    bp = bread(ip-&gt;dev, addr);    a = (uint*)bp-&gt;data;    if((addr = a[first_index]) == 0){      a[first_index] = addr = balloc(ip-&gt;dev);      log_write(bp);    }    brelse(bp);    // second : to data    bp = bread(ip-&gt;dev, addr);    a = (uint*)bp-&gt;data;    if((addr = a[second_index]) == 0){      a[second_index] = addr = balloc(ip-&gt;dev);      log_write(bp);    }    brelse(bp);    return addr;  }  // end  panic("bmap: out of range");}voiditrunc(struct inode *ip){  int i, j;  struct buf *bp;  uint *a;  for(i = 0; i &lt; NDIRECT; i++){    if(ip-&gt;addrs[i]){      bfree(ip-&gt;dev, ip-&gt;addrs[i]);      ip-&gt;addrs[i] = 0;    }  }  if(ip-&gt;addrs[NDIRECT]){    bp = bread(ip-&gt;dev, ip-&gt;addrs[NDIRECT]);    a = (uint*)bp-&gt;data;    for(j = 0; j &lt; NINDIRECT; j++){      if(a[j])        bfree(ip-&gt;dev, a[j]);    }    brelse(bp);    bfree(ip-&gt;dev, ip-&gt;addrs[NDIRECT]);    ip-&gt;addrs[NDIRECT] = 0;  }  // begin  struct buf *bp_index;  uint *a_index;  if(ip-&gt;addrs[NDIRECT+1]){    bp = bread(ip-&gt;dev, ip-&gt;addrs[NDIRECT+1]);    a = (uint*)bp-&gt;data;    for(i = 0; i&lt;NINDIRECT;i++){      if(a[i]){        bp_index = bread(ip-&gt;dev, a[i]);        a_index = (uint*)bp_index-&gt;data;        for(j = 0; j&lt;NINDIRECT;j++){          if(a_index[j])            bfree(ip-&gt;dev, a_index[j]);        }        brelse(bp_index);        bfree(ip-&gt;dev, a[i]);        a[i] = 0;      }    }    brelse(bp);    bfree(ip-&gt;dev, ip-&gt;addrs[NINDIRECT+1]);    ip-&gt;addrs[NDIRECT+1] = 0;  }  // end  ip-&gt;size = 0;  iupdate(ip);}</code></pre><h3 id="Symbolic-links-moderate">Symbolic links (moderate)</h3><p>增加系统调用的部分略。</p><p>定义：</p><pre class="language-c" data-language="c"><code class="language-c">//stat.h#define T_SYMLINK 4   // Symlink//fcntl.h#define O_NOFOLLOW 0x100</code></pre><p>sysfile.c:</p><pre class="language-c" data-language="c"><code class="language-c">uint64sys_open(void){  char path[MAXPATH];  int fd, omode;  struct file *f;  struct inode *ip;  int n;  if((n = argstr(0, path, MAXPATH)) &lt; 0 || argint(1, &amp;omode) &lt; 0)    return -1;  begin_op();  if(omode &amp; O_CREATE){    ip = create(path, T_FILE, 0, 0);    if(ip == 0){      end_op();      return -1;    }  } else {    int cnt = 0;    for(cnt = 0;cnt&lt;10;++cnt){      //printf("cnt: %d\n", cnt);      if((ip = namei(path)) == 0){        end_op();        return -1;      }      ilock(ip);      if(ip-&gt;type == T_SYMLINK &amp;&amp; ((omode &amp; O_NOFOLLOW) == 0)){        if(readi(ip, 0, (uint64)path, 0, MAXPATH) != MAXPATH){          iunlockput(ip);          end_op();          return -1;        }        iunlockput(ip);      } else {        break;      }    }    if(cnt==10){      iunlockput(ip);      end_op();      return -1;    }    if(ip-&gt;type == T_DIR &amp;&amp; omode != O_RDONLY){      iunlockput(ip);      end_op();      return -1;    }  }  //...}uint64sys_symlink(void){  char target[MAXPATH], path[MAXPATH];  if(argstr(0, target, MAXPATH) &lt; 0 || argstr(1, path, MAXPATH) &lt; 0){    return -1;  }  int len = strlen(target);  struct inode* ip;  begin_op();  if((ip = create(path, T_SYMLINK, 0, 0)) == 0){    end_op();    return -1;  }  //create 就是加锁的ip，这里铸币了  //ilock(ip);  if(writei(ip, 0, (uint64)target, 0, len) != len){    end_op();    return -1;  }  iunlockput(ip);  end_op();  return 0;}</code></pre><p>几个错误点：</p><ol><li>文档里的api不记得了，甚至还想自己实现一遍writei/readi，幸好悬崖勒马了。</li><li>另外对open的使用也不太熟悉，导致我还以为要在symlink的系统调用里头用O_TAG，我寻思也没有file层的调用啊。</li><li>最后就是ilock…这部分到现在还是不太了解，等之后细细梳理了。不过在这里和lock的原理无关，单纯就是自己会忘记加iunlockput而已。</li></ol><h2 id="碎碎念">碎碎念</h2><p>一拖再拖到最后剩一个mmap lab没完成，只能期待后面有时间写了。接下来没有lab了，课程还会继续看，但博客不再更新了，令人感叹。</p><p>写lab确实是有用的，满足了我写代码的需求，并且我也确实熟悉了关于操作系统的知识。但到后面就会发现，我这种三天打鱼两天晒网式学习严重影响了学6.S081 的过程，这也是我没时间写mmap lab的原因。</p><p>希望自己以后学这些确实能学到知识的时候，不会再去用这种态度去糟蹋知识吧。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT 6.S081 Lab4-6 trap &amp; Lazy &amp; COW</title>
      <link href="/2024/01/27/mit-6.s081-lab4-6-trap-lazy-cow/"/>
      <url>/2024/01/27/mit-6.s081-lab4-6-trap-lazy-cow/</url>
      
        <content type="html"><![CDATA[<p>这下大鸽子了，隔了一个月才写了这点。但不会完全鸽的。尽量在寒假前完成绝大部分lab。</p><p>或许我也想稍微摆点烂，因此把2021删掉的lab lazy也拿来做做<s>拖时间</s></p><h2 id="Lab-Trap-2021">Lab Trap(2021)</h2><h3 id="课程">课程</h3><h4 id="基本概念">基本概念</h4><ol><li>用户态中，RISC-V有32个用户寄存器以及SATP寄存器（User page table），trap需要将这些寄存器保存，并切换SATP到kernel page table。</li><li>内核态的切换中将会使用以下寄存器</li></ol><ul><li>stvec：trap handler的位置</li><li>sepc：保存用户的pc寄存器，sret等需要用到。</li><li>scause：reason for the trap</li><li>sstatus：其中，SIE bit表示device interrupts的enable；而SPP表示目前处于那个模式。</li></ul><ol start="3"><li>基本的trap过程：<br><img src="/images/OS/xv6-trap.png" alt="trap"><br>+ start executing at the new pc.</li><li>supervisor mode：实际上，supervisor mode可做的事很少。其相比于User mode，可以读写控制寄存器（也就是satp，stvec这些），以及使用PTE_U标志位为0的PTE，除此之外便无法进行，读取地址也只能依靠kernel page table。</li></ol><h4 id="uservec以及之前">uservec以及之前</h4><p>该trap为用户态系统调用等。<br>例如，用户态中通过shell调用write的时候会有：</p><p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-ML5OrMSu1sZV8JrCG4C%2F-ML5RUaTjsUrdw2GrcYT%2Fimage.png?alt=media&amp;token=54b07586-6e4d-4304-b399-3696cc0152f6" alt="write riscv"></p><p>其便会在a7寄存器寄存值，调用系统调用；且在其他寄存器配置write的基本参数，ecall进入uservec（trampoline）中。此时，ecall做了三件事：</p><ol><li>user mode-&gt; supervisor mode</li><li>pc-&gt; sepc</li><li>jump to stvec（此处为trampoline的起始地址，也就是uservec）.</li></ol><p>此时，需要uservec做以下事：</p><ol><li>保存32个用户寄存器</li><li>切换kernel page table</li><li>创建或找到kernel stack，改变sp。</li><li>jump to kernel C code（usertrap）</li></ol><p>以上步骤均通过uservec的汇编代码执行。需要注意的是，trampoline和trapframe（用户寄存器以及kernel寄存器保存处）在user 和kernel page table中都是固定的，这防止了因ecall导致的可能的页表错误。</p><p>汇编代码中的sscratch用于移除a0，让接下来的保存寄存器等操作可以通过a0实现。</p><h4 id="usertrap">usertrap</h4><p>该函数如下所示：</p><pre class="language-c" data-language="c"><code class="language-c">voidusertrap(void){  int which_dev = 0;  if((r_sstatus() &amp; SSTATUS_SPP) != 0)    panic("usertrap: not from user mode");  // send interrupts and exceptions to kerneltrap(),  // since we're now in the kernel.  w_stvec((uint64)kernelvec);  struct proc *p = myproc();    // save user program counter.  p-&gt;trapframe-&gt;epc = r_sepc();    if(r_scause() == 8){    // system call    if(p-&gt;killed)      exit(-1);    // sepc points to the ecall instruction,    // but we want to return to the next instruction.    p-&gt;trapframe-&gt;epc += 4;    // an interrupt will change sstatus &amp;c registers,    // so don't enable until done with those registers.    intr_on();    syscall();  } else if((which_dev = devintr()) != 0){    // ok  } else {    printf("usertrap(): unexpected scause %p pid=%d\n", r_scause(), p-&gt;pid);    printf("            sepc=%p stval=%p\n", r_sepc(), r_stval());    p-&gt;killed = 1;  }  if(p-&gt;killed)    exit(-1);  // give up the CPU if this is a timer interrupt.  if(which_dev == 2)    yield();  usertrapret();}</code></pre><p>感觉还是很好理解的。其做了以下事情：</p><ol><li>检查SPP等。</li><li>在内核进行任何操作之前，写入kernelvec，使得若发生kernel trap（一般而言就是exception）跳转到kernelvec。</li><li>保存用户程序计数器（防止切换改变SEPC）</li><li>根据不同情况，进行不同的处理。</li></ol><h4 id="usertrapret">usertrapret</h4><pre class="language-c" data-language="c"><code class="language-c">voidusertrapret(void){  struct proc *p = myproc();  // we're about to switch the destination of traps from  // kerneltrap() to usertrap(), so turn off interrupts until  // we're back in user space, where usertrap() is correct.  intr_off();  // send syscalls, interrupts, and exceptions to trampoline.S  w_stvec(TRAMPOLINE + (uservec - trampoline));  // set up trapframe values that uservec will need when  // the process next re-enters the kernel.  p-&gt;trapframe-&gt;kernel_satp = r_satp();         // kernel page table  p-&gt;trapframe-&gt;kernel_sp = p-&gt;kstack + PGSIZE; // process's kernel stack  p-&gt;trapframe-&gt;kernel_trap = (uint64)usertrap;  p-&gt;trapframe-&gt;kernel_hartid = r_tp();         // hartid for cpuid()  // set up the registers that trampoline.S's sret will use  // to get to user space.    // set S Previous Privilege mode to User.  unsigned long x = r_sstatus();  x &amp;= ~SSTATUS_SPP; // clear SPP to 0 for user mode  x |= SSTATUS_SPIE; // enable interrupts in user mode  w_sstatus(x);  // set S Exception Program Counter to the saved user pc.  w_sepc(p-&gt;trapframe-&gt;epc);  // tell trampoline.S the user page table to switch to.  uint64 satp = MAKE_SATP(p-&gt;pagetable);  // jump to trampoline.S at the top of memory, which   // switches to the user page table, restores user registers,  // and switches to user mode with sret.  uint64 fn = TRAMPOLINE + (userret - trampoline);  ((void (*)(uint64,uint64))fn)(TRAPFRAME, satp);}</code></pre><p>嗯哼，感觉饥初始写的也很明白（<br>这里可以说的就是，trampoline中的SEPC实际上可以不用在usertrap里保存，这里的保存顺序是没有必然联系的。</p><h4 id="userret">userret</h4><p>汇编代码，其做了以下事：</p><ol><li>切换 page table。</li><li>restore user register。</li><li>a0改为return的返回值（sscratch）</li><li>sret</li></ol><p>sret执行以下部分：</p><ol><li>切换回user mode</li><li>SPEC保存至PC寄存器</li><li>重新打开中断</li></ol><hr><p>以上过程中，xv6尽可能地使系统调用看上去像是函数，但实际上是需要一个层级的调用过程。</p><h4 id="kernel-trap">kernel trap</h4><p>该部分。。其实和user trap差不多，但简单一点。</p><p>kernelvec只在栈里保存和恢复寄存器，而kerneltrap处理interrupts（time）和exception。</p><h3 id="RISC-V-assembly-easy">RISC-V assembly (easy)</h3><p>这部分是简单的对着代码进行分析，让学生熟悉RISC-V的。但xv6的RISC-V并不用完整写一个程序，所以我这种完全不会RISC-V的也可以上手。</p><p>摆一张图：</p><p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MM-XjiGboAFe-3YvZfT%2F-MM0rYc4eVnR9nOesAAv%2Fimage.png?alt=media&amp;token=f30ebac8-8dc0-4b5d-8aa7-b241a10b43b3" alt="RISC-V registers"></p><p><s>用别人图床不也挺好吗</s></p><p>分析的代码部分：</p><pre class="language-c" data-language="c"><code class="language-c">user/_call:     file format elf64-littleriscvDisassembly of section .text:0000000000000000 &lt;g&gt;:#include "kernel/param.h"#include "kernel/types.h"#include "kernel/stat.h"#include "user/user.h"int g(int x) {   0:1141                addisp,sp,-16   2:e422                sds0,8(sp)   4:0800                addis0,sp,16  return x+3;}   6:250d                addiwa0,a0,3   8:6422                lds0,8(sp)   a:0141                addisp,sp,16   c:8082                ret000000000000000e &lt;f&gt;:int f(int x) {   e:1141                addisp,sp,-16  10:e422                sds0,8(sp)  12:0800                addis0,sp,16  return g(x);}  14:250d                addiwa0,a0,3  16:6422                lds0,8(sp)  18:0141                addisp,sp,16  1a:8082                ret000000000000001c &lt;main&gt;:void main(void) {  1c:1141                addisp,sp,-16  1e:e406                sdra,8(sp)  20:e022                sds0,0(sp)  22:0800                addis0,sp,16  printf("%d %d\n", f(8)+1, 13);  24:4635                lia2,13  26:45b1                lia1,12  28:00000517          auipca0,0x0  2c:7c050513          addia0,a0,1984 # 7e8 &lt;malloc+0xea&gt;  30:00000097          auipcra,0x0  34:610080e7          jalr1552(ra) # 640 &lt;printf&gt;  exit(0);  38:4501                lia0,0  3a:00000097          auipcra,0x0  3e:27e080e7          jalr638(ra) # 2b8 &lt;exit&gt;</code></pre><p>这里是解答部分：</p><div class="admonition info"><p class="admonition-title">Question 1</p><p>Which registers contain arguments to functions? For example, which register holds 13 in main's call to printf?</p></div><p>a0------a7. 13 存储在a2.</p><div class="admonition info"><p class="admonition-title">Question 2</p><p>Where is the call to function f in the assembly code for main? Where is the call to g? (Hint: the compiler may inline functions.)</p></div><p>编译器优化直接内联展开了。</p><div class="admonition info"><p class="admonition-title">Question 3</p><p>At what address is the function printf located?</p></div><p><code>0000000000000630 &lt;printf&gt;</code>。</p><div class="admonition info"><p class="admonition-title">Question 4</p><p>What value is in the register ra just after the jalr to printf in main?</p></div><p>返回的地址ra是main里头的对应行数的地址。</p><div class="admonition info"><p class="admonition-title">Question 5</p><p>Run the following code. What is the output?The output depends on that fact that the RISC-V is little-endian. If the RISC-V were instead big-endian what would you set i to in order to yield the same output? Would you need to change 57616 to a different value?</p></div><pre class="language-c" data-language="c"><code class="language-c">unsigned int i = 0x00646c72;printf("H%x Wo%s", 57616, &amp;i);</code></pre><p>大端小端的问题。。。计组都搞过了，不回答😤😤😤</p><div class="admonition info"><p class="admonition-title">Question 6</p><p>In the following code, what is going to be printed after 'y='? (note: the answer is not a specific value.) Why does this happen?</p></div><pre class="language-c" data-language="c"><code class="language-c">printf("x=%d y=%d", 3);</code></pre><p>未定义行为，当前的a2寄存器不知道是什么值，因此输出也是未知的。</p><h3 id="Backtrace-moderate">Backtrace (moderate)</h3><p>实现一个回溯的Backtrace。</p><p>还是很简单的一道题，用指针就行了，我还在想用什么riscv指令来访问物理内存。自己做这些题还是容易舍近求远。</p><p>本题目需要理解下图：</p><p><img src="/images/OS/xv6-stack.png" alt="xv6 Stack"></p><p>在每一层的堆栈中，return address位于frame pointer的offset(-8)位置，二上一个frame pointer的在当前frame pointer offset(-16)位置，因此若要存取上一个堆栈信息，可以直接用指针的加减来获得。</p><p>首先在<code>kernel/defs.h</code>等地方加上必要的配置，例如函数声明等。</p><p>其次在<code>kernel/riscv.h</code>里增加以下函数声明：</p><pre class="language-c" data-language="c"><code class="language-c">static inline uint64r_fp(){  uint64 x;  asm volatile("mv %0, s0" : "=r" (x) );  return x;}</code></pre><p>该函数可以获取当前帧指针<code>s0</code>的值。</p><p>在<code>kernel/printf.c</code>里增加以下内容：</p><pre class="language-c" data-language="c"><code class="language-c">void backtrace(){  printf("backtrace:\n");  uint64 fp = r_fp();  uint64 start = PGROUNDUP(fp), end = PGROUNDDOWN(fp);  while(end&lt;=fp&amp;&amp;fp&lt;=start){    printf("%p\n", *(uint64*)(fp-8));    fp = *(uint64*)(fp-16);  }}</code></pre><p>其中的start和end变量是为了防止fp的无限回溯超出界限。xv6会将每一个stack都分配一个page，因此用PGROUNDUP等宏即可获取上下限。</p><h3 id="Alarm-hard">Alarm (hard)</h3><p>按照他的步骤来就算简单。</p><p>本题要求增加两个系统调用：sigalarm和sigreturn。</p><p>除了增加系统调用所必要的修改外，其他修改如下：</p><p>由于跳转函数会破坏寄存器的值，因此需要在proc结构里保存寄存器的值。这里的实现是有些偷懒的，只根据alarmtest.asm里的所需值增加了所需要的寄存器：sp，pc，s0-s1, ra以及a0-a7，但实际上无从知道编译器会用哪些用户寄存器，因此在实际使用的时候应该将32个寄存器全部存储。</p><pre class="language-c" data-language="c"><code class="language-c">struct proc {  //...  uint64 ticks; //时间间隔  uint64 func; //执行的函数指针  uint64 count; //经过多长时间  uint64 alarm_epc; //保存的pc寄存器  uint64 in_handler; //是否有return  // 保存的寄存器  uint64 sp;  uint64 s0;  uint64 s1;  uint64 ra;  uint64 a0;  uint64 a1;  uint64 a2;  uint64 a3;  uint64 a4;  uint64 a5;  uint64 a6;  uint64 a7;};</code></pre><p><code>kernel/proc.c</code> 的<code>allocproc</code>函数里也增加初始化内容：</p><pre class="language-c" data-language="c"><code class="language-c">static struct proc*allocproc(void){found:    //.....  p-&gt;count = 0;  p-&gt;ticks = 0;  p-&gt;func = 0;  p-&gt;alarm_epc = 0;  p-&gt;in_handler = 0;  p-&gt;a0 = p-&gt;a1 = p-&gt;a2 = p-&gt;a3 = p-&gt;a4 = p-&gt;a5 = p-&gt;a6 = p-&gt;a7 =0;  p-&gt;sp = p-&gt;ra = p-&gt;s0 = p-&gt;s1 = 0;  return p;}</code></pre><p>两系统调用：</p><pre class="language-c" data-language="c"><code class="language-c">uint64sys_sigalarm(void){  int ticks;  uint64 func;  if(argint(0, &amp;ticks) &lt; 0 &amp;&amp; argaddr(1, &amp;func)&lt;0){    return -1;  }  struct proc *p = myproc();  func = p-&gt;trapframe-&gt;a1;  printf("%p\n", func);  if(ticks == 0 &amp;&amp; func == 0){    p-&gt;ticks = p-&gt;func = p-&gt;count = 0;    return 0;  }  p-&gt;ticks = ticks;  p-&gt;func = func;  p-&gt;count = 0;  return 0;}uint64sys_sigreturn(void){  struct proc *p = myproc();  if (p-&gt;in_handler){    p-&gt;trapframe-&gt;epc  = p-&gt;alarm_epc;    p-&gt;count = 0;    p-&gt;in_handler = 0;    p-&gt;trapframe-&gt;a0 = p-&gt;a0;    p-&gt;trapframe-&gt;a1 = p-&gt;a1;    p-&gt;trapframe-&gt;a2 = p-&gt;a2;    p-&gt;trapframe-&gt;a3 = p-&gt;a3;    p-&gt;trapframe-&gt;a4 = p-&gt;a4;    p-&gt;trapframe-&gt;a5 = p-&gt;a5;    p-&gt;trapframe-&gt;a6 = p-&gt;a6;    p-&gt;trapframe-&gt;a7 = p-&gt;a7;    p-&gt;trapframe-&gt;sp = p-&gt;sp;    p-&gt;trapframe-&gt;s0 = p-&gt;s0;    p-&gt;trapframe-&gt;s1 = p-&gt;s1;    p-&gt;trapframe-&gt;ra = p-&gt;ra;  }  return 0;}</code></pre><p><code>kernel/trap.c</code>:</p><pre class="language-c" data-language="c"><code class="language-c">voidusertrap(void){     // ...  // give up the CPU if this is a timer interrupt.  if(which_dev == 2){    if (p-&gt;func||p-&gt;ticks){      p-&gt;count++;      if (p-&gt;count==p-&gt;ticks){        p-&gt;in_handler = 1;        p-&gt;alarm_epc = p-&gt;trapframe-&gt;epc;        p-&gt;trapframe-&gt;epc = p-&gt;func;        p-&gt;a0 = p-&gt;trapframe-&gt;a0;        p-&gt;a1 = p-&gt;trapframe-&gt;a1;        p-&gt;a2 = p-&gt;trapframe-&gt;a2;        p-&gt;a3 = p-&gt;trapframe-&gt;a3;        p-&gt;a4 = p-&gt;trapframe-&gt;a4;        p-&gt;a5 = p-&gt;trapframe-&gt;a5;        p-&gt;a6 = p-&gt;trapframe-&gt;a6;        p-&gt;a7 = p-&gt;trapframe-&gt;a7;        p-&gt;sp = p-&gt;trapframe-&gt;sp;        p-&gt;s0 = p-&gt;trapframe-&gt;s0;        p-&gt;s1 = p-&gt;trapframe-&gt;s1;        p-&gt;ra = p-&gt;trapframe-&gt;ra;      }    }    yield();  }  usertrapret();}</code></pre><h3 id="Option">Option</h3><p>Optional Challenge是要在backtrace里打印出name而不是地址，这部分。。。网上找不到，我也不会。大概的思路就是像gdb一样从可执行文件里读symbol然后输出，可问题是怎么获得呢？不会捏。</p><h2 id="Lab-Lazy-2020">Lab Lazy(2020)</h2><p>2021课程把这个lab删了。可能是因为课堂上已经把lab的至少一半的内容给泄完了。</p><p>但其实剩下的也是重量级，谁能想得到把panic删了的。</p><h3 id="课程-2">课程</h3><p>课程关于代码的解释都在lab里面，所以这里只稍微提一下原理。</p><p>lazy lab本身需要利用虚拟内存的Page faults来加载page，RV里，Page fault的原因存储在SCAUSE，虚拟内存中的地址存储在STVAL寄存器中：</p><p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MMD_TK8Ar4GqWE6xfWV%2F-MMNmVfRDZSAOKze10lZ%2Fimage.png?alt=media&amp;token=4bbfdfa6-1491-4ab8-8248-03bd0e36a8e9" alt="RISC-V SCAUSE value"></p><p>以及在TRAPFRAME中存储的用户程序寄存器值。</p><p>因此，我们可以根据以上信息来进行lazy page allocation，替代eager allocation以提高性能。</p><h3 id="Eliminate-allocation-from-sbrk-easy">Eliminate allocation from sbrk() (easy)</h3><p>只要改一下sys_sbrk就行。</p><p><code>sysproc.c</code>:</p><pre class="language-c" data-language="c"><code class="language-c">uint64sys_sbrk(void){  int addr;  int n;  struct proc* p;  if(argint(0, &amp;n) &lt; 0)    return -1;  p =  myproc();  p-&gt;sz = p-&gt;sz+n;  //if(growproc(n) &lt; 0)  //  return -1;  return addr;}</code></pre><p>运行结果大致如下：</p><pre class="language-bash" data-language="bash"><code class="language-bash">init: starting sh$ echo hiusertrap(): unexpected scause 0x000000000000000f pid=3            sepc=0x0000000000001258 stval=0x0000000000004008va=0x0000000000004000 pte=0x0000000000000000panic: uvmunmap: not mapped</code></pre><p>可以看到uvmunmap出现了panic，因为这里只改了heap的位置，没有分配真正的内存，因此也没有真正的页表，无法进行unmap操作。</p><h3 id="Lazy-allocation-moderate">Lazy allocation (moderate)</h3><p>lazy allocation的思路是引发page fault（这里只处理load和save类型的page fault）时进行分配。由于物理内存和逻辑内存是全相联的，所以简单的分配给一页就行。</p><p>具体代码见下面整体任务。</p><h3 id="Lazytests-and-Usertests-moderate">Lazytests and Usertests (moderate)</h3><p><code>trap.c</code>:处理Page Fault的分配页表。</p><pre class="language-c" data-language="c"><code class="language-c">voidusertrap(void){  //......  if(r_scause() == 8){    // system call    if(p-&gt;killed)      exit(-1);    // sepc points to the ecall instruction,    // but we want to return to the next instruction.    p-&gt;trapframe-&gt;epc += 4;    // an interrupt will change sstatus &amp;c registers,    // so don't enable until done with those registers.    intr_on();    syscall();  } else if (r_scause() == 13 || r_scause() == 15){    uint64 va = r_stval();    //printf("page fault: %p\n", va);    //printf("%p, %p\n", r_stval(), va);    if(va &gt;= p-&gt;sz||va&lt;=p-&gt;trapframe-&gt;sp){      p-&gt;killed = 1;      //printf("usertrap(): error va %p pid=%d\n", va, p-&gt;pid);    } else {      uint64 ka = (uint64)kalloc();      if (ka==0){        p-&gt;killed = 1;      } else {        memset((void*)ka, 0, PGSIZE);        va = PGROUNDDOWN(va);        if(mappages(p-&gt;pagetable, va, PGSIZE, ka, PTE_W|PTE_U|PTE_R)!=0){          kfree((void*)ka);          p-&gt;killed = 1;        }      }          }  } else if((which_dev = devintr()) != 0){    // ok  }  //....}</code></pre><p>上述代码在load或save page fault进入，首先进行合法性检查，之后开始分配内存。若无内存，就kill内存，否则将内存置0，mappages将其映射到目标用户的页表中。</p><p><code>sysproc.c</code>: 修改sbrk。</p><pre class="language-c" data-language="c"><code class="language-c">uint64sys_sbrk(void){  int addr;  int n;  struct proc* p;  if(argint(0, &amp;n) &lt; 0)    return -1;  p =  myproc();  addr = p-&gt;sz;  p-&gt;sz = p-&gt;sz+n;  if (n&lt;0) {    uvmdealloc(p-&gt;pagetable, p-&gt;sz-n, p-&gt;sz);  }  //if(growproc(n) &lt; 0)  //  return -1;  return addr;}</code></pre><p>增加了负数的处理。</p><p><code>vm.c</code> 处理fork，copyin（write）和copyout（read）</p><pre class="language-c" data-language="c"><code class="language-c">// 要用到proc结构，引入头文件。#include "spinlock.h"#include "proc.h"//该部分的改动实际上就是注释掉两个panic，这谁想得到，或者敢这样做？//哎，以后得多试了，这里卡了好久。// Remove npages of mappings starting from va. va must be// page-aligned. The mappings must exist.// Optionally free the physical memory.voiduvmunmap(pagetable_t pagetable, uint64 va, uint64 npages, int do_free){  uint64 a;  pte_t *pte;  if((va % PGSIZE) != 0)    panic("uvmunmap: not aligned");  for(a = va; a &lt; va + npages*PGSIZE; a += PGSIZE){    if((pte = walk(pagetable, a, 0)) == 0){      //panic("uvmunmap: walk");      continue;    }    if((*pte &amp; PTE_V) == 0)      continue;      //panic("uvmunmap: not mapped");    if(PTE_FLAGS(*pte) == PTE_V)      panic("uvmunmap: not a leaf");    if(do_free){      uint64 pa = PTE2PA(*pte);      kfree((void*)pa);    }    *pte = 0;  }}// 同上。fork用的。// Given a parent process's page table, copy// its memory into a child's page table.// Copies both the page table and the// physical memory.// returns 0 on success, -1 on failure.// frees any allocated pages on failure.intuvmcopy(pagetable_t old, pagetable_t new, uint64 sz){  pte_t *pte;  uint64 pa, i;  uint flags;  char *mem;  for(i = 0; i &lt; sz; i += PGSIZE){    if((pte = walk(old, i, 0)) == 0)      //panic("uvmcopy: pte should exist");      continue;    if((*pte &amp; PTE_V) == 0)      //panic("uvmcopy: page not present");      continue;    pa = PTE2PA(*pte);    flags = PTE_FLAGS(*pte);    if((mem = kalloc()) == 0)      goto err;    memmove(mem, (char*)pa, PGSIZE);    if(mappages(new, i, PGSIZE, (uint64)mem, flags) != 0){      kfree(mem);      goto err;    }  }  return 0; err:  uvmunmap(new, 0, i / PGSIZE, 1);  return -1;}// Copy from kernel to user.// Copy len bytes from src to virtual address dstva in a given page table.// Return 0 on success, -1 on error.intcopyout(pagetable_t pagetable, uint64 dstva, char *src, uint64 len){  uint64 n, va0, pa0;  struct proc* p = myproc();  while(len &gt; 0){    va0 = PGROUNDDOWN(dstva);    pa0 = walkaddr(pagetable, va0);    if(pa0 == 0) {      if(va0 &gt;= p-&gt;sz||va0&lt;=p-&gt;trapframe-&gt;sp){        return -1;        //printf("usertrap(): error va %p pid=%d\n", va, p-&gt;pid);      } else {        pa0 = (uint64)kalloc();        if (pa0==0){          p-&gt;killed = 1;          return -1;        } else {          memset((void*)pa0, 0, PGSIZE);          va0 = PGROUNDDOWN(va0);          if(mappages(p-&gt;pagetable, va0, PGSIZE, pa0, PTE_W|PTE_U|PTE_R)!=0){            kfree((void*)pa0);            p-&gt;killed = 1;            return -1;          }        }            }    }    n = PGSIZE - (dstva - va0);    if(n &gt; len)      n = len;    memmove((void *)(pa0 + (dstva - va0)), src, n);    len -= n;    src += n;    dstva = va0 + PGSIZE;  }  return 0;}// Copy from user to kernel.// Copy len bytes to dst from virtual address srcva in a given page table.// Return 0 on success, -1 on error.intcopyin(pagetable_t pagetable, char *dst, uint64 srcva, uint64 len){  uint64 n, va0, pa0;  struct proc* p = myproc();  while(len &gt; 0){    va0 = PGROUNDDOWN(srcva);    pa0 = walkaddr(pagetable, va0);    if(pa0 == 0) {      if(va0 &gt;= p-&gt;sz||va0&lt;=p-&gt;trapframe-&gt;sp){        return -1;        //printf("usertrap(): error va %p pid=%d\n", va, p-&gt;pid);      } else {        pa0 = (uint64)kalloc();        if (pa0==0){          p-&gt;killed = 1;          return -1;        } else {          memset((void*)pa0, 0, PGSIZE);          va0 = PGROUNDDOWN(va0);          if(mappages(p-&gt;pagetable, va0, PGSIZE, pa0, PTE_W|PTE_U|PTE_R)!=0){            kfree((void*)pa0);            p-&gt;killed = 1;            return -1;          }        }            }    }    n = PGSIZE - (srcva - va0);    if(n &gt; len)      n = len;    memmove(dst, (void *)(pa0 + (srcva - va0)), n);    len -= n;    dst += n;    srcva = va0 + PGSIZE;  }  return 0;}</code></pre><hr><p>哎，自己好菜。</p><h2 id="Lab-Copy-On-Write-2021">Lab Copy-On-Write(2021)</h2><h3 id="课程-3">课程</h3><p>其实课程内容很少。</p><p>Xv6以及其他类POSIX 系统，若要使用fork-exec方式来生成新的进程，fork便会带来不必要的复制：fork的意义是为exec带来新的pid以及进程资源，原进程的复制只会带来不必要的IO。</p><p>于是，大部分操作系统都实现了Copy-On-Write（COW）fork，按需进行复制。</p><h4 id="具体过程">具体过程</h4><p>可以将fork后的父子进程共享同一份物理内存（page），这样，若不发生写入，则只需要修改一下子进程的pagetable即可。而为了满足这一点，需要将PTE标志位设为只读，且明确标明这是COW的结果（可在RSW位中设置），方便和出错情况区分。而当需要写入的时候，按需对写入页进行复制。</p><p>写时复制带来了性能的提升，但相对也带来了维护的复杂性：什么时候释放页呢？这里就需要引入引用计数，而引用计数的相关知识。。略。感觉都会罢。</p><h3 id="Implement-copy-on-write-hard">Implement copy-on write (hard)</h3><p>该部分确实和Lazy重合度大，重点在PTE标志位的设定，以及kalloc.c中引用数据结构的维护。</p><p>不用最开始就考虑复杂情况。由于xv6本身较为简单，因此标志位不会设定的太复杂，不需要考虑R和W位的组合问题，这里钻了牛角尖了。</p><p>riscv.h:</p><pre class="language-c" data-language="c"><code class="language-c">#define PTE_COW (1L &lt;&lt; 8) // 1 -&gt; Copy-On-Write PAGE</code></pre><p>kalloc.c:</p><pre class="language-c" data-language="c"><code class="language-c">#include "types.h"#include "param.h"#include "memlayout.h"#include "spinlock.h"#include "riscv.h"#include "defs.h"#define PA2CNT_INDEX(pa) (((uint64)pa)&gt;&gt;12)void freerange(void *pa_start, void *pa_end);struct cnt {  struct spinlock lock;  uint cnt[PHYSTOP&gt;&gt;PGSHIFT];} kcnt;extern char end[]; // first address after kernel.                   // defined by kernel.ld.struct run {  struct run *next;};struct {  struct spinlock lock;  struct run *freelist;} kmem;voidkinit(){  initlock(&amp;kmem.lock, "kmem");  initlock(&amp;kcnt.lock, "kcnt");  freerange(end, (void*)PHYSTOP);}voidfreerange(void *pa_start, void *pa_end){  char *p;  p = (char*)PGROUNDUP((uint64)pa_start);  for(; p + PGSIZE &lt;= (char*)pa_end; p += PGSIZE){    kcnt.cnt[PA2CNT_INDEX(p)] = 0;    kfree(p);  }}// Free the page of physical memory pointed at by v,// which normally should have been returned by a// call to kalloc().  (The exception is when// initializing the allocator; see kinit above.)voidkfree(void *pa){  struct run *r;  if(((uint64)pa % PGSIZE) != 0 || (char*)pa &lt; end || (uint64)pa &gt;= PHYSTOP)    panic("kfree");  acquire(&amp;kcnt.lock);  if(kcnt.cnt[PA2CNT_INDEX(pa)] != 0){    --kcnt.cnt[PA2CNT_INDEX(pa)];  }  release(&amp;kcnt.lock);  if (kcnt.cnt[PA2CNT_INDEX(pa)] != 0){    return;  }  // Fill with junk to catch dangling refs.  memset(pa, 1, PGSIZE);  r = (struct run*)pa;  acquire(&amp;kmem.lock);  r-&gt;next = kmem.freelist;  kmem.freelist = r;  release(&amp;kmem.lock);}// Allocate one 4096-byte page of physical memory.// Returns a pointer that the kernel can use.// Returns 0 if the memory cannot be allocated.void *kalloc(void){  struct run *r;  acquire(&amp;kmem.lock);  r = kmem.freelist;  if(r){    kmem.freelist = r-&gt;next;    acquire(&amp;kcnt.lock);    kcnt.cnt[PA2CNT_INDEX(r)] = 1;    release(&amp;kcnt.lock);  }  release(&amp;kmem.lock);  if(r){    memset((char*)r, 5, PGSIZE); // fill with junk  }  return (void*)r;}void kincrease(uint64 pa){  acquire(&amp;kcnt.lock);  kcnt.cnt[PA2CNT_INDEX(pa)] += 1;  release(&amp;kcnt.lock);}</code></pre><p>vm.c:</p><pre class="language-c" data-language="c"><code class="language-c">intuvmcopy(pagetable_t old, pagetable_t new, uint64 sz){  pte_t *pte;  uint64 pa, i;  uint flags;  //char *mem;  for(i = 0; i &lt; sz; i += PGSIZE){    if((pte = walk(old, i, 0)) == 0)      panic("uvmcopy: pte should exist");    if((*pte &amp; PTE_V) == 0)      panic("uvmcopy: page not present");    pa = PTE2PA(*pte);        kincrease(pa);        *pte |= PTE_COW;    *pte &amp;= ~PTE_W;    flags = PTE_FLAGS(*pte);    //if((mem = kalloc()) == 0)    //  goto err;    //memmove(mem, (char*)pa, PGSIZE);    if(mappages(new, i, PGSIZE, (uint64)pa, flags) != 0){      // 若无法分配一个page。。。感觉要改mappage，这里头有个remap。      //kfree((void*)pa);      goto err;    }  }  return 0;  //...}intcopyout(pagetable_t pagetable, uint64 dstva, char *src, uint64 len){  uint64 n, va0, pa0;  pte_t* pte0;  while(len &gt; 0){    va0 = PGROUNDDOWN(dstva);    pa0 = walkaddr(pagetable, va0);    if(pa0 == 0)      return -1;    pte0 = walk(pagetable, va0, 0);    if((*pte0 &amp; PTE_W) == 0){      if(cow(pagetable, va0)&lt;0){        return -1;      }    }    pa0 = PTE2PA(*pte0);    //.....  }}int cow(pagetable_t pagetable, uint64 va){  if(va&gt;=MAXVA){    return -1;  }  pte_t* pte;  if((pte = walk(pagetable, va, 0)) == 0){    panic("cow(): cow walk error.");    return -1;  }  if((*pte &amp; PTE_V) == 0){    return -1;  }  if((*pte &amp; PTE_COW) == 0){    return -1;  }  if((*pte &amp; PTE_U) == 0){    return -1;  }  uint64 ka = (uint64)kalloc(), pa = PTE2PA(*pte);  uint flags = PTE_FLAGS(*pte);  if (ka==0){    return -1;  }  memmove((void*)ka, (char*)pa, PGSIZE);  flags &amp;= ~PTE_COW;  flags |= PTE_W;  *pte = PA2PTE(ka) | flags;  kfree((void*)pa);  return 0;}</code></pre><p>trap.c:</p><pre class="language-c" data-language="c"><code class="language-c">voidusertrap(void){  //...  if(r_scause() == 8){    // system call    // ...    syscall();  } else if (r_scause() == 15){    uint64 va = r_stval();    if(cow(p-&gt;pagetable, va)&lt;0){      p-&gt;killed = 1;    }  } //...}</code></pre><p>再修改一下defs.h即可。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CNSS Recruit 2023 SA writeup</title>
      <link href="/2023/12/06/cnss-recruit-2023-sa-writeup/"/>
      <url>/2023/12/06/cnss-recruit-2023-sa-writeup/</url>
      
        <content type="html"><![CDATA[<p>孩子不会SA，随便打着玩的。<br>唉，总是在错误的时间遇到正确的事情。</p><h2 id="Little-Docker">Little Docker</h2><h3 id="基本要求">基本要求</h3><ul><li>安装docker</li><li>利用docker部署一个nginx服务，实现当宿主机请求自身的5000端口时能获取到nginx的欢迎界面</li><li>请你实现当不进入容器的情况下，将nginx的欢迎界面更改成下载链接中的页面(禁用文件复制)</li><li>现使用 centos:latest 镜像创建另一个容器，确保centos容器能以 container:port 的形式访问到点2中的页面</li><li>这两个容器能相互ping通</li></ul><h3 id="过程">过程</h3><p>本题在centos环境中完成。</p><p>安装docker部分：按照<a href="https://docs.docker.com/engine/install/centos/">官方文档</a>操作即可。</p><p>docker部署nginx：采用docker compose完成。</p><p>配置文件结构如下：</p><pre class="language-bash" data-language="bash"><code class="language-bash">.├── conf.d│   ├── fastcgi.conf│   ├── fastcgi.conf.default│   ├── fastcgi_params│   ├── fastcgi_params.default│   ├── koi-utf│   ├── koi-win│   ├── mime.types│   ├── mime.types.default│   ├── nginx.conf.default│   ├── scgi_params│   ├── scgi_params.default│   ├── uwsgi_params│   ├── uwsgi_params.default│   └── win-utf├── docker-compose.yml├── html│   └── index.html├── logs│   └── access.log└── nginx.conf</code></pre><p>nginx.conf如下：</p><pre class="language-nginx" data-language="nginx"><code class="language-nginx">worker_processes  auto;events {    worker_connections  1024;}http {    include       mime.types;    default_type  application/octet-stream;    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '                      '$status $body_bytes_sent "$http_referer" '                      '"$http_user_agent" "$http_x_forwarded_for"';    sendfile        on;    #tcp_nopush     on;    server_tokens off;    #keepalive_timeout  0;    keepalive_timeout  65;    gzip on;    gzip_types text/plain application/x-javascript text/css application/xml text/javascript application/javascript image/jpeg image/gif image/png;    gzip_vary on;          server {        listen       80;        location / {            root   /usr/share/nginx/html;            try_files /index.html /index.htm;        }    }}</code></pre><p>docker-compose.yaml如下：</p><pre class="language-yaml" data-language="yaml"><code class="language-yaml">version: '3.9'services:    nginx:        image: nginx        restart: always        ports:            - '5000:80'        volumes:            - ./html:/usr/share/nginx/html            - ./nginx.conf:/etc/nginx/nginx.conf            - ./conf.d:/etc/nginx/conf.d            - ./logs:/var/log/nginx        networks:            - testnetworks:    test:        driver: bridge</code></pre><p><code>curl 127.0.0.1:5000</code>，如下所示：</p><p><img src="/images/CNSS/curl%201.png" alt="curl"></p><p>创建centos容器：</p><pre class="language-bash" data-language="bash"><code class="language-bash">sudo docker run --network nginx_test --network-alias centos --name centos -itd centos:latest# 进入centos容器sudo docker exec -it &lt;centos id&gt; bash</code></pre><p><code>curl</code> 一下，发现docker网络里暴露的不是绑定的端口，而是自身的端口（</p><p><img src="/images/CNSS/curl%202.png" alt="centos curl"></p><p><img src="/images/CNSS/curl%203.png" alt="centos ping"></p><p>nginx容器测试时，由于容器过分精简导致没有<code>ping</code>，所以在容器中输入以下命令（默认root用户）：</p><pre class="language-bash" data-language="bash"><code class="language-bash">apt updateapt install inetutils-ping</code></pre><p>结果如下：</p><p><img src="/images/CNSS/curl%204.png" alt="nginx ping"></p><h2 id="RSS-Service">RSS Service</h2><h3 id="题目描述">题目描述</h3><ul><li>使用 Docker 部署 RSSHub，并开放到公网以供查房。</li><li>使用 Docker 部署梯子，并作为 RSSHub 的代理，以访问源站位于墙外的路由（例如 Twitter）</li><li>在同一个 docker-compose 中部署上述两服务</li></ul><h3 id="过程-2">过程</h3><p>其实应该更早做出来这道题的，但我debug找了半天，问了ganqiu才知道是我clash配置文件的问题，改一下<code>allow-lan</code>,将clash从只允许本地环回地址改成允许局域网访问就行。令人感叹。</p><p>本题采用clash作为代理，国内访问以bilibili（无需appkey）为例，国外访问以youtube（需要google key）为例，访问地址：<code>http://82.157.22.75:9981/</code>,经nginx反向代理至rsshub的端口（后面才发现其实根本没必要这样，懒了）</p><p><code>docker-compose.yaml</code>：</p><pre class="language-yaml" data-language="yaml"><code class="language-yaml">version: '3.9'services:    rsshub:        # two ways to enable puppeteer:        # * comment out marked lines, then use this image instead: diygod/rsshub:chromium-bundled        # * (consumes more disk space and memory) leave everything unchanged        image: diygod/rsshub        restart: always        ports:            - '1200:1200'        environment:            NODE_ENV: production            CACHE_TYPE: redis            REDIS_URL: 'redis://redis:6379/'            PUPPETEER_WS_ENDPOINT: 'ws://browserless:3000'  # marked            PROXY_URI: 'http://clash:7890'            YOUTUBE_KEY: 'xxxxxxxxxxxxxxxxxxxxxxxx' # 略        depends_on:            - clash            - redis            - browserless  # marked    browserless:  # marked        image: browserless/chrome  # marked        restart: always  # marked        ulimits:  # marked          core:  # marked            hard: 0  # marked            soft: 0  # marked        environment:          DEFAULT_LAUNCH_ARGS: '["--window-size=375,820","--proxy-server=http://clash:7890"]' # 代理服务         depends_on:          - clash    redis:        image: redis:alpine        restart: always        volumes:            - redis-data:/data     clash:        image: dreamacro/clash        restart: always        ports:          - "7890:7890"          - "7891:7891"          - "9090:9090"        volumes:          - /etc/clash:/root/.config/clashvolumes:    redis-data:</code></pre><p>命令部分：</p><pre class="language-bash" data-language="bash"><code class="language-bash"># 创建redis需要的data volumesudo docker create volume redis-data# RSSHub 启动！sudo docker compose up -d</code></pre><p>访问示例：</p><p>[bilibili]:</p><p><img src="/images/CNSS/rss_bilibili.png" alt="Bilibili Cherry"></p><p>[youtube]:</p><p><img src="/images/CNSS/rss_youtube.png" alt="Youtube"></p><h2 id="基础环境建设">基础环境建设</h2><h3 id="题目要求">题目要求</h3><ol><li><p>搭建基础环境，包括以下部分：</p><ul><li>git</li><li>docker</li><li>python 3</li><li>pip3</li><li>curl</li><li>ssh 禁用密码登录</li></ul></li><li><p>加分项</p><ul><li>一键脚本（见下）</li><li>一些奇怪的功能</li></ul></li></ol><h3 id="过程-3">过程</h3><p>本题基于夏令营的脚本基础上进行重构，除了基本要求，新增以下部分：</p><ol><li>多个发行版支持，有：<ul><li>Ubuntu (只要源里有就算支持)</li><li>CentOS 7 8（同上）</li><li>Arch Linux~~（这就是滚动更新给我的自信）~~</li></ul></li><li>支持切换安装源<br>目前支持阿里云、清华、中科大、网易源，并有交互可以修改。</li><li>一些个人配置<br>夏令营的存货，例如vim安装配置，安装zsh切换为默认shell，以及nodejs等等。</li></ol><p>脚本在WSL Ubuntu20.04和CentOS 7测试了一下，<s>不保证正确性</s></p><h3 id="Code">Code</h3><pre class="language-bash" data-language="bash"><code class="language-bash">#!/bin/bash# 重构了下原有的代码，看了下别人代码风格试着模仿了（# 只用过Ubuntu CentOS和Arch，就挑这三个发行版了function identify_the_linux_distribution(){    if [[ "$(uname)" == "Linux" ]]; then        if [[ "$(type -P apt)" ]]; then            PACKAGE_MANAGEMENT_INSTALL='sudo apt-get -y --no-install-recommends install'            PACKAGE_MANAGEMENT_UPDATE='sudo apt-get update &amp;&amp; sudo apt-get upgrade -y'            PACKAGE_MANAGEMENT_REMOVE='sudo apt-get purge'            LINUX_DISTRIBUTION='ubuntu'        elif [[ "$(type -P yum)" ]]; then            PACKAGE_MANAGEMENT_INSTALL='sudo yum -y install'            PACKAGE_MANAGEMENT_UPDATE='sudo yum makecache &amp;&amp; sudo yum -y upgrade'            PACKAGE_MANAGEMENT_REMOVE='sudo yum remove'            LINUX_DISTRIBUTION='centos'        elif [[ "$(type -P pacman)" ]]; then            PACKAGE_MANAGEMENT_INSTALL='sudo pacman -Syu --noconfirm'            PACKAGE_MANAGEMENT_UPDATE='sudo pacman -Syyu --noconfirm'            PACKAGE_MANAGEMENT_REMOVE='sudo pacman -Rsn'            LINUX_DISTRIBUTION='arch'        else              echo "error: The script does not support the package manager in this operating system."             exit 1        fi    else        echo "error: This OS is not supported."        exit 1    fi}function is_ip_cn(){    COUNTRY=$(curl ipinfo.io | grep "country" | awk '{print $2}')    if [ $COUNTRY == '"CN",' ]; then        LOCAL_COUNTRY="OTHER"    else        LOCAL_COUNTRY="CN"    fi}function update_software(){    $PACKAGE_MANAGEMENT_UPDATE    if [[ $PACKAGE_MANAGEMENT_UPDATE ]]; then        echo "info: update success."    else        echo "error: update failed!"        exit 1    fi}function install_software(){    package_name="$1"    file_to_detect="$2"    type -p "$file_to_detect" &gt; /dev/null 2&gt;&amp;1 &amp;&amp; return    if ${PACKAGE_MANAGEMENT_INSTALL} "$package_name"; then        echo "info: $package_name is installed."    else        echo "error: Installation of $package_name failed!"        exit 1    fi}function change_source() {    if [[ $LOCAL_COUNTRY == "CN" ]]; then        echo "WARNING: your linux is in CN so that change your source is recommended."    fi    echo "please choose a mirror:    1. aliyun    2. tsinghua    3. 163    4. ustc    "        read MIRROR_CHOOSE        if [ $MIRROR_CHOOSE -ne 1 ] &amp;&amp; [ $MIRROR_CHOOSE -ne 2 ] &amp;&amp; [ $MIRROR_CHOOSE -ne 3 ] &amp;&amp; [ $MIRROR_CHOOSE -ne 4 ]; then        echo 'error: input error.'        exit 1    fi    if [[ $LINUX_DISTRIBUTION == "ubuntu" ]]; then        echo "=========================================="        UBUNTU_VERSION=$(cat /etc/os-release | grep VERSION_CODENAME | awk -F "=" '{print $2}')        case $MIRROR_CHOOSE in            1)                UBUNTU_MIRROR_URL='http://mirrors.aliyun.com/ubuntu/'            ;;            2)                UBUNTU_MIRROR_URL='https://mirrors.tuna.tsinghua.edu.cn/ubuntu/'            ;;            3)                UBUNTU_MIRROR_URL='http://mirrors.163.com/ubuntu/'            ;;            4)                UBUNTU_MIRROR_URL='https://mirrors.ustc.edu.cn/ubuntu/'            ;;        esac        echo "==== Ubuntu version: $UBUNTU_VERSION ===="        echo "begin change your source($UBUNTU_MIRROR_URL)..."        sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak        echo "origin source.list is stored in /etc/apt/sources.list.bak"                echo "# 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释deb $UBUNTU_MIRROR_URL $UBUNTU_VERSION main restricted universe multiverse# deb-src $UBUNTU_MIRROR_URL $UBUNTU_VERSION main restricted universe multiversedeb $UBUNTU_MIRROR_URL $UBUNTU_VERSION-updates main restricted universe multiverse# deb-src $UBUNTU_MIRROR_URL $UBUNTU_VERSION-updates main restricted universe multiversedeb $UBUNTU_MIRROR_URL $UBUNTU_VERSION-backports main restricted universe multiverse# deb-src $UBUNTU_MIRROR_URL $UBUNTU_VERSION-backports main restricted universe multiverse# deb $UBUNTU_MIRROR_URL $UBUNTU_VERSION-security main restricted universe multiverse# \# deb-src $UBUNTU_MIRROR_URL $UBUNTU_VERSION-security main restricted universe multiversedeb http://security.ubuntu.com/ubuntu/ $UBUNTU_VERSION-security main restricted universe multiverse# deb-src http://security.ubuntu.com/ubuntu/ $UBUNTU_VERSION-security main restricted universe multiverse" | sudo tee /etc/apt/sources.list    elif [[ $LINUX_DISTRIBUTION == "centos" ]]; then        REDHAT_RELEASE=$(grep "CentOS" /etc/redhat-release)        if  echo "$REDHAT_RELEASE" | grep "release 7"         thenCENTOS_VERSION=7elif echo "$REDHAT_RELEASE" | grep "release 8"        thenCENTOS_VERSION=8elseecho "error: only support CentOS 7 and 8"            exit 1fi        sudo cp /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.bak        echo "origin CentOS-Base.repo is stored in /etc/yum.repos.d/CentOS-Base.repo.bak"        if [ $CENTOS_VERSION -eq 7 ]        then            case $MIRROR_CHOOSE in                1)                wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo                ;;                2)                sudo sed -e 's|^mirrorlist=|#mirrorlist=|g' \         -e 's|^#baseurl=http://mirror.centos.org/centos|baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos|g' \         -i.bak \         /etc/yum.repos.d/CentOS-*.repo                ;;                3)                sudo wget -O /etc/yum.repos.d/CentOS-Base.repo https://mirrors.163.com/.help/CentOS7-Base-163.repo                ;;                4)                sudo sed -e 's|^mirrorlist=|#mirrorlist=|g' \         -e 's|^#baseurl=http://mirror.centos.org/centos|baseurl=https://mirrors.ustc.edu.cn/centos|g' \         -i.bak \         /etc/yum.repos.d/CentOS-Base.repo                ;;            esac        else            case $MIRROR_CHOOSE in                1)                sudo wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-8.repo                 ;;                2)                sudo sed -e 's|^mirrorlist=|#mirrorlist=|g' \         -e 's|^#baseurl=http://mirror.centos.org/$contentdir|baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos|g' \         -i.bak \         /etc/yum.repos.d/CentOS-*.repo                ;;                3)                sudo wget -O /etc/yum.repos.d/CentOS-Base.repo https://mirrors.163.com/.help/CentOS8-Base-163.repo                ;;                4)                sudo sed -e 's|^mirrorlist=|#mirrorlist=|g' \         -e 's|^#baseurl=http://mirror.centos.org/$contentdir|baseurl=https://mirrors.ustc.edu.cn/centos|g' \         -i.bak \         /etc/yum.repos.d/CentOS-Stream-AppStream.repo \         /etc/yum.repos.d/CentOS-Stream-BaseOS.repo \         /etc/yum.repos.d/CentOS-Stream-Extras.repo \         /etc/yum.repos.d/CentOS-Stream-PowerTools.repo                ;;            esac        fi    elif [[ $LINUX_DISTRIBUTION == "arch" ]]; then        #reflect 在之前安装arch的时候很不好用，直接略了，这里只安装对应的源，以及社区源、yay。        sudo cp /etc/pacman.d/mirrorlist /etc/pacman.d/mirrorlist.bak        echo "origin mirrorlist is stored in /etc/pacman.d/mirrorlist.bak"        case $MIRROR_CHOOSE in            1)                echo 'Server = http://mirrors.aliyun.com/archlinux/$repo/os/$arch'&gt;/etc/pacman.d/mirrorlist            ;;            2)                echo 'Server = https://mirrors.tuna.tsinghua.edu.cn/archlinuxarm/$arch/$repo'&gt;/etc/pacman.d/mirrorlist            ;;            3)                echo 'Server = http://mirrors.163.com/archlinux/$repo/os/$arch'&gt;/etc/pacman.d/mirrorlist            ;;            4)                echo 'Server = https://mirrors.ustc.edu.cn/archlinux/$repo/os/$arch'&gt;/etc/pacman.d/mirrorlist            ;;        esac        echo 'choose a COMMUNITY SOURCE'        echo "        1. official        2. 163        3. tsinghua        "        read COMMUNITY_SOURCE        if [ $comm -ne 1 ]&amp;&amp;[ $comm -ne 2 ]; then            echo "error: input error."            exit 1        fi        echo "[archlinuxcn]"&gt;&gt;/etc/pacman.conf        case $COMMUNITY_SOURCE in            1)            echo 'Server = http://repo.archlinuxcn.org/$arch'&gt;&gt;/etc/pacman.conf            ;;            2)            echo 'Server = http://mirrors.163.com/archlinux-cn/$arch'&gt;&gt;/etc/pacman.conf            ;;            3)            echo 'Server = https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/$arch'&gt;&gt;/etc/pacman.conf            ;;        esac        install_software 'archlinuxcn-keyring' 'archlinuxcn-keyring'        install_software 'yay' 'yay'    fi    echo "=========================================="    echo "SUCCESS change $LINUX_DISTRIBUTION source!"}function install_zsh(){    echo "=========================================="    echo "begin install zsh..."    install_software 'zsh' 'zsh'    install_software 'git' 'git'    if [ $LOCAL_COUNTRY == "OTHER" ]; then        sh -c "$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)"    else        sh -c "$(curl -fsSL https://gitee.com/shmhlsy/oh-my-zsh-install.sh/raw/master/install.sh)" #国内镜像源    fi    chsh -s /bin/zsh    echo "=========================================="    echo "SUCCESS install zsh &amp; oh-my-zsh!"}function change_ssh_config(){    echo "=========================================="    echo "begin config ssh..."    sed -i 's/\(^[\s#]*\)ClientAliveInterval\(.*\)/ClientAliveInterval 60/'     sed -i 's/\(^[\s#]*\)ClientAliveCountMax\(.*\)/ClientAliveCountMax 10/'     sed -i 's/\(^[\s#]*\)PasswordAuthentication\(.*\)/PasswordAuthentication no/'    echo "=========================================="    echo "SUCCESS config ssh: 10 minutes Alive and no password auth"}function install_git(){    echo "=========================================="    echo "begin install git..."    install_software 'git' 'git'    echo -n "Your git name:"    read GIT_USERNAME    git config --global user.name $GIT_USERNAME    echo -n "Your git email:"    read GIT_EMAIL    git config --global user.email $GIT_EMAIL    git config --list    echo "=========================================="    echo "SUCCESS install git!"}function install_docker(){    echo "=========================================="    echo "begin install docker..."    if [[ "$LINUX_DISTRIBUTION" == "ubuntu" ]]; then        for pkg in docker.io docker-doc docker-compose podman-docker containerd runc; do            $PACKAGE_MANAGEMENT_REMOVE $pkg        done        install_software ca-certificates ca-certificates        install_software curl curl        install_software gnupg gnupg        sudo install -m 0755 -d /etc/apt/keyrings        curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg        sudo chmod a+r /etc/apt/keyrings/docker.gpg        echo \        "deb [arch="$(dpkg --print-architecture)" signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \        "$(. /etc/os-release &amp;&amp; echo "$VERSION_CODENAME")" stable" | \        sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null                update_software        for pkg in docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin; do            install_software $pkg $pkg        done        sudo systemctl enable docker        sudo systemctl start docker    elif [[ "$LINUX_DISTRIBUTION" == "centos" ]];then        for pkg in docker docker-client docker-client-latest docker-common docker-latest docker-latest-logrotate docker-logrotate docker-engine; do            $PACKAGE_MANAGEMENT_REMOVE $pkg        done        install 'yum-utils'        sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo        for pkg in docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin; do            install_software $pkg $pkg        done        sudo systemctl enable docker        sudo systemctl start docker    elif [[ "$LINUX_DISTRIBUTION" == "arch" ]]; then        install_software 'docker' 'docker'    fi    if [ $1 = "CN" ]; then     echo "{  \"registry-mirrors\": [\"https://docker.mirrors.ustc.edu.cn\"]}" | sudo tee -a /etc/docker/daemon.json    fi    sudo service docker restart    echo "=========================================="    echo "SUCCESS install docker!"}function install_nodejs_new(){    echo "=========================================="    echo "begin install nodejs..."    NOW_PWD=$(pwd)    cd /usr/local/src/    sudo wget https://nodejs.org/dist/v18.17.0/node-v18.17.0.tar.gz    sudo tar -zxvf node-v18.17.0.tar.gz    cd node-v18.17.0    sudo ./configure    sudo make    sudo make install    cd $NOW_PWD    if [ $1 = "CN" ]; then    npm config set registry https://registry.npm.taobao.org    npm config get registry    npm install -g cnpm --registry=https://registry.npm.taobao.org    fi    echo "=========================================="    echo "SUCCESS install newest nodejs!"}function install_vim(){    install_software 'vim' 'vim'    echo "set laststatus=2set numberset noebset ts=4set softtabstop=4set shiftwidth=4set expandtabset autoindent" | tee ~/.vimrc}function install_python3_pip(){    if [[ $LINUX_DISTRIBUTION == "ubuntu" ]]; then        install 'python3' 'python3'    elif [[ $LINUX_DISTRIBUTION == "centos" ]]; then        install 'python3' 'python3'    elif [[ $LINUX_DISTRIBUTION == "arch" ]]; then        install_software 'python' 'python'        echo "WARNING: arch linux doesn't use pip3 to install python package, use 'sudo pacman -S python-xxx' instead."    fi}function config_system_proxy(){    if [ $LOCAL_COUNTRY == "OTHER" ]; then        return 0    fi    echo "=========================================="    echo "begin config your proxy..."    echo "Your HTTP PROXY:"    read HTTP_PROXY    echo "Your HTTPS PROXY?:"    read HTTPS_PROXY    echo "export HTTP_PROXY=\"$HTTP_PROXY\"" | sudo tee -a /etc/profile.d/proxy.sh    echo "export HTTPS_PROXY=\"$HTTPS_PROXY\"" | sudo tee -a /etc/profile.d/proxy.sh    sudo chmod u+x /etc/profile.d/proxy.sh    source /etc/profile.d/proxy.sh    echo "=========================================="}function main(){    identify_the_linux_distribution    install_software 'curl' 'curl'    is_ip_cn    change_source    # update_software     install_git    install_docker    install_python3_pip    install_vim    install_zsh    # 源码编译nodejs过慢，略了    # install_nodejs_new }main#config_system_proxy</code></pre><h2 id="萌新也想搭载上……A-引擎！">萌新也想搭载上……A-引擎！</h2><h3 id="题目要求-2">题目要求</h3><p>使用 Apache 实现以下要求：</p><blockquote><ol><li>使用一个 Apache 实例代理 3 个页面，不同的端口号访问到不同的页面</li><li>实现 URL 转发： 当 URI 请求为 /google 时，跳转到谷歌；当 URI 请求为 /github 时，跳转到 GitHub ；当 URI 请求为/cnss或/cnss/xxx 时，xxx 是任意字符串，跳转到 CNSS 招新官网；其余任意请求跳转到静态页面</li><li>搭建一个简易文件下载服务器，访问 /downloads 能够显示文件目录。</li><li>实现一个简单的负载均衡器，当访问同一个 URL 时，按照流量比 1 : 2 : 3 分别访问到 3 个不同的页面.</li><li>syrinka 的朋友圈有很多大佬，为了膜拜这些大佬教他技术，他每天都会“轮询”拜访这些大佬的博客，并制作了一个 “URL 轮询器”来达到目的，访问该 URL 时，轮询跳转到大佬们的博客，请聪明的你也实现一个吧！</li></ol></blockquote><p>完成基本部分，无加分项。</p><h3 id="过程-4">过程</h3><h4 id="环境">环境</h4><blockquote><p>CentOS httpd(Apache服务器的CentOS版本)<br>python+flask</p></blockquote><h4 id="其他配置准备">其他配置准备</h4><p>静态文件部分，保存在/var/www下，目录结构如下所示：</p><pre class="language-bash" data-language="bash"><code class="language-bash">/var/www├── cgi-bin├── downloads│   ├── kknd│   └── logo.png└── html    ├── h1    │   └── index.html    ├── h2    │   └── index.html    ├── h3    │   └── index.html    └── todo        ├── index.html        ├── script.js        └── style.css</code></pre><p>python部分是为了完成URL轮询器。apache不像nginx，负载均衡的默认轮询算法不基于确定顺序(emmm，查不到原因捏)，因此无法像nginx那样通过upstream直接实现，用python+flask实现如下：</p><p><code>app.py</code></p><pre class="language-python" data-language="python"><code class="language-python">from flask import Flask, redirectapp=Flask(__name__)i=0url = [        'https://www.sh1no.icu/',        'https://yaossg.com',        'https://www.cnblogs.com/timlzh/',        'https://www.skyecho.fun/']@app.route('/')def index():        global i        true_url=url[i]        i+=1        i%=len(url)        return redirect(true_url)if __name__ == '__main__':        app.run(port=8084)</code></pre><p>另外，本机在<code>/etc/host</code> 添加 <code>127.0.0.1 zzzremake.eu.org</code></p><hr><p>httpd是有分主配置文件<code>/etc/httpd/conf/httpd.conf</code>和其他配置文件<code>/etc/httpd/conf.d/*.conf</code>，主配置文件中，除了Listen的端口修改外，其他保持默认。</p><p>主配置文件<code>/etc/httpd/conf/httpd.conf</code>(部分)</p><pre class="language-apache" data-language="apache"><code class="language-apache">ServerRoot "/etc/httpd"Listen 8080Listen 8081Listen 8082Listen 8083</code></pre><p>其他配置文件:<br><code>...../conf.d/h1_3.conf</code></p><p>完成 不同的端口号访问到不同的页面 部分。</p><pre class="language-apache" data-language="apache"><code class="language-apache">Define htmlroot "/var/www/html"&lt;VirtualHost zzzremake.eu.org:8081&gt;    DocumentRoot "${htmlroot}/h1"    DirectoryIndex index.html    ServerName zzzremake.eu.org:8081    &lt;Directory "${htmlroot}/h1"&gt;        Options Indexes FollowSymLinks        AllowOverride None        Require all granted    &lt;/Directory&gt;&lt;/VirtualHost&gt;&lt;VirtualHost zzzremake.eu.org:8082&gt;    DocumentRoot "${htmlroot}/h2"    DirectoryIndex index.html    ServerName zzzremake.eu.org:8082    &lt;Directory "${htmlroot}/h2"&gt;        Options Indexes FollowSymLinks        AllowOverride None        Require all granted    &lt;/Directory&gt;&lt;/VirtualHost&gt;&lt;VirtualHost zzzremake.eu.org:8083&gt;    DocumentRoot "${htmlroot}/h3"    DirectoryIndex index.html    ServerName zzzremake.eu.org:8083    &lt;Directory "${htmlroot}/h3"&gt;        Options Indexes FollowSymLinks        AllowOverride None        Require all granted    &lt;/Directory&gt;&lt;/VirtualHost&gt;</code></pre><p><code>...../conf.d/url_redirect.conf</code></p><pre class="language-apache" data-language="apache"><code class="language-apache">RewriteEngine on&lt;VirtualHost zzzremake.eu.org:8080&gt;    ServerName zzzremake.eu.org:8080    DocumentRoot /var/www/html/todo        RewriteRule "^/google$" "https://www.google.com" [R=301,L]    RewriteRule "^/github$" "https://github.com" [R=301,L]    RewriteRule "^/cnss$" "https://recruit.cnss.io" [R=301,L]    RewriteRule "^/cnss/.*" "https://recruit.cnss.io" [R=301,L]    # RewriteRule "^(/downloads)$" "$1/" [L]    RewriteRule "^(/visit)$" "http://127.0.0.1:8084" [P,L]        RewriteCond %{REQUEST_URI} !^/downloads     RewriteRule "^/.+$" "http://127.0.0.1:8080/" [R,L]     ProxyRequests off       &lt;Proxy balancer://balance&gt;        BalancerMember http://zzzremake.eu.org:8081 loadfactor=1        BalancerMember http://zzzremake.eu.org:8082 loadfactor=2        BalancerMember http://zzzremake.eu.org:8083 loadfactor=3        ProxySet lbmethod=bytraffic    &lt;/Proxy&gt;    ProxyPass /balance balancer://balance    ProxyPassReverse /balance balancer://balance    Alias /downloads/ /var/www/downloads/    &lt;Directory "/var/www/html/todo"&gt;        Options Indexes FollowSymlinks        AllowOverride None        Require all granted    &lt;/Directory&gt;    &lt;Directory "/var/www/downloads"&gt;        Options Indexes FollowSymLinks        AllowOverride None        Require all granted    &lt;/Directory&gt;&lt;/VirtualHost&gt;</code></pre><h2 id="我要成为组网高手！">我要成为组网高手！</h2><h3 id="题目要求-3">题目要求</h3><p>使用任意网络模拟器（本题选用PacketTracer）完成如下图所示的</p><p><img src="/images/CNSS/network.png" alt="network"></p><p>并完成以下要求：</p><ol><li><p>基本要求</p><ul><li>完成 10.0.10.0/24 与 10.0.20.0/24 网段的搭建，使 PC0 至 PC3 可以互通</li><li>完成 10.0.30.0/24 网段的搭建，并为 Edge_Route 与 Side_Route 配置动态路由协议，在不使用静态路由的前提下，使 PC0 至 PC4 可以互通</li><li>配置 ICP，并为其配置静态路由，使 PC0 至 PC4 可以连通 ICP</li><li>假设 ICP 所在的网段为外网，PC0 至 PC3 所在的网段为内网，为 Edge_Route 配置 NAT</li></ul></li><li><p>加分项</p><ul><li>15% 配置 VLAN，令 PC0 与 PC2 加入 vlan10，PC1 与 PC3 加入 vlan20</li><li>[ ] 25% 将 Edge_Route 替换为防火墙，并配置规则，使：<br>PC0-3 能连通 PC4、Edge_Route、ICP<br>PC4 能连通 Edge_Route、ICP、不能连通 PC0-3<br>ICP 不能连通 PC0-4、Edge_Route</li><li>[ ] 10% 使用 HCL 完成本题（因为它真的要全程用命令行，这是授予明知山有虎偏向虎山行的勇士的奖励）</li></ul></li></ol><h3 id="过程-5">过程</h3><h4 id="基本部分">基本部分</h4><p>网段搭建部分就不提了，这部分只要网关和ip地址对了就行。</p><p>动态路由部分，设置ospf 1和area 0. 需要注意的是ping用的ICMP是一个来回的过程，所以要配双向路由。</p><p>配置静态路由部分，也是一样要注意双向路由都要配置。</p><p>NAT部分，静态NAT无法满足需求，动态NAT也要多IP的pool，采用端口映射PAT。</p><h4 id="加分项部分">加分项部分</h4><p>VLAN配似了，结果出错了（</p><p><img src="/images/CNSS/nishi_.png" alt="某出题人的回答"></p><p>路由器的子端口无法单独配置VLAN ID，因此当出现题目所示的配置时，会因为子网冲突而无法配置单臂路由的网关，到最后只能在一个子接口有对应的ip地址。<br>因此，VLAN间无法互通。</p><p><s>但原意似乎就是配trunk和access口就行了</s></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> CNSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CNSS </tag>
            
            <tag> DevOps </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT 6.S081 Lab1-3 begin xv6</title>
      <link href="/2023/11/09/mit-6.s081-lab1-3-begin-xv6/"/>
      <url>/2023/11/09/mit-6.s081-lab1-3-begin-xv6/</url>
      
        <content type="html"><![CDATA[<p>去年这个时候我刚开始写现代密码学的博客，过了一年开了个这个，令人感叹。</p><h2 id="配环境">配环境</h2><p>第一次配环境的时候wsl给我搞崩了，可能是wsl的Ubuntu版本不同，导致源和官方文档不太一样。反正没什么重要东西，卸载重装！</p><p>具体方法详见<a href="https://pdos.csail.mit.edu/6.828/2021/tools.html">官方文档</a>，我自己的环境配置为：</p><blockquote><p>wsl2+Ubuntu20.04<br>具体环境及配置命令同官方文档。</p></blockquote><h3 id="一些命令">一些命令</h3><ol><li><p><code>make qemu</code> 启动qemu以及xv6。<br>课程评测文件<code>grade-lab-util</code>是py文件，所以既可以用<code>./grade-lab-util xxxx</code>评测，也可以加个python启动。</p></li><li><p><code>echo "add-auto-load-safe-path /home/remake/remake_dev/xv6-labs-2021/.gdbinit" &gt;&gt; ~/.gdbinit</code> 让<code>gdb-multiarch</code>可以调试xv6程序。调试时需要注意make qemu的flag添加（</p></li></ol><h2 id="Lab-1-Util">Lab 1 Util</h2><p>主要通过类POSIX接口实现用户的一些功能。</p><h3 id="课程">课程</h3><p>大体其实和普通的OS差不多，但6.S081的一大特点是上来就讲代码，因此很多操作系统课不会讲的代码具体实现在课程里会详细介绍。</p><p>除了xv6代码的细节，例如程序必须exit(0)退出，exec载入elf格式文件等，值得讲的就是fork和exec的I/O和File的descriptors，一切似乎都是水到渠成。</p><hr><p>file descriptor作为一种流的抽象，被广泛应用于UNIX的各个部分（除了network，虽然有类似实现但又存在不同），诸如管道等。</p><p>fork在普通OS课程中只会用变量等例子来展示"子进程是父进程的复制"，但不仅于此。fork在复制程序本身的情况下还复制了父进程的文件描述符表，而exec虽然改变了程序（通过load的image），但不会对文件描述符表进行改变。</p><p>因此，父进程可以通过临时改变文件描述符来操作子进程的描述符，子进程只知道描述符本身，而不知道描述符后面代表的是文件，设备、或者管道。</p><p>另外，fork虽然复制了描述符表，但每个描述符下的偏移量是独立的。因此，两个进程的描述符下可能是同一个东西，共享同一个偏移量。</p><hr><p>既然介绍了这么多，那么pipe也就水到渠成了。父进程和子进程共享一个descriptor。在实际的操作中，一端操作需要对另一端进行关闭，否则便会一直阻塞。pipe的语义中，read返回需要：</p><ol><li>write字节</li><li>写入端关闭</li></ol><p>因此，需要按需关闭pipe。</p><hr><p>最后一个可以关注的点便是shell内置命令。Unix时代经常把mkdir等命令内置，但Unix将其作为可执行程序，从PATH中寻找。但cd命令不同，如果用传统的fork-exec来进行，改变的只有子进程的工作目录，shell并不会关注子进程的这一信息。</p><h3 id="Sleep-easy">Sleep (easy)</h3><p>简单的系统调用。</p><pre class="language-c" data-language="c"><code class="language-c">#include "kernel/types.h"#include &lt;user/user.h&gt;void my_sleep(const char* argument){    int sleep_second = atoi(argument);    sleep(sleep_second);}int main(int argc, char const *argv[]){    if(argc &lt;= 1){        fprintf(2, "usage: sleep need number(second).\n");        exit(1);    }    if(argc &gt;=3){        fprintf(2, "error: too many argument.(sleep)\n");    }    my_sleep(argv[1]);    exit(0);}</code></pre><h3 id="pingpong-easy">pingpong (easy)</h3><p>简单的进程间通信，理解了pipe和fork的关系就行。</p><pre class="language-c" data-language="c"><code class="language-c">//Simple pingpong: pipe.#include &lt;kernel/types.h&gt;#include &lt;user/user.h&gt;int main(int argc, char const *argv[]) {    int p[2];    char buf[2];        if(pipe(p)&lt;0){        fprintf(2, "error: pipe exit(pingpong)\n");        exit(1);    }    int pid = fork();    if(pid == 0){        //child        int read_bytes = read(p[0], buf, 1);        close(p[0]);        if(read_bytes&gt;0){            int now_pid = getpid();            printf("%d: received ping\n", now_pid);            write(p[1], buf, 1);            close(p[1]);        } else {            exit(1);        }    } else if(pid&gt;0){        //parent        char *buf="y";        char* buf_test="y";        write(p[1], buf, 1);        close(p[1]);        int read_bytes = read(p[0], buf, 1);        close(p[0]);        if(read_bytes&gt;0){            int now_pid = getpid();            if(strcmp(buf, buf_test)){                printf("%d: received pong\n", now_pid);                           }        }    } else {        fprintf(2, "error: fork(pingpong)\n");    }    return 0;}</code></pre><h3 id="primes-moderate-hard">primes (moderate)/(hard)</h3><p>抽象起来了。</p><p>问题在于理解下面这张图：</p><p><img src="https://swtch.com/~rsc/thread/sieve.gif" alt="primes"></p><p>可以看到，主进程fork完后，便一直向子进程发送递增数据，而子程序接受数据后，需要视情况fork，然后传递数据。</p><p>其主要伪代码为：</p><pre class="language-python" data-language="python"><code class="language-python">p = get a number from left neighborprint ploop:    n = get a number from left neighbor    if (p does not divide n)        send n to right neighbor</code></pre><pre class="language-c" data-language="c"><code class="language-c">#include &lt;kernel/types.h&gt;#include &lt;user/user.h&gt;void prime(int*fd){    int p, d;    close(fd[1]);    if(read(fd[0], &amp;p, 4)==0){        exit(0);    }    printf("prime %d\n", p);    if (read(fd[0], (void *)&amp;d, sizeof(d))){        int fd1[2];        pipe(fd1);        if (fork() == 0){            prime(fd1);        }else{            // 关闭读            close(fd1[0]);            do{                if (d % p != 0){                    write(fd1[1], (void *)&amp;d, sizeof(d));                }            }while(read(fd[0], (void *)&amp;d, sizeof(d)));            // 关闭读            close(fd[0]);            // 关闭写            close(fd1[1]);            wait(0);        }    }    exit(0);}int main(int argc, char const *argv[]) {    int p[2];    pipe(p);    int pid=fork();    if(pid==0){        prime(p);    } else if(pid&gt;0){        close(p[0]);        for(int i = 2;i&lt;=35;++i){            write(p[1], &amp;i, 4);        }        close(p[1]);        wait((int*)0);    } else {        fprintf(2, "error: fork(prime).\n");    }    exit(0);}</code></pre><p>当时犯了两错误。</p><ol><li>题目一眼用函数递归实现，但当时钻了牛角尖非得在main函数实现，甚至打算用goto了。</li><li>函数顺序应该是<code>read -- read -- fork</code> ，这样第二个read便可以成为停止条件；而我当时理解成了 <code>read -- fork -- read</code> 这会导致一个进程一直在等待信息，从而无法退出程序。</li></ol><h3 id="xargs-moderate">xargs (moderate)</h3><p>注意读题（</p><p>本题并没有什么难度，但做的时候读错题意导致后面代码可读性很差，最后还是参考了别人，令人感叹。</p><p>注意要用exec实现，第一次实现的时候虽然过了但并不是exec实现。</p><pre class="language-c" data-language="c"><code class="language-c">#include &lt;kernel/types.h&gt;#include &lt;kernel/param.h&gt;#include &lt;user/user.h&gt;void copy(char **p1, char *p2){    *p1 = malloc(strlen(p2) + 1);    strcpy(*p1, p2);}int readline(char** parm, int begin){    char buf[512];        int i = 0;    while(read(0, buf+i, 1)){        if(buf[i]=='\n'){            buf[i]=0;            break;        }        ++i;    }    if(i==0){        return 0;    }    int j = 0;    while(j&lt;i){        if(begin&gt;MAXARG){            fprintf(2, "too many parameters!(xargs)\n");            exit(1);        }        int temp = j;        while((j&lt;i)&amp;&amp;(buf[j]!=' ')){            ++j;        }        buf[j++] = 0;        copy(&amp;parm[i], buf+temp);    }    return begin;}int main(int argc, char *argv[]){    if(argc&lt;2){        fprintf(2, "Please enter more parameters.(xargs)\n");        exit(1);    }    char*pars[MAXARG];    for(int i = 1;i&lt;argc;++i){        copy(&amp;pars[i-1], argv[i]);    }    int end;    end=readline(pars, argc-1);    while(end){        pars[end]=0;        if(fork()==0){            for(int i =0;i&lt;end;++i){                printf("%s\n", pars[i]);            }            //exec(pars[0], pars);            exit(1);        } else {            wait(0);        }        end=readline(pars, argc-1);    }    exit(0);}</code></pre><h2 id="Lab-2-system-calls">Lab 2 system calls</h2><h3 id="课程-2">课程</h3><p>似乎从lab2开始，便深入xv6细节，而不关注UNIX等其他系统的接口了（但xv6还是类UNIX嘛）</p><hr><div class="admonition info"><p class="admonition-title">misc</p><p>qemu模拟器模拟了ROM, RAM, Disk和 serial connection to 用户的屏幕/键盘。</p><p>RISC-V具有三个模式：machine supervisor和user mode，一般的特权指令是指supervisor mode，user space要调用系统调用的时候，需要在寄存器先设置好参数，再通过ecall指令到特权模式，通过sret退出。</p></div><p>xv6的地址空间为39bit，而xv6只用其中的38bit。逻辑空间最大值MAXVA=$2^{38}-1$。<br>进程抽象为proc结构，其中存储着诸如pagetable等成员。同时，进程维护着两个堆栈，用户堆栈和内核堆栈kstack，内核堆栈在进入特权模式下使用且独立，因此进程破坏的时候，kernel仍然能在kstack中执行。</p><hr><p>xv6的启动过程中：</p><ol><li>首先在bootloader（ROM）读取引导程序，引导程序将xv6 kernel载入内存在_entry中（entry.S）：</li></ol><pre class="language-risc-v" data-language="risc-v"><code class="language-risc-v">.section .text.global _entry_entry:        # set up a stack for C.        # stack0 is declared in start.c,        # with a 4096-byte stack per CPU.        # sp = stack0 + (hartid * 4096)        la sp, stack0        li a0, 1024*4        csrr a1, mhartid        addi a1, a1, 1        mul a0, a0, a1        add sp, sp, a0        # jump to start() in start.c        call startspin:        j spin</code></pre><p>RISC-V（此时为machine mode）启动的时候禁用了分页硬件，因此程序的虚拟地址直接映射入物理地址。</p><p>loader直接将kernel映射入物理地址0x80000000，这也是qemu的入口地址。0到80000000的这一部分则是IO设备。</p><ol start="2"><li>entry.S创建了C代码所需的栈stack0，并启动了start function(start.c)</li><li>start.c将mode转为supervisor（通过mret）并载入main函数地址（mepc）以及其他必要设置，如委托中断和异常给supervisor mode，启动clock等，最后将pc转为main函数。</li><li>main函数启动必要的配置，在userinit里创建第一个进程。</li><li>进程执行initcode.S汇编程序，invoke exec 系统调用，转变为/init。当kernel执行exec完毕，将会返回/init 进程，该进程会执行诸如打开标准文件描述符和启动shell等任务。</li></ol><div class="admonition note"><p class="admonition-title">main函数干了什么？</p><p>kinit：设置page allocatorkvminit：设置虚拟内存kvminitstart：打开页表processinit：设置初始进程trapinit：设置user/kernel mode转换代码plicinit：中断控制器binit：buffer cachefileinit：文件系统virtio_disk_init：初始化磁盘userinit：启动第一个进程</p></div><h3 id="System-call-tracing-moderate">System call tracing (moderate)</h3><p>还是读题问题。英语太差是这样的。</p><p>这题讲明了需要在proc结构里增加变量来实现tracing。因此，系统调用trace只需要改变调用进程的mask，fork的子进程便会继承mask(修改fork实现)。</p><p>当进行系统调用的时候，syscall函数便会检查mask，默认0，其他情况便可以检查来打印具体函数。</p><hr><ol><li>proc结构里增加mask字段来记录要trace的系统调用。</li><li><code>kernel/syscall.c</code>改为：</li></ol><pre class="language-c" data-language="c"><code class="language-c">void syscall(void){  int num;  struct proc *p = myproc();  num = p-&gt;trapframe-&gt;a7; // 记录系统调用  if(num &gt; 0 &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) {    p-&gt;trapframe-&gt;a0 = syscalls[num](); //返回值记录a0    if((1 &lt;&lt; num) &amp; p-&gt;mask){      printf("%d: syscall %s -&gt; %d\n",        p-&gt;pid, sysnames[num], p-&gt;trapframe-&gt;a0);    }  } else {    printf("%d %s: unknown sys call %d\n",            p-&gt;pid, p-&gt;name, num);    p-&gt;trapframe-&gt;a0 = -1;  }}</code></pre><ol start="3"><li><code>kernel/sysproc.c</code> 添加：</li></ol><pre class="language-c" data-language="c"><code class="language-c">uint64 sys_trace(void){   uint64 mask;  if(argaddr(0, &amp;mask)&lt;0)    return -1;  myproc()-&gt;mask = mask;  return 0;}</code></pre><p>剩余的诸如修改fork和头文件等略。</p><h3 id="Sysinfo-moderate">Sysinfo (moderate)</h3><p>具体函数用法需要看具体的用例。lab已经给出用法：在<code>kernel/file.c</code>里头。</p><p>重要的就是<code>arg</code>函数以及<code>copyout</code>函数使用。</p><hr><ol><li><code>kernel/kalloc.c</code>里增加：</li></ol><pre class="language-c" data-language="c"><code class="language-c">uint64 get_memory_count(void){  uint64 count=0;  struct run*r = kmem.freelist;  while(r){    count+=PGSIZE;    r = r-&gt;next;  }  return count;}</code></pre><ol start="2"><li><code>kernel/proc.c</code>增加：</li></ol><pre class="language-c" data-language="c"><code class="language-c">int get_process_count(void){  int count = 0;  struct proc* p;  for(p = proc; p &lt; &amp;proc[NPROC]; p++) {      if(p-&gt;state != UNUSED){        count++;      }  }  return count;}</code></pre><ol start="3"><li><code>kernel/sysproc.c</code> 增加系统调用：</li></ol><pre class="language-c" data-language="c"><code class="language-c">uint64 sys_sysinfo(void){  uint64 info;  struct sysinfo nowinfo;  if(argaddr(0, &amp;info) &lt; 0)    return -1;  nowinfo.freemem = get_memory_count();  nowinfo.nproc = get_process_count();    struct proc *p = myproc();  if(copyout(p-&gt;pagetable, info, (char*)&amp;nowinfo, sizeof(nowinfo))&lt;0)    return -1;  return 0;}</code></pre><p>其他修改同trace。</p><h2 id="Lab-3">Lab 3</h2><h3 id="课程-3">课程</h3><p>这里试图对xv6的内核页表挂载流程进行梳理。</p><h4 id="pre">pre</h4><p>xv6在c代码中写明了具体的过程。在这之前，先看看用到的结构：</p><pre class="language-c" data-language="c"><code class="language-c">//链表结构struct run {  struct run *next;};//lock并发+freelist结构struct {  struct spinlock lock;  struct run *freelist;} kmem;//匿名结构：kmem管理内核页表</code></pre><p>main函数中关于内核页表的内容有：</p><pre class="language-c" data-language="c"><code class="language-c">kinit();         // physical page allocatorkvminit();       // create kernel page tablekvminithart();   // turn on paging</code></pre><p>下面内容主要为kalloc.c。</p><h4 id="kinit">kinit</h4><p>首先看看kinit：初始化lock和内核页表，将内核页表挂载到物理内存中</p><pre class="language-c" data-language="c"><code class="language-c">void kinit(){  initlock(&amp;kmem.lock, "kmem");  freerange(end, (void*)PHYSTOP);}//end在kalloc.c声明为`extern char []`，实际上的end在kernel.ld出现，其代表内核后的第一个地址.//PHYSTOP 为宏定义：#define KERNBASE 0x80000000#define PHYSTOP (KERNBASE + 128*1024*1024)//其代表 内存空间为128M.</code></pre><p>kernel的逻辑地址和物理地址如下所示：</p><p><img src="/images/OS/xv6_kernel.png" alt="xv6 logical address to physical address"></p><p>内核挂载在逻辑地址0x8000000（KERNBASE）,内核空间到PHYSTOP。由于kinit的时候还未有页表结构，此时的逻辑地址是直接映射到物理空间的。</p><p>freerange如下：</p><pre class="language-c" data-language="c"><code class="language-c">#define PGSIZE 4096#define PGROUNDUP(sz) (((sz)+PGSIZE-1) &amp; ~(PGSIZE-1))//这里的输入为物理地址voidfreerange(void *pa_start, void *pa_end){  char *p;  p = (char*)PGROUNDUP((uint64)pa_start);  for(; p + PGSIZE &lt;= (char*)pa_end; p += PGSIZE)    kfree(p);}</code></pre><p>可以看到，以上过程中对pa_start到pa_end的所有空间进行kfree(即初始化)。<br>xv6中每页长度固定为4096，PGROUNDUP操作的含义是页表首地址往上取整，例如输入（页表0）0000则返回（页表0）0000，若输入（页表0）0001则返回（页表1）0000。</p><p>end是kernel后的第一个地址，因此可能没有进行内存对齐。PGROUNDUP则将内核页表的每个页进行内存对齐，内核和内核页表间存在空闲空间。对齐的意义不用多说，其可以简化许多操作，上过计组的都知道罢。</p><p>kfree操作如下所示：</p><pre class="language-c" data-language="c"><code class="language-c">void kfree(void *pa){  struct run *r;  if(((uint64)pa % PGSIZE) != 0 || (char*)pa &lt; end || (uint64)pa &gt;= PHYSTOP)    panic("kfree");  // Fill with junk to catch dangling refs.  memset(pa, 1, PGSIZE);  r = (struct run*)pa;  acquire(&amp;kmem.lock);  r-&gt;next = kmem.freelist;  kmem.freelist = r;  release(&amp;kmem.lock);}</code></pre><p>kfree 对数据进行必要检查后，memset为1（若错误访问，memset为1期望能够更快地引发异常，终止过程），然后填充链表。</p><p>连带着，解释以下kalloc：</p><pre class="language-c" data-language="c"><code class="language-c">void * kalloc(void){  struct run *r;  acquire(&amp;kmem.lock);  r = kmem.freelist;  if(r)    kmem.freelist = r-&gt;next;  release(&amp;kmem.lock);  if(r)    memset((char*)r, 5, PGSIZE); // fill with junk  return (void*)r;}</code></pre><p>kalloc 将free链表的表头去掉free后，初始化内存并返回物理地址（kernel）</p><h4 id="kvminit">kvminit</h4><p>kvminit紧接着kinit的初始化，开始分配内核页表。</p><p>其内部为：</p><pre class="language-c" data-language="c"><code class="language-c">// the kernel's page table.pagetable_t kernel_pagetable;void kvminit(void){  kernel_pagetable = kvmmake();}pagetable_t kvmmake(void){  pagetable_t kpgtbl;  kpgtbl = (pagetable_t) kalloc();  memset(kpgtbl, 0, PGSIZE);  // uart registers  kvmmap(kpgtbl, UART0, UART0, PGSIZE, PTE_R | PTE_W);  // virtio mmio disk interface  kvmmap(kpgtbl, VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W);  // PLIC  kvmmap(kpgtbl, PLIC, PLIC, 0x400000, PTE_R | PTE_W);  // map kernel text executable and read-only.  kvmmap(kpgtbl, KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X);  // map kernel data and the physical RAM we'll make use of.  kvmmap(kpgtbl, (uint64)etext, (uint64)etext, PHYSTOP-(uint64)etext, PTE_R | PTE_W);  // map the trampoline for trap entry/exit to  // the highest virtual address in the kernel.  kvmmap(kpgtbl, TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X);  // map kernel stacks  proc_mapstacks(kpgtbl);    return kpgtbl;}</code></pre><p>kvminit调用kvmmake，而kvmmake对每一段进行具体的分配。为什么要这么分配？见上图。</p><p>kvmmake:</p><pre class="language-c" data-language="c"><code class="language-c">void kvmmap(pagetable_t kpgtbl, uint64 va, uint64 pa, uint64 sz, int perm){  if(mappages(kpgtbl, va, sz, pa, perm) != 0)    panic("kvmmap");}</code></pre><p>kvmmap 调用mappages来分配va到pa的满足size=sz的PTE页表项。</p><h4 id="mappages">mappages</h4><p>mappages如下所示：</p><pre class="language-c" data-language="c"><code class="language-c">#define PGROUNDDOWN(a) (((a)) &amp; ~(PGSIZE-1))// Create PTEs for virtual addresses starting at va that refer to// physical addresses starting at pa. va and size might not// be page-aligned. Returns 0 on success, -1 if walk() couldn't// allocate a needed page-table page.int mappages(pagetable_t pagetable, uint64 va, uint64 size, uint64 pa, int perm){  uint64 a, last;  pte_t *pte;  if(size == 0)    panic("mappages: size");    a = PGROUNDDOWN(va);  last = PGROUNDDOWN(va + size - 1);  for(;;){    if((pte = walk(pagetable, a, 1)) == 0)      return -1;    if(*pte &amp; PTE_V)      panic("mappages: remap");    *pte = PA2PTE(pa) | perm | PTE_V;    if(a == last)      break;    a += PGSIZE;    pa += PGSIZE;  }  return 0;}</code></pre><p>mappages 通过walk获得分配后的页表项地址，进行一系列检查后持续进行，直到满足size要求。size和va不必进行对齐，函数内部通过PGROUNDDOWN 进行页表项地址向下对齐。</p><h4 id="walk">walk</h4><p>walk用到的宏比较多，这里列出：</p><pre class="language-c" data-language="c"><code class="language-c">#define MAXVA (1L &lt;&lt; (9 + 9 + 9 + 12 - 1))#define PXMASK          0x1FF // 9 bits#define PXSHIFT(level)  (PGSHIFT+(9*(level)))#define PX(level, va) ((((uint64) (va)) &gt;&gt; PXSHIFT(level)) &amp; PXMASK)#define PTE2PA(pte) (((pte) &gt;&gt; 10) &lt;&lt; 12)#define PA2PTE(pa) ((((uint64)pa) &gt;&gt; 12) &lt;&lt; 10)</code></pre><ol><li>MAXVA就是xv6的最高地址，这里分拆来写，maybe让人明白页表和页内偏移的位数吧。</li><li>PX部分通过level和虚拟地址来获得第level级页表项的index。</li><li>PTE2PA的两个组是进行页表项和物理地址的互转。</li></ol><p>walk 代码如下：</p><pre class="language-c" data-language="c"><code class="language-c">// Return the address of the PTE in page table pagetable// that corresponds to virtual address va.  If alloc!=0,// create any required page-table pages.//// The risc-v Sv39 scheme has three levels of page-table// pages. A page-table page contains 512 64-bit PTEs.// A 64-bit virtual address is split into five fields://   39..63 -- must be zero.//   30..38 -- 9 bits of level-2 index.//   21..29 -- 9 bits of level-1 index.//   12..20 -- 9 bits of level-0 index.//    0..11 -- 12 bits of byte offset within the page.pte_t *walk(pagetable_t pagetable, uint64 va, int alloc){  if(va &gt;= MAXVA)    panic("walk");  for(int level = 2; level &gt; 0; level--) {    pte_t *pte = &amp;pagetable[PX(level, va)];    if(*pte &amp; PTE_V) {      pagetable = (pagetable_t)PTE2PA(*pte);    } else {      if(!alloc || (pagetable = (pde_t*)kalloc()) == 0)        return 0;      memset(pagetable, 0, PGSIZE);      *pte = PA2PTE(pagetable) | PTE_V;    }  }  return &amp;pagetable[PX(0, va)];}</code></pre><p>可以看到，以上过程中相当于模拟了页表的寻址过程。通过三级的页表方式来分配页表，并返回PTE的address。</p><h4 id="proc-mapstacks">proc_mapstacks</h4><pre class="language-c" data-language="c"><code class="language-c">// Allocate a page for each process's kernel stack.// Map it high in memory, followed by an invalid// guard page.voidproc_mapstacks(pagetable_t kpgtbl) {  struct proc *p;    for(p = proc; p &lt; &amp;proc[NPROC]; p++) {    char *pa = kalloc();    if(pa == 0)      panic("kalloc");    uint64 va = KSTACK((int) (p - proc));    kvmmap(kpgtbl, va, (uint64)pa, PGSIZE, PTE_R | PTE_W);  }}</code></pre><p>为每一个proc（proc的内容都是事先分配的）分配一个KSTACK。<br>KSTACK如下所示：</p><pre class="language-c" data-language="c"><code class="language-c">#define KSTACK(p) (TRAMPOLINE - (p)*2*PGSIZE - 3*PGSIZE)</code></pre><p>分配KSTACK的时候需要在trampoline下（顶层），每个STACK都要有两个guard pages来保护，若访问了超出KSTACK的部分，有效位会引发异常。</p><h4 id="kvminitstart">kvminitstart</h4><pre class="language-c" data-language="c"><code class="language-c">voidkvminithart(){  w_satp(MAKE_SATP(kernel_pagetable));  sfence_vma();}</code></pre><p>执行内存屏障，刷新TLB。</p><h3 id="code">code</h3><p>2021及之后的6.S081把一些lab改了，怎么回事呢？</p><h4 id="Speed-up-system-calls-easy">Speed up system calls (easy)</h4><p>本题需要将用户空间（VA）的USYSCALL处映射到内核中的某一处，这样用户便可以从USYCALL处获得必要信息（本题为pid）。</p><p>具体实现中：修改proc结构：</p><p><code>kernel/proc.h</code></p><pre class="language-c" data-language="c"><code class="language-c">struct proc {  struct spinlock lock;  // p-&gt;lock must be held when using these:  enum procstate state;        // Process state  void *chan;                  // If non-zero, sleeping on chan  int killed;                  // If non-zero, have been killed  int xstate;                  // Exit status to be returned to parent's wait  int pid;                     // Process ID  // wait_lock must be held when using this:  struct proc *parent;         // Parent process  // these are private to the process, so p-&gt;lock need not be held.  uint64 kstack;               // Virtual address of kernel stack  uint64 sz;                   // Size of process memory (bytes)  pagetable_t pagetable;       // User page table  struct trapframe *trapframe; // data page for trampoline.S  struct context context;      // swtch() here to run process  struct file *ofile[NOFILE];  // Open files  struct inode *cwd;           // Current directory  char name[16];               // Process name (debugging)  #ifdef LAB_PGTBL  struct usyscall * usyscall;  #endif};</code></pre><p><code>kernel/proc.c</code>:</p><pre class="language-c" data-language="c"><code class="language-c">static struct proc*allocproc(void){  // ......found:  p-&gt;pid = allocpid();  p-&gt;state = USED;  // Allocate a trapframe page.  if((p-&gt;trapframe = (struct trapframe *)kalloc()) == 0){    freeproc(p);    release(&amp;p-&gt;lock);    return 0;  }  #ifdef LAB_PGTBL  if((p-&gt;usyscall = (struct usyscall*)kalloc()) == 0){    freeproc(p);    release(&amp;p-&gt;lock);    return 0;  }  p-&gt;usyscall-&gt;pid = p-&gt;pid;  #endif  // An empty user page table.  p-&gt;pagetable = proc_pagetable(p);  if(p-&gt;pagetable == 0){    freeproc(p);    release(&amp;p-&gt;lock);    return 0;  }  //.......}static voidfreeproc(struct proc *p){  if(p-&gt;trapframe)    kfree((void*)p-&gt;trapframe);  #ifdef LAB_PGTBL  if(p-&gt;usyscall)    kfree((void*)p-&gt;usyscall);  p-&gt;usyscall = 0;  #endif  //.....}pagetable_tproc_pagetable(struct proc *p){  //....  // map the trapframe just below TRAMPOLINE, for trampoline.S.  if(mappages(pagetable, TRAPFRAME, PGSIZE,              (uint64)(p-&gt;trapframe), PTE_R | PTE_W) &lt; 0){    uvmunmap(pagetable, TRAMPOLINE, 1, 0);    uvmfree(pagetable, 0);    return 0;  }#ifdef LAB_PGTBL  if(mappages(pagetable, USYSCALL, PGSIZE,              (uint64)(p-&gt;usyscall), PTE_R | PTE_U)&lt;0){    uvmunmap(pagetable, TRAMPOLINE, 1, 0);    uvmunmap(pagetable, TRAPFRAME, 1, 0);    uvmfree(pagetable, 0);    return 0;              }#endif  return pagetable;}// Free a process's page table, and free the// physical memory it refers to.voidproc_freepagetable(pagetable_t pagetable, uint64 sz){  uvmunmap(pagetable, TRAMPOLINE, 1, 0);  uvmunmap(pagetable, TRAPFRAME, 1, 0);  #ifdef LAB_PGTBL  uvmunmap(pagetable, USYSCALL, 1, 0);  #endif  uvmfree(pagetable, sz);}</code></pre><p>本题的坑在于proc_freepagetable这里。</p><p>其余部分的修改均有提示，但proc_freepagetable没有。若未修改proc_freepagetable，则freewalk函数会触发panic：</p><p>以下为freewalk（<code>kernel/vm.c</code>）代码：</p><pre class="language-c" data-language="c"><code class="language-c">// Recursively free page-table pages.// All leaf mappings must already have been removed.voidfreewalk(pagetable_t pagetable){  // there are 2^9 = 512 PTEs in a page table.  for(int i = 0; i &lt; 512; i++){    pte_t pte = pagetable[i];    if((pte &amp; PTE_V) &amp;&amp; (pte &amp; (PTE_R|PTE_W|PTE_X)) == 0){      // this PTE points to a lower-level page table.      uint64 child = PTE2PA(pte);      freewalk((pagetable_t)child);      pagetable[i] = 0;    } else if(pte &amp; PTE_V){      panic("freewalk: leaf");    }  }  kfree((void*)pagetable);}</code></pre><p>可以看到，若panic，则对应的pte的PTE_R,W,X均有效，即该pte没有释放。因此，需要在proc_freepagetable处unmap了。</p><p>发现方法：（呃呃，我搜了，确实不会gdb）<br>gdb设置freewalk断点，continue后通过backtrace找函数调用栈可以发现。</p><h4 id="Print-a-page-table-easy">Print a page table (easy)</h4><p>没什么好说的，对着提示写递归就行。</p><pre class="language-c" data-language="c"><code class="language-c">void _vmprint_level(pagetable_t pagetable, int level){  if(level&gt;2){    return;  }  // there are 2^9 = 512 PTEs in a page table.  for(int i = 0; i &lt; 512; i++){        pte_t pte = pagetable[i];    if(pte &amp; PTE_V){      // this PTE points to a lower-level page table.      for(int i = 0;i &lt;= level;++i){          printf(" ..");      }      uint64 child = PTE2PA(pte);            printf("%d: pte %p pa %p\n", i, pte, child);      _vmprint_level((pagetable_t)child, level+1);    }  }}void vmprint(pagetable_t pagetable){  printf("page table %p\n", pagetable);  _vmprint_level(pagetable, 0);}</code></pre><p>坑点在于不能先写这个再写speed up…</p><p>speed up会创建必要的内核页表映射，若没有写speed up部分，print会缺少一页，也就是speed up创建的USYSCALL映射页。</p><h4 id="Detecting-which-pages-have-been-accessed-hard">Detecting which pages have been accessed (hard)</h4><p>这题需要跨文件来使用walk函数，但walk函数已经被封装而不能直接使用，因此封装了一下写了mywalk函数：</p><p><code>kernel/vm.c</code></p><pre class="language-c" data-language="c"><code class="language-c">pte_t *my_walk(pagetable_t pagetable, uint64 va, int alloc){  return walk(pagetable, va, alloc);}</code></pre><p><code>kernel/sysproc.c</code></p><pre class="language-c" data-language="c"><code class="language-c">#ifdef LAB_PGTBLvoid my_pgacess_walk(uint64 va, int num, int* buf){  struct proc* p = myproc();  vmprint(p-&gt;pagetable);  for(int i =0;i&lt;num;++i){    pte_t* pte = my_walk(p-&gt;pagetable, va, 0);    if(*pte &amp; PTE_A){      (*buf) |=(1&lt;&lt;i);      (*pte) &amp;= ~(PTE_A);      printf("pte: %p\n", *pte);    }    va+=PGSIZE;  }}intsys_pgaccess(void){  uint64 va, buf;  int num;  int tempbuf = 0;  if(argaddr(0, &amp;va) &lt; 0 || argint(1, &amp;num) &lt;0 || argaddr(2, &amp;buf) &lt;0)    return -1;  struct proc* p = myproc();  my_pgacess_walk(va, num, &amp;tempbuf);  printf("buf: %p\n", (uint64)tempbuf);  if(copyout(p-&gt;pagetable, buf, (char*)&amp;tempbuf, sizeof(tempbuf))&lt;0){    return -1;  }    return 0;}#endif</code></pre><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CNSS Summer 2023 Dev writeup</title>
      <link href="/2023/09/08/cnss-summer-2023-dev-writeup/"/>
      <url>/2023/09/08/cnss-summer-2023-dev-writeup/</url>
      
        <content type="html"><![CDATA[<h2 id="碎碎念">碎碎念</h2><p>呜呜，孩子不会dev，随便打着玩的。</p><h2 id="🧐Dev-is-so-fun…-functional">🧐Dev is so fun… functional!</h2><h3 id="题目描述">题目描述</h3><p>写出和以下<code>scheme</code>代码等价的代码（三种语言）</p><pre class="language-scheme" data-language="scheme"><code class="language-scheme">#lang scheme(define (make-withdraw balance)  (lambda (amount)    (if (&gt;= balance amount)        (begin (set! balance (- balance amount))               balance)        "Insufficient funds")))(define W1 (make-withdraw 100))(define W2 (make-withdraw 100))(W1 50); 50(W1 30); 20(W2 70); 30(W2 50); Insufficient funds</code></pre><h3 id="要点">要点</h3><p>哈哈，不会函数式编程捏。<br>题目要求的是闭包实现，因此用class实现类似功能是不行的。</p><h3 id="过程">过程</h3><p><s>Javascript根本不会，但用法都能从网上找到</s></p><h4 id="C">C++</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;functional&gt;#include &lt;iostream&gt;std::function&lt;void(int)&gt; make_withdraw(int balance){    return [=] (int amount) mutable {        if (balance &gt;= amount){            balance -=amount;            std::cout&lt;&lt;balance&lt;&lt;'\n';        } else {            std::cout&lt;&lt;"Insufficient funds\n";        }    };}int main(){    auto W1=make_withdraw(100);    auto W2=make_withdraw(100);    W1(50);    W1(30);    W2(70);    W2(50);}</code></pre><h4 id="Python">Python</h4><pre class="language-python" data-language="python"><code class="language-python">def make_withdraw(balance):    def kkndlam(amount):        nonlocal balance        if balance &gt;= amount:            balance -= amount            print(balance)        else:            print("Insufficient funds")    return kkndlamW1 = make_withdraw(100)W2 = make_withdraw(100)W1(50)W1(30)W2(70)W2(50)</code></pre><h4 id="Javascript">Javascript</h4><pre class="language-javascript" data-language="javascript"><code class="language-javascript">function make_withdraw(balance) {    function kkndlam(amount) {        if(balance&gt;=amount){            balance -= amount;            console.log(balance)        } else{            console.log("Insufficient funds");        }    };    return kkndlam;}var W1 = make_withdraw(100);var W2 = make_withdraw(100);W1(50);W1(30);W2(70);W2(50);</code></pre><h2 id="♊双人成行">♊双人成行</h2><h3 id="题目描述-2">题目描述</h3><p>使用数据并行化实现多机/多卡对<code>CIFAR-10</code>进行分类的神经网络，模型自选，并回答数据并行化的方式</p><h3 id="要点-2">要点</h3><p>CPU+GPU也是双卡😤，pytorch写一下multiprocessing就行。</p><h3 id="过程-2">过程</h3><div class="admonition note"><p class="admonition-title">配置</p><ul><li>CPU 略</li><li>GPU NVIDIA GeForce MX450</li><li>机器学习环境 pytorch 2.0.1+cu117 CUDA 11.7</li></ul></div><p>实现：用<s>东拼西凑的</s>ResNet残差网络实现的、以<code>CIFAR-10</code>为数据集的图像分类</p><h4 id="Code">Code</h4><pre class="language-python" data-language="python"><code class="language-python">import osimport argparseimport torchimport torchvisionimport torchvision.transforms as transformsimport torch.nn as nnimport torch.optim as optimfrom torch.nn import functional as Fimport torch.multiprocessing as mpimport torch.distributed as distfrom torch.nn.parallel import DistributedDataParallel# some parameterkernel_size=3num_epochs = 3lr = 0.01# device: cpu, gpudevice = [torch.device('cpu'), torch.device('cuda')]# transform origin data： 数据增强等。transform = transforms.Compose([    transforms.Pad(4), # 填充像素    transforms.RandomHorizontalFlip(), # 倒转    transforms.RandomCrop(32), # 切片    transforms.ToTensor()])# Res blockclass Residual(nn.Module):    def __init__(self, input_channels, num_channels,                 kernel_size, strides=1, use1x1=False):        super().__init__()        self.conv1 = nn.Conv2d(input_channels, num_channels,                               kernel_size=kernel_size, padding=(kernel_size-1)//2, stride=strides)        self.conv2 = nn.Conv2d(num_channels, num_channels,                               kernel_size=kernel_size, padding=(kernel_size-1)//2)        if use1x1:            self.conv3 = nn.Conv2d(input_channels, num_channels, kernel_size=1, stride=strides)        else:            self.conv3 = None        self.bn1 = nn.BatchNorm2d(num_channels)        self.bn2 = nn.BatchNorm2d(num_channels)    def forward(self, X):        Y = self.conv1(X)        Y = self.bn1(Y)        Y = F.relu(Y)        Y = self.bn2(self.conv2(Y))        if self.conv3:            X = self.conv3(X)        Y += X        return F.relu(Y)# 总模型class ResNet(nn.Module):    def _resnet_block(self, input_channels, num_channels, num_residuals, first_block=False):        blist=[]        for i in range(num_residuals):            if i == 0 and not first_block:                blist.append(Residual(input_channels, num_channels,kernel_size=kernel_size, use1x1=True))            else:                blist.append(Residual(num_channels, num_channels, kernel_size=kernel_size))        return nn.Sequential(*blist)    def __init__(self, layers:list, num_classes=10):        super().__init__()        self.conv1 = nn.Conv2d(3, 16, kernel_size=kernel_size, bias=False)        self.bn1 = nn.BatchNorm2d(16)        self.relu = nn.ReLU(inplace=True)        self.resblk1 = self._resnet_block(16, 16, layers[0], first_block=True)        self.resblk2 = self._resnet_block(16,32, layers[1])        self.resblk3 = self._resnet_block(32, 64, layers[2])        self.avgPool = nn.AdaptiveAvgPool2d((1,1))        self.flatten = nn.Flatten()        self.fullconn = nn.Linear(64, num_classes)    def forward(self, x):        Y = self.conv1(x)        Y = self.bn1(Y)        Y = self.relu(Y)        Y = self.resblk1(Y)        Y = self.resblk2(Y)        Y = self.resblk3(Y)        Y = self.avgPool(Y)        Y = self.flatten(Y)        Y = self.fullconn(Y)        return Ydef train(rank, args):    # 初始化 使用内置的gloo    dist.init_process_group("gloo", rank=rank, world_size=args.nodes*args.gpus)    # 当前进程所用device    local_device = device[rank]    # print(rank, local_device)    # 初始化进程    model = ResNet([2,2,2]).to(local_device)    # 分布！    model = DistributedDataParallel(model)    #    if rank == 0: # 主进程download        train_dataset = torchvision.datasets.CIFAR10(root='data/', train=True, transform=transform, download=True)    else:        dist.barrier()        train_dataset = torchvision.datasets.CIFAR10(root='data/', train=True, transform=transform)    train_loader = torch.utils.data.DataLoader(dataset=train_dataset, batch_size=300, shuffle=True)    # 等待状态以使进程达到同步。    dist.barrier()    # 交叉熵损失函数， Adam优化器    criterion = nn.CrossEntropyLoss()    optimizer = optim.Adam(model.parameters(), lr=lr)    for epoch in range(num_epochs):        # print(epoch)        for images, labels in train_loader:            images = images.to(local_device)            labels = labels.to(local_device)            optimizer.zero_grad()            out = model(images)            loss = criterion(out, labels)            loss.backward()            optimizer.step()    dist.barrier()    # 存下参数    if rank == 0:        torch.save(model.state_dict(), "./resnet.pth")    # 关闭所有进程    dist.destroy_process_group()if __name__ == "__main__":    os.environ["MASTER_ADDR"] = "127.0.0.1"    os.environ["MASTER_PORT"] = "11451"    parser = argparse.ArgumentParser()    parser.add_argument('-n', '--nodes', default=1, type=int)    parser.add_argument('-g', '--gpus', default=len(device), type=int)    args = parser.parse_args()    mp.spawn(train, nprocs=args.gpus, args=(args,))</code></pre><h4 id="数据并行化">数据并行化</h4><p>code中为多进程Ring ALLReduce方式，通过环式的通信提升了通信效率。</p><p>另外，诸如torch的dataparallel就类似于google 的 MapReduce，将任务分派给各个子任务进行reduce，最后在主节点进行整合。</p><h2 id="🆕malloc-怎么是个函数啊">🆕malloc 怎么是个函数啊</h2><h3 id="题目描述-3">题目描述</h3><blockquote><p>推荐linux环境完成</p></blockquote><p>使用C语言造出malloc和free的轮子，并回答相应问题。</p><h3 id="要点-3">要点</h3><p><s>windows很好实现，但会被毙</s><br><s>没试过这样干，可以看看yao的博客</s></p><p>malloc会在分配的内存块前存放信息，从而方便free等操作。</p><h3 id="过程-3">过程</h3><h4 id="Code-2">Code</h4><pre class="language-c" data-language="c"><code class="language-c">#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#define align8(x) (((((x)+7)&gt;&gt;3)&lt;&lt;3))typedef struct block block;typedef struct block* p_block;// 全局p_block begin_heap = NULL, end_heap = NULL;struct block{    p_block next; //下一块地址。    p_block prev;// 前一块地址，用于merge。    size_t size;// 该块分配了多少字节    int free; //该块是否free.    char *ptr;// 相当于验证作用？    char data[]; //用于实际操作中按字节寻址。};p_block find_block(size_t size){    p_block now = begin_heap;    while(now &amp;&amp; !(now-&gt;free &amp;&amp; now-&gt;size &gt;= size)){        now = now-&gt;next;    }    return now;}p_block extend(size_t size){    p_block now = sbrk(0);    if(sbrk(sizeof(block)+size)==(void*)-1){        return NULL;    }    now-&gt;size = size;    now-&gt;next = NULL;    now-&gt;free = 0;    if(end_heap){        end_heap-&gt;next = now;    } else {        begin_heap = now;    }    now -&gt; prev = end_heap;    now -&gt; ptr = now-&gt;data;    end_heap = now;    return now;}void *mymalloc(size_t size){    p_block now;    size_t align_size = align8(size);    if (begin_heap) {        //已有malloc内存后的操作        if (now = find_block(align_size)){            now -&gt; free = 0;        } else {            now = extend(align_size);            if(now == NULL){                return NULL;            }        }    } else {        // 初次malloc，进行extend操作        now = extend(align_size);        if (now == NULL){            return NULL;        }    }    return now-&gt;data;}p_block get_block(void *nowptr){    //malloc 将信息保存在使用的内存块前，这里获取该metadata地址。    return (p_block)((char*)nowptr - sizeof(block));}int is_valid(void *nowptr){    if (begin_heap){        if ((void*)begin_heap &lt; nowptr &amp;&amp; nowptr &lt; sbrk(0)){            return nowptr == get_block(nowptr)-&gt;ptr;        }    }    return 0;}p_block merge_block(p_block now){    // avoid fragments(maybe?)    if(now-&gt;next &amp;&amp; now-&gt;next-&gt;free){        now-&gt;size += sizeof(block) + now-&gt;next-&gt;size;        now-&gt;next = now-&gt;next-&gt;next;        if(now-&gt;next){            now-&gt;next-&gt;prev = now;        }    }    return now;}void myfree(void * nowptr){    //merge一下碎片    if(is_valid(nowptr)){        //free block        p_block now = get_block(nowptr);        now-&gt;free = 1;        //merge prev.        if(now-&gt;prev&amp;&amp;now-&gt;prev-&gt;free){            now = merge_block(now-&gt;prev);        }        if(now-&gt;next == NULL){// update begin and end heap.            end_heap = now-&gt;prev;            if(end_heap){                end_heap-&gt;next = NULL;            } else {                begin_heap = NULL;            }            brk(now);        } else { //else do merge.           merge_block(now);         }    } //else : do nothing.}int main(){    //测测你的    printf("sizeof block: %d\n",sizeof(block));    printf("ptr   begin_heap: %p, end_heap: %p\n", begin_heap, end_heap);    int *a = (int*)mymalloc(sizeof(int)*10);    printf("ptr   begin_heap: %p, end_heap: %p\n", begin_heap, end_heap);    char *b = (char*)mymalloc(sizeof(char)*100);    p_block ta = get_block(a), tb = get_block(b);    printf("a: size %d, next %p, prev %p\n",ta-&gt;size, ta-&gt;next, ta-&gt;prev);    printf("b: size %d, next %p, prev %p\n",tb-&gt;size, tb-&gt;next, tb-&gt;prev);    printf("ptr   begin_heap: %p, end_heap: %p\n", begin_heap, end_heap);    myfree(a);    printf("free a: ptr   begin_heap: %p, end_heap: %p\n", begin_heap, end_heap);    myfree(b);    printf("free b: ptr   begin_heap: %p, end_heap: %p\n", begin_heap, end_heap);}</code></pre><p>测试截图:<br><img src="/images/CNSS/mymalloc.png" alt="kknd"></p><h4 id="为什么-malloc-size-t-size-需要申请的内存长度，但是-free-void-ptr-不需要已申请的内存长度？">为什么 malloc(size_t size) 需要申请的内存长度，但是 free(void* ptr) 不需要已申请的内存长度？</h4><p>malloc的实现中，会在分配的内存块前储存一小块数据，用于存储关于该次malloc的信息，例如分配的内存字节大小，以及其他信息。free的时候只需要传入指针，程序会在约定好的位置读取信息，便可以进行free操作而不用传入需要释放的内存大小，方便操作。</p><h4 id="OS如何管理内存？">OS如何管理内存？</h4><p>操作系统如何管理内存捏？</p><ol><li>操作系统向进程隐藏了具体的物理内存地址，取而代之的是虚拟的地址空间假象（使用MMU等硬件进行虚拟地址转换）。</li><li>操作系统给每一个进程分配一个页表，用相对较大的页这一单元来储存具体的代码和数据，并使用TLB、多级页表等机制进行速度优化。</li><li>操作系统会将不常用的页从内存储存进磁盘，当需要访问该页时，硬件抛出缺页异常，由软件（操作系统）来调度页。</li></ol><p>需要说明的是，以上的操作系统过程都是透明的，进程无从感知这一切，操作系统用复杂的机制向进程隐藏了这一切。</p><h2 id="🔀Trace-it">🔀Trace it!</h2><p>再造次轮子！</p><h3 id="题目描述-4">题目描述</h3><p>自选语言，实现linux下的traceroute。打印出本机到目的主机之间设备的 IP 地址和 TTL 时间。由于有些中间设备关闭了某些网络服务，所以不能被 trace 到，你只需要给出相应提示即可。</p><h3 id="要点-4">要点</h3><p>虽说traceroute使用的ICMP包已经确定好了类型和代码，但错误的类型和代码仍能得到回应<br><s>和出题人battle后发现出题人写错了类型和代码照样能得到回应</s></p><p>于是只要构造ICMP包就行了。</p><h3 id="过程-4">过程</h3><p>环境</p><blockquote><p>Linux<br>Python 3.11.3 + Scapy</p></blockquote><h4 id="原理">原理</h4><p>traceroute 主要通过IP协议和ICMP协议两者共同完成（负载上也有TCP和UDP两种实现，这里只讲UDP实现）</p><p>IP协议中的TTL字段每经一个路由器都会-1， 若-1后为0，路由器将其丢弃，并将向源ip地址（发起方）回复一个ICMP的超时报文，从超时数据报的源IP地址中， 发起方便可获取该路由器的IP地址、</p><p>利用以上原理，traceroute可以在第一次发送<code>TTL=1</code>的UDP（or TCP?）报文，收到超时的回复时再发送<code>TTL=2</code>的报文，如此反复，直到发送到目的IP地址，或达到设定的最高hop数（Linux 中的 <code>traceroute</code> 默认为30 hops），便可得出数据包途经的IP地址。</p><p>需要注意的是，现在的许多路由器开启了防火墙等功能，被配置为了不返回ICMP报文，因此traceroute命令无法获得该路由器的IP地址，在原命令中显示为<code>*</code>。traceroute不会因为遇到该种情况停止，而是继续增加TTL，发出数据包，直到遇到以上所述的情况而停止。</p><hr><p>那么，如何根据ICMP来得出路由器返回的不同情况呢？</p><p>ICMP 提供了type字段以及细分的code字段以区分不同的类型，其中有两个在traceroute中尤其重要：</p><table><thead><tr><th>Type</th><th>Code</th><th>description</th></tr></thead><tbody><tr><td>11</td><td>0</td><td>TTL expired in transit</td></tr><tr><td>3</td><td>3</td><td>Destination port unreachable</td></tr></tbody></table><p>Destination port unreachable(目的端口不可达)： traceroute 的目的端口设为&gt;30000(Linux 默认值为33434), 大多数的服务器处理该数据报时会将其视为端口不可达，因此返回特定报文。</p><div class="admonition note"><p class="admonition-title">为什么目的端口设定为大于30000</p><p>UDP的实现中保证了0~65535的端口号可用，在RFC文档中并没有限制端口使用。</p><p>man文档中的解释为：探测包需要使用 <code>udp datagrams with so-called "unlikely" destination ports</code>，于是就选择了默认值33434，也许设计者认为33434大伙儿都不会用吧，文档中也说明不保证33434如果有应用用了，traceroute的行为如何。</p><p>至于端口设置为大于30000的说法，也许只是网上的人云亦云？</p></div><p>TTL expired in transit(TTL 超时)：TTL为0时路由器返回的ICMP报文，用于获取该路由器的源IP地址。</p><hr><p>综合来看， traceroute的设计足够巧妙，利用了两个协议的组合使用来达成功能。<br><s>也足够严谨，说明了自己选择目的端口33434会导致未定义行为</s></p><h4 id="Code-3">Code</h4><pre class="language-python" data-language="python"><code class="language-python">import sysimport socketimport timefrom scapy.all import *def my_trace_one(dest_ip:str, dest_port:str, ttl:int):    begin_time = time.time()    # verbose 会输出多余信息，timeout为设定单次请求超时时间1s。    # IP段设置目的IP， ttl生存周期， UDP设置源port(这感觉无所谓的)， 目的端口设为不可达(&gt;30000)    reply = sr1(IP(dst=dest_ip, ttl=ttl)/UDP(sport=6600, dport=dest_port), timeout=1, verbose=False)    end_time = time.time()    period=end_time-begin_time    try:        if reply.getlayer(ICMP).type==11 and reply.getlayer(ICMP).code==0:            now_ip = reply.getlayer(IP).src            return "TTL expired in transit", now_ip, period        elif reply.getlayer(ICMP).type == 3 and reply.getlayer(ICMP).code == 3:            now_ip = reply.getlayer(IP).src            return "Destination port unreachable", now_ip, period    except Exception as e:        return None    def my_traceroute(domain:str,ip:str, hops:int=30):    print("Destiny : "+f"({domain}) "+ip)    hop = 0    flag = True    # traceroute default port: 33434    dest_port=33434    while flag and hop&lt;hops:        hop += 1        dest_port +=1        message = str(hop)+" "        result = my_trace_one(dest_ip=ip, dest_port=dest_port, ttl=hop)        if result is None:            message +="\t*"        elif result[0]=="TTL expired in transit":            message += f"\t{result[1]}\t{result[2]*1000}ms"        elif result[0]=="Destination port unreachable":            message += f"\t{result[1]}\t{result[2]*1000}ms\nOver!"            flag=False        print(message)if __name__ == "__main__":    domain = sys.argv[1]    if len(sys.argv)&gt;2:        hops = int(sys.argv[2])    else:        hops=30    ip = socket.gethostbyname(domain)    my_traceroute(domain, ip, hops)</code></pre><h4 id="Picture">Picture</h4><p>演示：<br><img src="/images/CNSS/mytraceroute.png" alt="kknd"></p><p>看看Linux的<br><img src="/images/CNSS/linux_traceroute.png" alt="linux"></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> CNSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CNSS </tag>
            
            <tag> DevOps </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CNSS Summer 2023 SA writeup</title>
      <link href="/2023/09/08/cnss-summer-2023-sa-writeup/"/>
      <url>/2023/09/08/cnss-summer-2023-sa-writeup/</url>
      
        <content type="html"><![CDATA[<p>早知道，还得是SA。</p><p>以下做题过程中，环境包括：</p><ol><li>Windows</li><li>Ubuntu 20.04</li><li>CentOS 7</li><li>Arch… 当时最新版本。</li></ol><p>唉，linux太多了。</p><h2 id="🌳Learn-Git-Branching-Git">🌳Learn Git Branching(Git)</h2><h3 id="题目描述">题目描述</h3><p><a href="https://learngitbranching.js.org/">Learn Git</a></p><p>完成以上链接中[主要]里的<strong>基础篇</strong>、<strong>高级篇</strong>、<strong>移动提交记录</strong> 和<strong>杂项</strong>，还有[远程]里的<strong>Push &amp; Pull —— Git 远程仓库！</strong>。</p><p><s>留给后面查git命令来用</s></p><h3 id="主要-基础篇">主要-基础篇</h3><h4 id="commit">commit</h4><p>只需要进行两次提交即可。</p><pre class="language-bash" data-language="bash"><code class="language-bash">git commitgit commit</code></pre><h4 id="branch">branch</h4><p>创建<code>bugFix</code>分支并切换到此分支。</p><pre class="language-bash" data-language="bash"><code class="language-bash">git branch bugFixgit checkout bugFix</code></pre><h4 id="merge">merge</h4><p>创建分支后分别<code>commit</code>，最后使用<code>merge</code>可以合并<code>bugFix</code>分支至<code>main</code>分支。</p><pre class="language-bash" data-language="bash"><code class="language-bash">git checkout -b bugFixgit commitgit checkout maingit commitgit merge bugFix</code></pre><h4 id="Rebase">Rebase</h4><p>将新建的<code>bugFix</code>分支通过<code>rebase</code>转移至<code>main</code>下。</p><pre class="language-bash" data-language="bash"><code class="language-bash">git checkout -b bugFixgit commitgit checkout maingit commitgit checkout bugFixgit rebase main</code></pre><h3 id="主要-高级篇">主要-高级篇</h3><h4 id="在提交树上移动">在提交树上移动</h4><p>指定哈希值便可以分离<code>HEAD</code>.</p><pre class="language-bash" data-language="bash"><code class="language-bash">git checkout C4</code></pre><h4 id="相对引用1">相对引用1</h4><p>除开哈希值，可以使用<code>^</code>或<code>~num</code>来向上移动。</p><pre class="language-bash" data-language="bash"><code class="language-bash">git checkout bugFix^</code></pre><h4 id="相对引用2">相对引用2</h4><p>同上</p><pre class="language-bash" data-language="bash"><code class="language-bash">git branch -f main C6git checkout HEAD~1git branch -f bugFix HEAD~1</code></pre><h4 id="撤销变更">撤销变更</h4><p><code>git reset</code>通过回退来撤销改动（本地），<code>git revert</code>撤销更改并分享别人。这里只需要对不同的分支进行不同操作即可。</p><pre class="language-bash" data-language="bash"><code class="language-bash">git reset HEAD^git checkout pushedgit revert pushed</code></pre><h3 id="移动提交记录">移动提交记录</h3><h4 id="Git-Cherry-pick">Git Cherry-pick</h4><p>该命令可以将一些提交直接复制到HEAD下，并可指定多个提交按线性顺序复制.</p><pre class="language-bash" data-language="bash"><code class="language-bash">git cherry-pick C3 C4 C7</code></pre><h4 id="交互式-rebase">交互式 rebase</h4><p><code>rebase -i(--interactive)</code>可以打开UI界面进行节点删除、修改顺序等操作。</p><pre class="language-bash" data-language="bash"><code class="language-bash">git rebase -i overHere</code></pre><p>然后拖拽删除节点为指定顺序即可。</p><h3 id="杂项">杂项</h3><h4 id="只取一个提交记录">只取一个提交记录</h4><p>仍然在交互的rebase下进行拖拽删除。</p><pre class="language-bash" data-language="bash"><code class="language-bash">git rebase -i maingit rebase bugFix main</code></pre><h4 id="提交的技巧-1">提交的技巧 #1</h4><p>可以通过<code>rebase -i </code>+<code>commit--amend</code>完成</p><pre class="language-bash" data-language="bash"><code class="language-bash">git rebase -i HEAD~2git commit --amendgit rebase -i HEAD~2git rebase caption main</code></pre><h4 id="提交的技巧-2">提交的技巧 #2</h4><p><code>rebase</code>可能会导致冲突，<code>cherry-pick</code>则可以将提交树上任何地方拿来追加至<code>HEAD</code>（非<code>HEAD</code>上游）</p><pre class="language-bash" data-language="bash"><code class="language-bash">git checkout maingit cherry-pick C2git commit --amendgit cherry-pick C3</code></pre><h4 id="Git-tags">Git tags</h4><p>使用tag可以定义永远指向某个提交记录的标识。</p><pre class="language-bash" data-language="bash"><code class="language-bash">git tag v1 C2git tag v0 C1git checkout v1</code></pre><h4 id="Git-Describe">Git Describe</h4><p>这里只是作为测试<code>describe</code>命令使用，最后输出<code>&lt;tag&gt;_&lt;numCommmits&gt;_g&lt;hash&gt;</code>;<br><code>git commit</code> 命令只是为了通过此关。</p><pre class="language-bash" data-language="bash"><code class="language-bash">git discribe maingit commit</code></pre><h3 id="Push-Pull-——-Git-远程仓库">Push &amp; Pull —— Git 远程仓库</h3><h4 id="git-clone">git clone</h4><p>创建远程仓库拷贝。</p><pre class="language-bash" data-language="bash"><code class="language-bash">git clone</code></pre><h4 id="远程分支">远程分支</h4><p>o(origin)/main为远程分支，反应了远程仓库在上次进行通信的状态，直接c在o/main上提交不会改变远程仓库的状态。</p><pre class="language-bash" data-language="bash"><code class="language-bash">git commitgit checkout o/maingit commit</code></pre><h4 id="Git-Fetch">Git Fetch</h4><p>该命令可以获取远程仓库的最新信息（更新远程分支）</p><pre class="language-bash" data-language="bash"><code class="language-bash">git fetch</code></pre><h4 id="Git-Pull">Git Pull</h4><p><code>fetch</code> 和 <code>merge</code>的合并操作。</p><pre class="language-bash" data-language="bash"><code class="language-bash">git pull</code></pre><h4 id="模拟团队协作">模拟团队协作</h4><p><code>fakeTeamwork</code>在教程中为远程仓库的提交，只做演示作用。</p><p>这里模拟了部分团队协作，只在本地进行了更新<code>pull</code>操作。</p><pre class="language-bash" data-language="bash"><code class="language-bash">git clonegit fakeTeamwork main 2git commitgit pull</code></pre><h4 id="Git-push">Git push</h4><p>将变更上传至远程仓库。</p><pre class="language-bash" data-language="bash"><code class="language-bash">git commitgit commitgit push</code></pre><h4 id="偏离的工作">偏离的工作</h4><p>历史偏移的不确定性，导致git不允许直接进行push变更（失败）。需要先强制合并远程代码，再进行push操作。</p><p><code>pull --rebase</code> (fetch rebase)和<code>pull</code>(fetch merge)的行为不同。</p><pre class="language-bash" data-language="bash"><code class="language-bash">git clonegit fakeTeamwork 1git commitgit pull --rebasegit push</code></pre><h4 id="锁定的main">锁定的main</h4><p>远程仓库的main锁定时，需要通过新建分支、推送分支来进行操作。</p><pre class="language-bash" data-language="bash"><code class="language-bash">git branch -f main C1git checkout -b featuregit branch -f feature C2git push origin feature </code></pre><h2 id="🐋上个题-Docker-Xinetd">🐋上个题(Docker, Xinetd)</h2><h3 id="题目描述-2">题目描述</h3><p>部署一道<code>Pwn</code>题。要求全自动部署。</p><h3 id="过程">过程</h3><p>这题可以直接从github上找<a href="https://github.com/Eadom/ctf_xinetd/tree/master">轮子</a><br>但做题过程中稍微绕了一下，原本想自己写着试试的，但最后还是按以上<a href="https://github.com/Eadom/ctf_xinetd/tree/master">轮子</a>的思路写了。</p><h3 id="Code">Code</h3><p><strong>docker-compose.yml</strong></p><pre class="language-yaml" data-language="yaml"><code class="language-yaml">services:  pwn:    image: ubuntu:16.04    build: .    container_name: hello_pwn_deploy    ports:      - 0.0.0.0:10000:10000</code></pre><p>剩下的部分同以上的轮子部分。</p><p>pwn 启动：<code>sudo docker compose up --build -d</code></p><p>做题时pwn题采用2023 CNSS夏令营里头的<code>👀[easy]你的名字</code>。</p><h2 id="🎮Play-Game-With-Friends-配环境">🎮Play Game With Friends(配环境)</h2><h3 id="题目描述-3">题目描述</h3><ol><li>完成 【我的世界 Minecraft 】、【泰拉瑞亚 Terraria 】、【饥荒 Don’t Starve】、【原神 Genshin Impact】 中任意两款游戏的服务器搭建。</li><li>搭建在公网不间断运行的服务器上。</li></ol><h3 id="要点">要点</h3><p>官方wiki都有搭建服务器教程，对着自己linux版本调一下就行了。</p><h3 id="过程-2">过程</h3><p>由于CentOS内存过小配置太低，仅能同时在线一个游戏的服务器。</p><p>开启对应游戏具体端口xxxx（MC），xxxx+114514（Terraria）。</p><h4 id="我的世界部分">我的世界部分</h4><p>我的世界最新的服务器需要jdk17，CentOS自带java为1.8（Java 8）卸载自带的jdk1.8，去Oracle官网安装了<a href="https://download.oracle.com/java/17/latest/jdk-17_linux-x64_bin.tar.gz">jdk-17</a></p><p>具体命令如下：</p><pre class="language-bash" data-language="bash"><code class="language-bash">wget https://download.oracle.com/java/17/latest/jdk-17_linux-x64_bin.tar.gztar zxf jdk-17_linux-x64_bin.tar.gz# jdk 17.0.8 版本mv jdk-17.0.8.* jdk-17mv jdk-17 /usr/local/# 增加环境变量vim /etc/profile# 增加以下语句export JAVA_HOME=/usr/local/jdk-17export PATH=/usr/local/jdk-17/bin:$PATH# 保存后加载配置文件source /etc/profile# 看看java版本java -version</code></pre><p>之后就是我的世界服务器搭建：</p><p>去官网找到<a href="https://piston-data.mojang.com/v1/objects/84194a2f286ef7c14ed7ce0090dba59902951553/server.jar">服务器下载网址</a>，在minecraft文件夹下使用命令：</p><pre class="language-bash" data-language="bash"><code class="language-bash">wget https://piston-data.mojang.com/v1/objects/84194a2f286ef7c14ed7ce0090dba59902951553/server.jar</code></pre><p>之后先运行一次服务器：</p><pre class="language-bash" data-language="bash"><code class="language-bash">java -Xmx1024M -Xms1024M -jar server.jar --nogui </code></pre><p>修改生成的eula.txt,修改为：</p><pre class="language-bash" data-language="bash"><code class="language-bash">eula=true</code></pre><p>最后就是修改配置部分，配置文件为<code>server.properties</code>,配置如下（做了点隐私处理）</p><pre class="language-bash" data-language="bash"><code class="language-bash">#Minecraft server propertiesenable-jmx-monitoring=falsercon.port=?level-seed=gamemode=survivalenable-command-block=falseenable-query=falsegenerator-settings={}enforce-secure-profile=truelevel-name=worldmotd=A Minecraft Serverquery.port=?pvp=truegenerate-structures=truemax-chained-neighbor-updates=1000000difficulty=easynetwork-compression-threshold=256max-tick-time=-1require-resource-pack=falseuse-native-transport=truemax-players=4online-mode=falseenable-status=trueallow-flight=falseinitial-disabled-packs=broadcast-rcon-to-ops=trueview-distance=10server-ip=resource-pack-prompt=allow-nether=trueserver-port=??????????????enable-rcon=falsesync-chunk-writes=trueop-permission-level=4prevent-proxy-connections=falsehide-online-players=falseresource-pack=entity-broadcast-range-percentage=100simulation-distance=10rcon.password=player-idle-timeout=0force-gamemode=falserate-limit=0hardcore=falsewhite-list=falsebroadcast-console-to-ops=truespawn-npcs=truespawn-animals=truefunction-permission-level=2initial-enabled-packs=vanillalevel-type=minecraft\:normaltext-filtering-config=spawn-monsters=trueenforce-whitelist=falsespawn-protection=16resource-pack-sha1=max-world-size=29999984</code></pre><p>由于我自己是用PCL启动器而非官方的，所以online-mode 改成false了。</p><p>好嘞，<strong>MC 启动</strong>！</p><p><img src="/images/CNSS/local_mc.png" alt="本地游戏界面"></p><p><img src="/images/CNSS/shell_mc.png" alt="shell查看MC"></p><p>最后让服务器24小时运行，使用命令：</p><pre class="language-bash" data-language="bash"><code class="language-bash">sudo yum install screenscreen -S minecraft</code></pre><p>进行以上启动部分的命令，然后Ctrl+A+D退出screen，可以发现仍然能够远程访问MC。</p><h4 id="泰拉瑞亚部分">泰拉瑞亚部分</h4><p>没玩过泰拉瑞亚，瞎写了。</p><p>首先steam购买泰拉瑞亚（36￥😭），查看版本1.4.4.9</p><p>然后新建Terraria文件夹，从官网上下载最新版本：</p><pre class="language-bash" data-language="bash"><code class="language-bash">wget https://www.terraria.org/api/download/pc-dedicated-server/terraria-server-1449.zip</code></pre><p>下载来的文件有Windows， linux和MacOS三个版本，把linux中文件全部复制到Terraria文件夹下。</p><p>给文件加权限：</p><pre class="language-bash" data-language="bash"><code class="language-bash">chmod a+x ./TerrariaServer.bin.x86_64</code></pre><p>点击运行并生成世界。但有些麻烦了，直接写个config.txt:</p><pre class="language-bash" data-language="bash"><code class="language-bash">#Load a world and automatically start the server. Createworld=....../Terraria/worlds/helloTerraria.wldworldpath=....../Terraria/worldsworldname=helloTerrariaport=?????password=??????????????????????????upnp=1motd=Test your terraria!autocreate=1difficulty=0secure=1language=zh/Hans</code></pre><p>输入以下命令，<strong>泰拉瑞亚 启动！</strong></p><pre class="language-bash" data-language="bash"><code class="language-bash">./TerrariaServer.bin.x86_64 -config config.txt</code></pre><p><img src="/images/CNSS/shell_terraria.png" alt="Terraria shell"></p><p>24小时运行方式同MC的方式。</p><h2 id="😋懒人福音-shell脚本">😋懒人福音(shell脚本)</h2><h3 id="题目描述-4">题目描述</h3><p>写个一键 bash 脚本完成:</p><ol><li>切换软件源为国内源（apt/yum）</li><li>安装 zsh/fish 和 oh-my-zsh</li><li>设置 ssh 超时时间为至少 10 分钟</li><li>安装 Git 并配置好 email 和用户名</li><li>设置系统代理</li><li>切换系统 locale 为中文</li><li>更新所有软件为最新</li><li>简要的交互提示</li></ol><p>并完成附加要求：</p><ol><li>安装 docker 并配好国内镜像</li><li>安装 nodejs 最新版并配好国内镜像</li><li>安装并配置好你在 Linux 下最常用的编辑器（推荐 Vim 只需要配个 vimrc 就好了）</li><li>对于以上所有有关镜像/代理的内容，检测当前脚本运行的 ip 是否在国内，在的话才配置镜像/代理否则不更改默认配置</li></ol><h3 id="要点-2">要点</h3><p>都能搜得到，唯一注意的是检测ip在国内，需要curl一下外部网址。</p><h3 id="过程-3">过程</h3><pre class="language-bash" data-language="bash"><code class="language-bash">#!/bin/shfunction change_apt_source(){    echo "=========================================="    UB_VERSION=$(cat /etc/os-release | grep VERSION_CODENAME | awk -F "=" '{print $2}')    echo "==== Ubuntu version: $UB_VERSION ===="    echo "begin change your source(tsinghua)..."    if [ $1 = "OTHER" ]; then        echo "You are not in CN so that don't need change your apt source."        return 0    fi     echo "origin source.list is stored in /etc/apt/sources.list.bak"    sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak        echo "# 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ $UB_VERSION main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ $UB_VERSION main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ $UB_VERSION-updates main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ $UB_VERSION-updates main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ $UB_VERSION-backports main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ $UB_VERSION-backports main restricted universe multiverse# deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ $UB_VERSION-security main restricted universe multiverse# \# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ $UB_VERSION-security main restricted universe multiversedeb http://security.ubuntu.com/ubuntu/ $UB_VERSION-security main restricted universe multiverse# deb-src http://security.ubuntu.com/ubuntu/ $UB_VERSION-security main restricted universe multiverse# 预发布软件源，不建议启用# deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ $UB_VERSION-proposed main restricted universe multiverse# # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ $UB_VERSION-proposed main restricted universe multiverse" | sudo tee /etc/apt/sources.list    echo "=========================================="    echo "SUCCESS change apt source!"}function install_zsh(){    echo "=========================================="    echo "begin install zsh..."    sudo apt-get install zsh    if [ $1 = "OTHER" ]; then        sh -c "$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)"    else        sh -c "$(curl -fsSL https://gitee.com/shmhlsy/oh-my-zsh-install.sh/raw/master/install.sh)" #国内镜像源    fi    echo "=========================================="    echo "SUCCESS install zsh&amp;oh-my-zsh!"}function change_ssh_config(){    echo "=========================================="    echo "begin config ssh..."    sed -i 's/\(^[\s#]*\)ClientAliveInterval\(.*\)/ClientAliveInterval 60/'     sed -i 's/\(^[\s#]*\)ClientAliveCountMax\(.*\)/ClientAliveCountMax 10/' ~/test.txt    echo "=========================================="    echo "SUCCESS config ssh: 10 minutes Alive"}function install_git(){    echo "=========================================="    echo "begin install git..."    sudo apt install git    echo -n "Your git name:"    read GIT_USERNAME    git config --global user.name $GIT_USERNAME    echo -n "Your git email:"    read GIT_EMAIL    git config --global user.email $GIT_EMAIL    git config --list    echo "=========================================="    echo "SUCCESS install git!"}function install_docker(){    echo "=========================================="    echo "begin install docker..."    for pkg in docker.io docker-doc docker-compose podman-docker containerd runc; do        sudo apt-get remove $pkg    done    sudo apt-get update    sudo apt-get install ca-certificates curl gnupg    sudo install -m 0755 -d /etc/apt/keyrings    curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg    sudo chmod a+r /etc/apt/keyrings/docker.gpg    echo \    "deb [arch="$(dpkg --print-architecture)" signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \    "$(. /etc/os-release &amp;&amp; echo "$VERSION_CODENAME")" stable" | \    sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null    sudo apt-get update    sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin    sudo systemctl enable docker    sudo systemctl start docker    if [ $1 = "CN" ]; then     echo "{  \"registry-mirrors\": [\"https://docker.mirrors.ustc.edu.cn\"]}" | sudo tee -a /etc/docker/daemon.json    fi    sudo service docker restart    echo "=========================================="    echo "SUCCESS install docker!"}function install_nodejs_new(){    echo "=========================================="    echo "begin install nodejs..."    NOW_PWD=$(pwd)    cd /usr/local/src/    sudo wget https://nodejs.org/dist/v18.17.0/node-v18.17.0.tar.gz    sudo tar -zxvf node-v18.17.0.tar.gz    cd node-v18.17.0    sudo ./configure    sudo make    sudo make install    cd $NOW_PWD    if [ $1 = "CN" ]; then    npm config set registry https://registry.npm.taobao.org    npm config get registry    npm install -g cnpm --registry=https://registry.npm.taobao.org    fi    echo "=========================================="    echo "SUCCESS install newest nodejs!"}function install_vim(){    sudo apt update    sudo apt install vim    echo "set laststatus=2set numberset noebset ts=4set softtabstop=4set shiftwidth=4set expandtabset autoindent" | tee ~/.vimrc}function config_Chinese(){    echo "=========================================="    echo "begin config Chinese..."    sudo apt update    sudo apt install language-pack-zh-hans    echo 'LANG="zh_CN.UTF-8"LANGUAGE="zh_CN:zh"LC_NUMERIC="zh_CN"LC_TIME="zh_CN"LC_MONETARY="zh_CN"LC_PAPER="zh_CN"LC_NAME="zh_CN"LC_ADDRESS="zh_CN"LC_TELEPHONE="zh_CN"LC_MEASUREMENT="zh_CN"LC_IDENTIFICATION="zh_CN"LC_ALL="zh_CN.UTF-8"' | sudo tee /etc/default/localeecho "=========================================="echo "SUCCESS 配置中文！"}function config_English(){    echo "=========================================="    echo "begin config English..."    echo 'LANG=C.UTF-8LANGUAGE=LC_CTYPE="C.UTF-8"LC_NUMERIC="C.UTF-8"LC_TIME="C.UTF-8"LC_COLLATE="C.UTF-8"LC_MONETARY="C.UTF-8"LC_MESSAGES="C.UTF-8"LC_PAPER="C.UTF-8"LC_NAME="C.UTF-8"LC_ADDRESS="C.UTF-8"LC_TELEPHONE="C.UTF-8"LC_MEASUREMENT="C.UTF-8"LC_IDENTIFICATION="C.UTF-8"LC_ALL=' | sudo tee /etc/default/locale    echo "=========================================="    echo "SUCCESS config English!"}function config_system_proxy(){    if [ $1 = "OTHER" ]; then        return 0    fi    echo "=========================================="    echo "begin config your proxy..."    echo "Your HTTP PROXY:"    read HTTP_PROXY    echo "Your HTTPS PROXY?:"    read HTTPS_PROXY    echo "export HTTP_PROXY=\"$HTTP_PROXY\"" | sudo tee -a /etc/profile.d/proxy.sh    echo "export HTTPS_PROXY=\"$HTTPS_PROXY\"" | sudo tee -a /etc/profile.d/proxy.sh    sudo chmod u+x /etc/profile.d/proxy.sh    source /etc/profile.d/proxy.sh    echo "=========================================="    echo "SUCCEE config system proxy(HTTP, HTTPS) in /etc/profile.d/proxy.sh"}   function update_software(){    sudo apt upgrade    sudo apt update}function is_ip_cn(){    echo $1    COUNTRY=$(curl ipinfo.io | grep "country" | awk '{print $2}')    if [ $COUNTRY = '"CN",' ]; then        return 0    else        return 1    fi}if [ is_ip_cn ]; then    COUNTRY="CN"else    COUNTRY="OTHER"fichange_apt_source $COUNTRY;install_zsh $COUNTRY;change_ssh_config;install_git;config_system_proxy $COUNTRY;config_Chinese;update_software;install_docker $COUNTRY;install_nodejs_new $COUNTRY;install_vim;</code></pre><h2 id="🖥️GUI-Undoubtedly-Indispensable-VNC-xrdp-nohup">🖥️GUI Undoubtedly Indispensable(VNC,xrdp,nohup)</h2><h3 id="题目描述-5">题目描述</h3><ol><li>完成任意 Linux 云服务器 上的图形化环境搭建（如 gnome, xfce, kde ）</li><li>连接到桌面环境下打开 GVIM 和对应环境的终端（运行 neofetch/screenfetch） 并截图</li></ol><h3 id="过程-4">过程</h3><p>云服务器为腾讯云 CentOS 7.</p><p>系统必要的配置略过不提，直接到图形化界面部分。</p><pre class="language-bash" data-language="bash"><code class="language-bash">sudo yum grouplist # 检查可安装的group# 发现可安装GNOME Desktopsudo yum groupinstall "GNOME Desktop"# 安装vnc serversudo yum install vnc-server# 安装xrdpsudo yum install epel*sudo yum install xrdp# 启动xrdpsudo systemctl start xrdp# 查看xrdp启动状态sudo systemctl status xrdp# 设置开机自启sudo systemctl enable xrdp</code></pre><p>之后到腾讯云控制台开放3389端口：</p><p>Windows通过远程桌面连接程序指定ip进行连接，输入用户名密码即可进入桌面；安装gvim，neofetch，结束。</p><hr><p>使用以下命令后台执行firefox：</p><pre class="language-bash" data-language="bash"><code class="language-bash">nohup firefox &amp;</code></pre><h2 id="🚀萌新也想搭载上X-引擎-Nginx">🚀萌新也想搭载上X-引擎(Nginx)</h2><h3 id="题目描述-6">题目描述</h3><ol><li>在 Linux 系统上安装 Nginx 免费开源版（编译安装/包管理器安装），安装后在浏览器访问 Nginx 初始欢迎页面。</li><li>了解 Nginx 常见使用命令，寻找你的 Nginx 配置文件路径。</li><li>Nginx 的欢迎页面太丑了。修改配置文件，让浏览器访问显示该静态页面页面</li><li>使用一个 Nginx 代理3个页面，不同的端口号访问到不同的页面.</li><li>实现 URL 转发： 当 URI 请求为 /google 时，跳转到谷歌；当 URI 请求为 /github 时，跳转到 GitHub ；当 URI 请求为/cnss或/cnss/xxx 时，xxx 是任意字符串，跳转到 CNSS 招新官网；其余任意请求跳转到该静态页面。</li><li>搭建一个简易文件下载服务器，访问 /downloads 能够显示文件目录。</li><li>实现一个简单的负载均衡器，当访问同一个 URL 时，按照流量比 1 : 2 : 3 分别访问到 3 个不同的页面。<blockquote><p>Tip：Nginx upstream 可以将请求转发给多个后端 server，该怎样模拟多个 server 呢？</p></blockquote></li><li>实现 “URL 轮询器”，访问该 URL 时，轮询跳转到大佬们的博客。</li></ol><h3 id="要点-3">要点</h3><p>最花时间的一集<br>其他SA一下午便可完成，这题做了三四天，令人感叹。</p><p>nginx实现重定向的时候不需要太复杂，不要往proxy想就行。</p><h3 id="过程-5">过程</h3><p>CentOS 7 配置nginx：</p><p>yum源里头没有nginx availbale，选择编译安装nginx：</p><p>必要的环境已预装（实际上也就yum里头的几个软件）</p><pre class="language-bash" data-language="bash"><code class="language-bash"># stable nginxwget http://nginx.org/download/nginx-1.24.0.ziptar -zxvf nginx-1.24.0.zipcd nginx-1.24.0mkdir /var/temp/nginx -p# 编译配置./configure         --prefix=/usr/local/nginx \    --pid-path=/usr/local/nginx/nginx.pid \    --lock-path=/var/lock/nginx.lock     \    --error-log-path=/var/log/nginx/error.log \         --http-log-path=/var/log/nginx/access.log   \    --with-http_gzip_static_module     \    --http-client-body-temp-path=/var/temp/nginx/client  \    --http-proxy-temp-path=/var/temp/nginx/proxy \    --http-fastcgi-temp-path=/var/temp/nginx/fastcgi \    --http-uwsgi-temp-path=/var/temp/nginx/uwsgi   \    --http-scgi-temp-path=/var/temp/nginx/scgi \    --with-pcre \    --with-http_ssl_module \    --with-http_v2_module \    --with-http_realip_module \    --with-http_addition_module \     --with-http_sub_module \    --with-http_dav_module \    --with-http_flv_module \    --with-http_mp4_module \    --with-http_gunzip_module \    --with-http_gzip_static_module \    --with-http_random_index_module \    --with-http_secure_link_module \    --with-http_stub_status_module \    --with-http_auth_request_module \    --with-http_image_filter_module \    --with-http_slice_module \    --with-mail \    --with-threads \     --with-file-aio \    --with-stream \    --with-mail_ssl_module \    --with-stream_ssl_module \sudo make &amp;&amp; sudo make install# 测试一下cd /usr/local/nginx/sbinsudo ./nginx # nginx 启动！sudo ./nginx -t # 看看配置文件sudo ./nginx -s reload # 重启sudo ./nginx -s stop  # 关闭sudo ./nginx -v        # 看看版本# 添加服务sudo vim /usr/lib/systemd/system/nginx.service# 文件如下：# [Unit]# Description=nginx - high performance web server# Documentation=http://nginx.org/en/docs/# After=network.target remote-fs.target nss-lookup.target# # [Service]# Type=forking# PIDFile=/var/run/nginx/nginx.pid# ExecStartPre=/usr/local/nginx/sbin/nginx -t -c /usr/local/nginx/conf/nginx.conf# ExecStart=/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf# ExecReload= /usr/local/nginx/sbin/nginx -s reload# ExecStop= /usr/local/nginx/sbin/nginx -s stop# PrivateTmp=true# [Install]# WantedBy=multi-user.targetsudo chmod +x /usr/lib/systemd/nginx.servicesudo systemctl daemon-reloadsudo systemctl start nginx.servicesudo systemctl enable nginx.service# 常用指令## 平滑重启sudo nginx -s reload## 停止nginxsudo nginx -s stop## 检测下语法错误sudo nginx -t## 启动nginxsudo nginx</code></pre><p>nginx代理的静态页面文件布局如下：</p><pre class="language-bash" data-language="bash"><code class="language-bash">nginx/├── bg.jpg├── downloads│   ├── kknd│   └── nishi?├── index.html├── port│   ├── h1.html│   ├── h2.html│   └── h3.html└── todo    ├── index.html    ├── script.js    └── style.css</code></pre><p>nginx配置文件：</p><pre class="language-nginx" data-language="nginx"><code class="language-nginx">user  ?本机user;worker_processes  auto;error_log  logs/error.log;error_log  logs/error.log  notice;error_log  logs/error.log  info;pid  /usr/local/nginx/nginx.pid;events {    # ulimits -n是100001,这里就稍微小一点    worker_connections  1024;}http {    include       /usr/local/nginx/conf/mime.types;    default_type  application/octet-stream;    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '                      '$status $body_bytes_sent "$http_referer" '                      '"$http_user_agent" "$http_x_forwarded_for"';    #access_log  logs/access.log  main;    sendfile        on;    #tcp_nopush     on;    #keepalive_timeout  0;    keepalive_timeout  65;    gzip on;    gzip_types text/plain application/x-javascript text/css application/xml text/javascript application/javascript image/jpeg image/gif image/png;    gzip_vary on;          upstream balance {        server 本地配置域名:8081 weight=1 max_fails=5 fail_timeout=5;        server 本地配置域名:8082 weight=2 max_fails=5 fail_timeout=5;        server 本地配置域名:8083 weight=3 max_fails=5 fail_timeout=5;    }    upstream visit {        # 轮询实现url轮询器        server 本地配置域名:8084 max_fails=5 fail_timeout=5;        server 本地配置域名:8085 max_fails=5 fail_timeout=5;        server 本地配置域名:8086 max_fails=5 fail_timeout=5;    }     server {        listen       80;        server_name  本地配置域名;        #charset koi8-r;        access_log  logs/welcome.log main;        rewrite ^/google$ https://www.google.com permanent;        rewrite ^/github$ https://github.com permanent;        rewrite ^/cnss$ https://summer.cnss.io permanent;        rewrite ^/cnss/.*$ https://summer.cnss.io permanent;        location = / {            root   /???/nginx;            try_files /index.html /index.htm;        }        location / {            rewrite ^/.*$ /todo/ redirect;        }        location = /balance {            proxy_pass http://balance/;        }        location = /visit {                    proxy_pass http://visit/;        }        location /todo/ {            access_log logs/todo.log main;            alias /???/nginx/todo;            try_files /index.html /style.css;        }        location ^~ /downloads/ {            autoindex on;# 显示目录            autoindex_exact_size on;# 显示文件大小            autoindex_localtime on;# 显示文件时间            alias /???/nginx/downloads/;        }        error_page   500 502 503 504  /50x.html;    }    server {        listen        8081;            server_name   本地配置域名;        access_log    logs/h1.log      main;        location / {            root    /???/nginx/port;            index   h1.html h1.htm;        }     }        server {        listen        8082;            server_name   本地配置域名;        access_log    logs/h2.log      main;        location / {            root    /???/nginx/port;            index   h2.html h2.htm;        }     }    server {        listen        8083;            server_name   本地配置域名;        access_log    logs/h3.log      main;        location / {            root    /???/nginx/port;            index   h3.html h3.htm;        }     }    server {        listen 8084;        server_name 本地配置域名;        access_log   logs/visit1.log main;        location / {           rewrite ^.*$ https://yaossg.com redirect;        }    }    server {        listen 8085;        server_name 本地配置域名;        access_log   logs/visit2.log main;        location / {            return 302 https://www.cnblogs.com/timlzh;        }    }    server {        listen 8086;        server_name 本地配置域名;        access_log logs/visit2.log main;        location / {            return 302 https://sh1no.icu;        }    }    # 关注yaossg timlzh shino谢谢喵}</code></pre><p>若要继续改进，可有：</p><ol><li>keep-alived等增加可用性</li><li>docker一键部署</li><li>https域名+证书</li></ol><h2 id="🐋造个集装箱">🐋造个集装箱</h2><h3 id="题目描述-7">题目描述</h3><p>手动模拟一个Docker容器网络。</p><h3 id="要点-4">要点</h3><p>来张picture：</p><p><img src="/images/CNSS/docker_network.jpg" alt="docker 网络原理"></p><h3 id="过程-6">过程</h3><p>为了表示访问外网，写个flask先。</p><p>Flask <code>./app.py</code>:</p><pre class="language-python" data-language="python"><code class="language-python">from flask import Flask, render_templateimport requestsapp = Flask(__name__)@app.route('/')def moyu():    """    获取摸鱼人日历    """    url = "https://moyu.qqsuu.cn/?type=json"    img_url = ""    response = requests.get(url=url).json()    # 数据格式示例：（可以看到根本没必要用url来获取固定格式的图片url，但这里只是为了稍微展示一下能访问外网）    # {"code":200,"msg":"success","data":"https://moyu.qqsuu.cn/moyu/20230818.png"}    if response.get("code") == 200:        moyu_url=response["data"]        response = requests.get(moyu_url)        img_url = response.url    return render_template('index.html', img_url=img_url)if __name__ == '__main__':    app.run(host="0.0.0.0",port=80)</code></pre><p>Flask 渲染的html模版文件<code>./template/index.html</code>：</p><pre class="language-markup" data-language="markup"><code class="language-markup">&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;🖐️🐟&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;img src="{{ img_url }}"&gt;&lt;/body&gt;</code></pre><p>脚本文件（默认已装有必要工具）：</p><pre class="language-bash" data-language="bash"><code class="language-bash"># 创建网络namespacesudo ip netns add flask_test# 创建veth（Virtual Ethernet Pair），作为桥梁链接不同虚拟网络设备。sudo ip link add veth_ns type veth peer name veth_br# 将veth其中一端连入namespace中sudo ip link set veth_ns netns flask_test# 配置namespace端的veth ipsudo ip netns exec flask_test ip addr add 192.168.0.2/24 dev veth_ns# veth_ns 启动！sudo ip netns exec flask_test ip link set veth_ns up# 创建虚拟网桥sudo brctl addbr flask_br # 配置网桥ipsudo ip addr add 192.168.0.1/24 dev flask_br# 配置veth的另一端到网桥上#网桥flask_br和网络namespace flask_test相连sudo ip link set dev veth_br master flask_br# 两个都启动sudo ip link set veth_br upsudo ip link set flask_br up# 把 veth_ns设为默认网关# 此时内网部分便可以ping通sudo ip netns exec flask_test route add default gw 192.168.0.1 veth_nssudo sysctl -w net.ipv4.conf.all.forwarding=1# 本机路由转发配置（FORWARD规则），设置flask_br可以通过eth0（本地通网网卡）来进行与外网的通信。sudo iptables -A FORWARD --out-interface eth0 --in-interface flask_br -j ACCEPTsudo iptables -A FORWARD --in-interface eth0 --out-interface flask_br -j ACCEPT# SNAT 与MASQUERADE不同，MASQUERADE自动从网卡获取ip地址进行转换，SNAT需要指定ip进行转换# 进入路由判断前的规则添加，将源ip地址转换为本机ip地址。sudo iptables -t nat -A POSTROUTING -s 192.168.0.0/24 -j MASQUERADE# DNAT（目标网络地址转换），类似docker 端口绑定，将外网42062的访问绑定至192.168.0.2：80（本地服务端）sudo iptables -t nat -A PREROUTING -p tcp --dport 42062 -j DNAT --to 192.168.0.2:80# 一键安装flask环境（centos）# 由于执行部分需要root权限，需要再在root下安装依赖包。# 这部分和具体的自定义网络没什么关系，以注释方式呈现# sudo pip3 install flask# sudo pip3 uninstall urllib3# sudo pip3 install urllib3==1.26.6# sudo pip3 install requests# 在网络 namespace下运行nohup sudo ip netns exec flask_test python3 /.....?????/app.py --port 80 &gt; test.log 2&gt;&amp;1 &amp;</code></pre><p>运行截图：</p><p><img src="/images/CNSS/result.png" alt="docker network"></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> CNSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CNSS </tag>
            
            <tag> DevOps </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>综合课程设计：令人感叹</title>
      <link href="/2023/04/27/zong-he-ke-cheng-she-ji-ling-ren-gan-tan/"/>
      <url>/2023/04/27/zong-he-ke-cheng-she-ji-ling-ren-gan-tan/</url>
      
        <content type="html"><![CDATA[<p>课设过程没有记录时间线，因此该博客少了点条理性。<br>第一次写这种稍微大一点的项目，过程还是值得记录下的。</p><h2 id="开始">开始</h2><p>综合课程设计刚开始选题的时候，定位到负责我们这一块的申杰老师项目列表，所有项目几乎都和CV，机器学习相关，唯独一个文件加密传输十分显眼。5难度，刚好上学期上过密码学。不觉得很酷吗？很符合我对分数的想象。</p><p>于是我自信满满的选了，持续一个月的噩梦也开始了。</p><p>第一步自然是选择库<s>我怎么会先想着造轮子</s>。题目要求<code>C++</code>，那图形化软件很容易想到Qt；而密码库的选择倒是一波三折，原本想用成熟的OpenSSL的，但学习成本极大，于是翻知乎翻到现在用的<code>CryptoPP</code>库，有wiki有示例代码，想要的加密算法一应俱全，还是<code>C++</code>原生的，太好了，就它了！</p><p>然而之后大部分的bug（或者说，全部恼人的bug）都来源这个加密库。这部分暂且不提。</p><p><code>CryptoPP</code>库没有现成的lib，换句话说需要自己编译。打开它的github下载源码，发现这玩意使用VS编译的（<s>不用CMAKE?</s>）,源码里甚至有专门提供给VS2005的用户的<code>sln</code>文件.</p><p>好，那我就用VS2022给你编译了，然后喜闻乐见的报错了。翻网上资料发现要用VS2017，那就装！(电脑被VS狂暴鸿儒四五次才装好，<code>C++</code>下的SDK确实难绷)</p><p>编译好了（已经过去三四天了），配环境部分最恼火的来了：我该怎么让<code>Qt</code>和<code>CryptoPP</code>适配呢？<br>装了Qt七八回，Qt老版本的VS只支持VS2015套件，而新版本的VS2017套件不知道怎么回事检测不到本地的VS2017 SDK。折腾了三四天才挑出来符合的Qt版本，之后又花了一天在Qt的项目配置文件<code>.pro</code>边查边写,终于搞好了VS2017 编译的<code>CryptoPP</code>在windows下如何和VS2017 SDK套件的Qt以及qmake适配。</p><p><s>这就是装环境，听devops说</s></p><h2 id="网络通信部分（QT）">网络通信部分（QT）</h2><p>这部分其实没啥好说，各种抄，抄着抄着就把自己软件的框架搭好了，然后在这基础上改了。<br>后面翻了下，我在原来的代码上改了挺多的，看上去确实和原来代码差别很大。socket从两个到三个又到两个，还稍微学了下TCP的粘滞，以及Qt神奇的信号和槽机制。</p><p>若把TCP作为一种抽象流，那么我们是无法分辨其中数据意义的。若要分辨，必须事先知道文件/消息的长度，然后再根据长度进行截断。<br>需要指出的是，暴露密文的长度并不会影响安全性，因此可以将密文的长度直接暴露在不安全信道下。</p><p>Qt的信号与槽是可以反复绑定的。反复绑定对于某些情况是不要紧的，但如果你需要信号的参数，这就有大问题。我在一个函数里写了connect进行信号和槽的绑定，而该函数多次调用导致一个信号和多个槽（但其实是一个）进行了绑定。于是槽函数便收到了多个信号，而这些信号都是来源于同一个动作函数的。</p><h2 id="密码学部分（CryptoPP）">密码学部分（CryptoPP）</h2><p>具体细节放报告里了不想写，这里挑几个<code>CryptoPP</code>的神奇bug罢。</p><h3 id="中文">中文</h3><p>这个其实还好，<code>CryptoPP</code>不支持中文路径和中文名的文件加密。但还是可以吐槽：不是只对文件内部数据进行加密签名吗？名字按二进制存取不行吗？</p><h3 id="RNG">RNG</h3><p>不是电竞那个<code>RNG</code>，hz打来我就投降。</p><p><code>RNG</code>（Random number generator），在密码学中是十分重要的一个原语，用于生成伪随机数，然而<code>CryptoPP</code>的<code>RNG</code>行为十分特异：<code>RNG</code>定义后必须立即使用，不能放在其他地方（比如我原先放在一个统一管理的<code>CryptoManager</code> class里头）备用。否则<code>CryptoPP</code>自己推荐的“对加载的密钥必须进行验证（Valinate，该操作接受一个<code>RNG</code>和一个验证级别作为参数）”便会<code>Runtime-error</code>.</p><h3 id="DSA">DSA</h3><p>DSA是十分经典的数字签名方案，本来想在课设里实现一下的。但<code>CryptoPP</code>库的DSA内部出现了问题：我在同一份代码里对文件生成签名，之后立刻验证，直接RE。后面~~经过输出debug（ACM习惯了属于是）~~定位到<code>CryptoPP</code>库内部出现问题，没啥办法，删了罢。</p><h3 id="RSA">RSA</h3><p>RSA作为公钥加密方案，同时也支持数字签名。但运行过程中，<code>CryptoPP</code>库又出现了和DSA一样的错误。到这里我还是没发现为什么数字签名会产生错误，后面选择ED25519作为数字签名方案的时候才偶然发现，又是你，<code>RNG</code>！</p><p><code>CryptoPP</code>库的<code>RNG</code>支持极其不完善，而示例代码中，数字签名基本都需要使用<code>RNG</code>作为参数来进行验证。而WIKI中的ED25519示例代码十分特殊的把对应的<code>RNG</code>换成了<code>NullRNG</code>,这十分形象的名字，使得ED25519能够顺利进行签名。于是ED25519成为了课设里唯一的数字签名方案。</p><p>看到这里的你其实也明白了，理论上DSA，RSA这两个弃用的数字签名改改<code>RNG</code>就能恢复使用，但我懒了，不改了😇</p><h3 id="ED25519">ED25519</h3><p>ED25519是椭圆曲线数字签名方案，其公钥密钥长度为64/32 bytes，在其他语言中可以自由选择这两个。</p><p>但<code>CryptoPP</code>与众不同：头文件写明default情况下，ED25519应该生成32bytes的密钥，但它实际上生成了56bytes的密钥，前面多出来的24bytes是不变值。</p><p>若按照示例代码所写进行编程，那么密钥中将会包含24bytes的确定值，以及8bytes的随机值，而这显然会影响到ED25519的安全性。<br>而被DSA,RSA，以及接下来的GCM摧残许久的我放弃了修改（虽然修改确实会比较容易），多一事不如少一事，何况这ED25519能跑。能跑就行，不奢望太多了。</p><p><s>反正老师也看不懂</s></p><h3 id="GCM">GCM</h3><p>GCM是在对称密钥加密里头的操作模式，它提供了AE安全性，因此满足了CCA安全。。。。<br>以上部分换成人能听懂的，就是:GCM能够提供比采取普通操作模式更强的安全性，而这部分安全性的来源，很大程度上来源于它独立生成的GMAC 认证标签，这是其他操作模式所没有的。</p><p>这么好的安全性自然要拿来用了。照着wiki代码敲一遍，RE…RE？</p><p>翻了StackOverflow，发现示例代码是错的，代码把Tag长度和IV长度搞反了。呃呃💧。<br>最离谱的是：<code>CryptoPP</code> wiki专门写了：初始的IV向量可以是任意长度；但实际过程中，IV必须为12字节。</p><hr><p>另外还有诸如指针没有new变量导致程序出现奇怪bug，被yaossg(orz)指出后心态炸裂等nt行为，暂且不表。</p><h2 id="summary">summary</h2><p><code>CryptoPP</code>库极其难用，于是只能挑几个毛病最少的使用。但最本质的问题并不在此，而是：为什么要用<code>C++</code>开发？</p><p><code>C++</code>没有内置的密码库，所以我只能挑不靠谱的第三方库作为代替，而其他语言，比如JS,C#,JAVA,这些都有十分成熟且现成的密码库，并且图形化软件编写更比<code>C++</code>容易的多。而申请改换语言只要和老师说一句就行了。</p><p>当我发现这个问题的时候，我已经把代码写完了。</p><p>也许综设整个过程就是个笑话。哈哈。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 随想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Crypto </tag>
            
            <tag> 随想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Modern-CryptoⅫ-Digital-Signature</title>
      <link href="/2023/03/03/modern-cryptoxii-digital-signature/"/>
      <url>/2023/03/03/modern-cryptoxii-digital-signature/</url>
      
        <content type="html"><![CDATA[<p>公钥语境下的认证可以认为是加密方案的“逆操作”。在公钥加密方案中，发送者可以对消息用公钥加密，接收者用唯一一把私钥进行解密，从而保证消息的Secrecy。而认证方案，也就是接下来要介绍的数字签名中，发送者用私钥进行加密，接收者用公钥解密，这样便可以验证发送者的身份。</p><p>实际上，数字签名（公钥语境下的MAC）需要保证以下性质：</p><ol><li>Integrity protection：任何对一个被签名的消息的修改都会被发现。</li><li>Source authenticity 发送该消息的人身份得以验证。</li><li>Non-repudiation 发送者无法抵赖他发送了这条信息。</li></ol><h2 id="Definition">Definition</h2><p>一个数字签名方案可看作PPT 三元组$(Gen,Sig,Vrfy)$</p><p>$Gen(1^n)\rightarrow (pk,sk)$<br>$Sig_{sk}(m)\rightarrow$ 签名 $\sigma$。需要注意的是这里的m也和公钥加密方案一样被密钥制定消息空间。<br>$Vrfy_{pk}(m,\sigma)\rightarrow b$</p><p>特别的，数字签名允许以下Vrfy过程的可忽略概率的失败：</p><p>$Vrfy_{pk}(m,Sig_{sk}(m))=1$</p><p>$Vrfy$是确定性的，其可以具有“可忽略概率的失败”性质，也可以解密完全成功。<br>而$Sig$可确定可概率性，也可以无状态或者有状态，在实际过程中，无状态为实践做法。</p><p>上述过程中，我们构造了一个有限长度的数字签名方案，后续会介绍任意长度的方案。</p><h2 id="Formal-security-notions">Formal security notions</h2><p>数字签名需要新的威胁模型和安全目标。</p><h3 id="Attack-model">Attack model</h3><ol><li><strong>No-message attack (NMA)</strong>: 攻击者只能获取密钥信息。</li><li><strong>Random message attack (RMA)</strong>: 攻击者只能看到随机的信息流，其中包含数字签名。即类似于EAV的被动攻击。</li><li><strong>Non-adaptive chosen message attack (naCMA)</strong>: 攻击者可以主动构造一系列信息，并获得签名（构造的过程需在获得密钥之前）。</li><li>攻击者可以任意选择信息，并获得签名（无需考虑顺序）</li></ol><h3 id="Goal-of-an-adversary">Goal of an adversary</h3><p>攻击者的目标反过来就是安全目标（逃</p><ol><li><strong>Universal forgery(UF)</strong>: 攻击者需要对任意消息输出一个合法的signature。</li><li><strong>Existential forgery (EF)</strong>: 攻击者可对自己选定的消息输出合法signature。</li></ol><hr><p>因此，我们尽量选择最强的敌手能力，在此之下来保证其不能满足最弱的目标，作为我们的安全目标。</p><p>于是有EUF-CMA： existential unforgeability under chosen message attacks.</p><h3 id="EUF-CMA-Security">EUF-CMA Security</h3><p>略。定义方式和MAC的存在不可为造性极其相似，不想写了属于是。</p><p>需要注意的是，signature分为one-time（一次性）和many-time signatures，并且还有weak signature和strong（对于查询过的$m$，生成不一样但有效的$\sigma$）signature的区别。</p><h2 id="RSA-signatures">RSA signatures</h2><h3 id="“Textbook”-RSA">“Textbook” RSA</h3><p>这里的方案和课本上的RSA加密过程极其相似，不过是公钥和私钥作用的位置互换。</p><p>然而，RSA只能保证一次性的安全性，于是有一下攻击：</p><p><strong>NMA</strong>: $(m’,\sigma’)=(1,1)$，则必有$1^d=1\pmod N$<br><strong>EUF-CMA</strong>: 任意$(m_1,\sigma_1),(m_2,\sigma_2)$，都能构造新的一对：$(m’,\sigma’)=(m_1\cdot m_2\pmod N,\sigma_1\cdot\sigma_2\pmod N)$,其为合法数字签名。</p><h3 id="Hash-and-Sign">Hash-and-Sign</h3><p>理论上而言，使用定长的数字签名方案，重复多次也能够起到加密任意长信息的效果。然而，这并不能满足对高效率的需求。</p><p>很自然的便有了使用Hash再签名的方案。需要注意的是哈希函数$H$的值域也需要满足数字签名的消息空间要求。</p><p>于是有以下构造：$\Sigma=(Gen,Sig,Vrfy)$作为长度$k(n)$的定长数字签名方案，设$\Gamma=(Gen_H,H)$作为输出长度$k(n)$的哈希方案，则构造任意长度数字签名方案$\Sigma’=(Gen’,Sig’,Vrfy’)$</p><p>$Gen’: Gen(1^n)\rightarrow (pk,sk)，Gen_H(1^n)\rightarrow s$，公钥为$(pk,s)$,私钥为$(sk,s)$.<br>$Sig’: Sig_{sk}(H(s,m))\rightarrow$ 签名 $\sigma$。<br>$Vrfy’: Vrfy_{pk}(H(s,m),\sigma)\rightarrow b$</p><p>可以看到，这里添加了哈希函数的密钥s。</p><div class="admonition warning"><p class="admonition-title">Arbitrary long signature scheme</p><p>若$\Sigma$为安全定长数字签名，$\Gamma$为抗碰撞，则$\Sigma'$为任意长度的安全数字签名。</p></div><h2 id="Some-construct-scheme">Some construct scheme</h2><h3 id="RSA-FDH">RSA FDH</h3><p>若将普通RSA版本改为上方的Hash-and-Sign方式，则满足EUF-CMA性质，其证明用到了随机预言机。</p><h3 id="Scheme-based-on-DL-problem">Scheme based on DL problem</h3><p>接下来介绍的两方案本质上是一种无交互的零知识证明下使用DL problem的方案。</p><h3 id="Schnorr">Schnorr</h3><p>$Gen：\mathcal{G}(1^n)\rightarrow(G,q,g)$，均匀选择$x\leftarrow \mathbb{Z}_q,y=g^x$，则公钥为$(G,q,g,y)$,私钥为$x$。同时，选择$H:\{0,1\}‘\rightarrow \mathbb{Z}_q$<br>$Sign:m\in \{0,1\}’$，均匀选择$k\leftarrow \mathbb{Z}_q,I=g^k$，计算 $r=H(I,m),s=rx+k\pmod q $,最后输出$\sigma=(r,s)$.<br>$Vrfy:$ 计算 $I=g^s\cdot y^{-r}$，验证$r$是否等于$H(I,m)$</p><p>Correctness:$g^s\cdot y^{-r}=g^{rx+k}\cdot g^{-xr}=g^r=I$</p><div class="admonition warning"><p class="admonition-title">Schnorr</p><p>若H为随机预言机，则该问题基于DL problem下满足EUF-CMA secure。</p></div><h3 id="DSA-ECDSA">DSA/ECDSA</h3><p>这里只介绍DSA（因为不会椭圆曲线<s>最重要的原因是PPT没有</s>）</p><p>$Gen：\mathcal{G}(1^n)\rightarrow(G,q,g)$，均匀选择$x\leftarrow \mathbb{Z}_q,y=g^x$，则公钥为$(G,q,g,y)$,私钥为$x$。同时，选择$H:\{0,1\}‘\rightarrow \mathbb{Z}_q$和函数$F:G\rightarrow \mathbb{Z}_q$<br>$Sign:m\in \{0,1\}’$，均匀选择$k\leftarrow \mathbb{Z}_q,r=F(g^k)$，则计算$s=k^{-1}(H(m)+rx)\pmod q $。若 $r,k,s$任意一个为0，则重新开始，选择全新的k。最后输出$\sigma=(r,s)$。<br>$Vrfy:$ 计算 $u=s^{-1} \pmod q$，验证$r$是否等于$F(g^{H(m)u}y^{ru})$</p><p>Correctness类似上方，化简下就出来了。</p><p>DSA工作在素数 $q$ 阶群，并且$F(I)=I \pmod q$,ECDSA类似。</p><div class="admonition warning"><p class="admonition-title">DSA/ECDSA</p><p>若$H,F$为随机预言机，那么该方案的EUF-CMA 基于DL问题。</p></div><hr><p>需要注意的是，这两个方案并不是完全安全的。</p><h3 id="One-time-signatures">One-time signatures</h3><p>$Gen：\mathcal{G}(1^n)\rightarrow(G,q,g)$，均匀选择$x，y\leftarrow \mathbb{Z}_q,h=g^x,c=g^y$，则公钥为$(G,q,g,h,c)$,私钥为$(x,y)$。<br>$Sign:m\in \{0,1\}'$,计算$\sigma=(y-m)x^{-1} \pmod q$<br>$Vrfy:$ 计算 $u=s^{-1} \pmod q$，验证$c=g^mh^\sigma$</p><p>Correctness: $g^m,c^\sigma=g^{m+x\sigma}=g^{m+x(y-m)/x}=g^y=c$</p><div class="admonition warning"><p class="admonition-title">One-time signatures</p><p>该方案基于DL problem 满足 EUF-1-naCMA安全性。</p></div><h2 id="杂项">杂项</h2><h3 id="Generic-compilers-for-strong-security">Generic compilers for strong security</h3><ol><li><strong>CMA from RSA</strong> 任意的RMA方案（消息空间 $k,q(k)$）都能构造出$q(k)$消息空间的CMA 方案。<br>具体而言，对消息$m\in\{0,1\}^*$，随机选择$m_L\rightarrow \{0,1\}^q$，计算$m_R=m_L\oplus m$则有$m=m_L\oplus m_R$,两个都具有随机性。<br>随机选择$r\leftarrow\{0,1\}^k$,则$r||m_L,r||m_R$分别可作为独立的$sk_L,sk_R$。</li><li><strong>CMA from naCMA</strong>,通过使用一次性的naCMA方案生成消息的数字签名，并使用长期的naCMA方案来对一次性naCMA方案签名，即可构造CMA。</li></ol><h3 id="CA">CA</h3><p>略。</p><h3 id="碎碎念">碎碎念</h3><p>啊哈哈，终于在紧赶慢赶，摸鱼摆烂中写完了这个密码学博客，原本作为考试复习的博客后面发现写了太多太花时间，结果忽略了最后公钥加密的章节，在开始考试的时候我还没有写11章，12章博客，现在我密码学分数已经出来了，93，在大题炸了的情况下还算能够接受。</p><p><s>但我其他科目炸了</s></p><p>本博客糟糕的文笔（很多地方都是纯记流水账）使这个博客可读性大大降低。我尽力使这博客看起来“对新手友好”，但一千个读者有一万个yy顶针，如果因为本博客的糟糕体验（迫真）而使你失去了对现代密码学这门课的兴趣，万分抱歉😭。</p><p>原著<code>Introduction to MODERN CRYPTOGRAPHY</code>的条理性以及知识点补充是极强的，还是来看看远处的原著吧家人们。</p><p>开始写这个博客的时候还是去年11月26号，现在3月3号我才写完这博客，即使花了这么长时间<s>从寒假才开始认真学这密码学</s>，我还是没法克服自己摆烂摸鱼的习惯，有趣的证明我几乎一个没写，而让我对密码学有兴趣的一大原因恰恰就是证明部分，限于精力和时间等因素没有办法完成，不能不说是一种遗憾。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Crypto </tag>
            
            <tag> Public key </tag>
            
            <tag> Digital Signature </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Modern CryptoⅪ Public-key-Encryption</title>
      <link href="/2023/02/24/modern-cryptoxi-public-key-encryption/"/>
      <url>/2023/02/24/modern-cryptoxi-public-key-encryption/</url>
      
        <content type="html"><![CDATA[<p>上章讲了公钥密码的优点，这里来点缺点：</p><ol><li>公钥密码不能指定发送者。公钥是公开的，那么任何人都可以发送给持有私钥的接收者信息。</li><li>最主要的还是效率，公钥密码的时间复杂度比私钥密码高出2-3个数量级。</li></ol><h2 id="Security-distribution-of-public-keys">Security distribution of public keys</h2><p>到目前为止，我们对公钥密码的讨论仅限于被动（EAV）敌手。若敌手能够截获所有信息，并且通信双方没有在此之前共享密钥，则无法实现secrecy。</p><p>因此，在本章有一个很重要的假设：发送者能够直接获得接收者的公钥（安全密钥分发）。该假设的原因是因为存在有其他方式能够抵御主动攻击，因此将密钥分发和公钥加密的安全性分开讨论是合理的。</p><h2 id="CPA-attacks">CPA attacks</h2><h3 id="EAV-Security">EAV Security?</h3><hr><p>$PubK_{\mathcal{A},\prod}^{\mathbf{eav}}$ expriment</p><ol><li>敌手预言机事先给定安全参数n。</li><li>预言机:$(pk,sk)\leftarrow Gen(1^n),b\leftarrow \{0,1\}$，并将公钥返回给攻击者。</li><li>攻击者$\mathcal{A}$ 发送$(m_0,m_1)$,预言机返回$c’\leftarrow Enc_{pk}(m_b)$</li><li>攻击者返回$b’$，若$b=b’$ 返回1，否则0.</li></ol><hr><div class="admonition warning"><p class="admonition-title">EAV Security</p><p>A public-key encryption scheme $\prod =(Gen, Enc, Dec)$ has indistinguishable encryption in the presence of an eavesdropper if for all probabilistic polynomial-time adversary $\mathcal{A}$ there is a negligible function $negl$ such that$Pr[PubK_{\mathcal{A},\prod}^{\mathbf{eav}}(n)=1]\leq 1/2+negl(n)$</p></div><h3 id="Public-key-definition">Public key definition</h3><p>$Gen(1^n)$生成公钥$pk$,私钥$sk$.<br>$Enc_{pk}( m)\rightarrow c$，其中m从消息空间$\mathcal{M}$中获取。<br>$Dec_{sk}( c)\rightarrow m\quad or\quad<br>\bot$</p><p>需要注意的是，公钥密码允许有可忽略的概率使得<br>$Dec_{sk}(Enc_{pk}(m))=m$不成立。<br>因此，Enc可以是确定性或概率性的，Dec允许Perfectly Correct，但也允许以可忽略概率失败。</p><p>需要注意的是，每一个公钥密码的实例中，消息空间都是隐含着与公钥$pk$有关，可能是某些代数结构中的元素。因此，消息m可能需要转换。</p><h3 id="Some-Theorem">Some Theorem</h3><div class="admonition info"><p class="admonition-title">CPA-Secure</p><p>若公钥加密方案保证EAV安全，那么其也是IND-CPA-Secure（IND= indistinguishable）</p></div><p>这条很好说明，公钥的公开使任何人都可以加密信息，相当于获得了$Enc$预言机。</p><div class="admonition info"><p class="admonition-title">Perfect secret</p><p>没有任何公钥加密方案能保证完美加密。</p></div><p>不做证明（之后看看能不能补上）</p><div class="admonition info"><p class="admonition-title">Deterministic encryption scheme</p><p>没有确定性的公钥加密方案满足IND-CPA-Secure</p></div><p>在实践中，我们想让同一条公钥pk去加密多条消息，于是有：</p><div class="admonition warning"><p class="admonition-title">Multiple Encryption</p><p>若公钥加密方案满足IND-CPA-secure，那么其也满足multiple encryption的不可区分性。</p></div><h2 id="Arbitrary-long-messages">Arbitrary long messages</h2><p>由上文对多消息加密的安全性，可以构造一个加密方案，其基于最初的公钥加密：每一块都来个加密然后发送。该方案是IND-CPA-secure的。</p><p>然而，这不够高效，于是有混合加密方案：</p><p>公钥加密只加密私钥加密的密钥，私钥加密整条信息连带着公钥加密的密钥一同发送。</p><h3 id="CCA-attacks">CCA attacks</h3><hr><p>CCA attack experiment</p><ol><li>事先给定n，</li><li>预言机:$(pk,sk)\leftarrow Gen(1^n),b\leftarrow \{0,1\}$，并将公钥返回给攻击者。</li><li>攻击者发送密文$c_i$,预言机返回$Dec_{sk}(c_i)$</li><li>可进行多次第三步，之后敌手发送$m_0,m_1$,预言机返回$c’$<br>之后还可以多次进行第三步，但无法对$c’$进行Dec。</li><li>敌手发送b’,之后和其他定义一样。</li></ol><hr><div class="admonition warning"><p class="admonition-title">CCA-secure</p><p>对任意PPT敌手$\mathcal{A}$,若满足以下性质，则满足CCA-secure：$$Pr[PubK_{\mathcal{A},\prod}^{\mathbf{cca}}=1]\leq 1/2+negl(n)$$</p></div><h2 id="Key-encapsulation-machanism-KEM">Key-encapsulation machanism(KEM)</h2><p>KEM定义为$Gen,Encaps,Decaps$</p><p>$Gen(1^n)\rightarrow (pk,sk)$<br>$Encaps(1^n,pk)\rightarrow (c,k),k\in\{0,1\}^{p(n)}$<br>$Decaps(sk,c)\rightarrow k$</p><p>同样也要求存在可忽略的概率不成功（公钥啊嗯）</p><hr><p>KEM experiment</p><ol><li>事先给定n。</li><li>预言机$Gen(1^n)\rightarrow (pk,sk),Encaps_{pk}(1^n)\rightarrow (c’,k)$,随机选择$b\leftarrow\{0,1\}$，若b=0，k’=k，否则k从$\{0,1\}^n$随机获取，返回敌手$(pk,(c’,k’))$</li><li>敌手返回b’，剩余和其他预言机定义相同。</li></ol><hr><div class="admonition warning"><p class="admonition-title">warning</p><p>对任意PPT敌手$\mathcal{A}$,若满足以下性质则有CPA-secure：$$Pr[KEM_{\mathcal{A},\prod}^{\mathbf{pa}}=1]\leq 1/2+negl(n)$$</p></div><p>用先前构造的公钥密码方案（IND-CPA/IND-CCA）可以很容易构造KEM(IND-CPA/IND-CCA)，构造方法略（懒），把加密的消息换成k就行了。</p><p>需要注意的是，由于k本身需要“随机”选择，因此消息空间需要具有合适的“min-entropy”。</p><p>当然，专门的KEM算法效率肯定比这种构造的效率要高。</p><h3 id="Hybrid-Encryption">Hybrid Encryption</h3><p>有了KEM，就可以构造更高效的（混合）公钥加密。</p><p>设$\prod=(Gen,Encaps,Decaps),\prod’=(Gen’,Enc’,Dec’)$,构造$\prod^{hy}=(Gen^{hy},Enc^{hy},Dec^{hy})$</p><p>$Gen^{hy}:(pk,sk)\leftarrow Gen(1^n)$<br>$Enc^{hy}:c’ \leftarrow Enc_k’(m)$<br>output:$(c,c’)$<br>$Dec^{hy}:k=Decaps_{sk}©,m=Dec_k’(c’)$</p><div class="admonition info"><p class="admonition-title">info</p><p>若$\prod$ 是CPA-secure KEM，$\prod'$私钥密码是EAV下安全，则$\prod^{hy}$是CPA-secure的。</p></div><div class="admonition info"><p class="admonition-title">info</p><p>若$\prod$ 是CCA-secure KEM，$\prod'$私钥密码是CCA-secure，则$\prod^{hy}$是CCA-secure的。</p></div><h2 id="EIGamal-Encryption">EIGamal Encryption</h2><p>基本思路：<br>利用DH problem，接收者选择$a\leftarrow \mathbb{Z}_q$作为私钥，而把群$(G,q,g)$和$g^a$作为公钥公开，那么任何人可以指定b，传输$g^b，K\cdot M$给接收者，则接收者运行$K\leftarrow(g^b)^a$,从而解密，并共享密钥。</p><h3 id="scheme">scheme</h3><p>$Gen(1^n):Run(G,q,g)\leftarrow\mathbb{G}(1^n)$随机选择$x\leftarrow\mathbb{Z}_q$,计算$y=g^x$<br>$$(sk,pk)=((G,q,g,x)(G,q,g,y))$$<br>$Enc(m,pk):$对于输入m，随机选择$r\leftarrow\mathbb{Z}_q,$<br>$$C=(g^r,m\cdot y^r)$$<br>$Dec(C,sk):C=(C_1,C_2),$<br>$$m=C_2\cdot(C_1^x)^{-1}$$</p><p>在这里可以认为$(G,q,g)$为安全参数。</p><h3 id="Security">Security</h3><div class="admonition warning"><p class="admonition-title">lemma EIGamal</p><p>设$G$为有限群，$m\in G$任意，随机选择的$k\in G$和设置的$k'=k\cdot m$具有相同的分布，即对任意的$g'\in G$$$Pr[k\cdot m=g']=1/G$$</p></div><p>上方的lemma中，可以看到类似于私钥密码中的一次一密定义，那么由此，可以设想出另外一种"EIGamal"的加密方式：</p><p>随机选择$g^z$,让密文$C=(g^r,m\cdot g^z)$</p><p>因此， $g^z$ 对敌手是未知的，则其能够满足信息论安全（即完美加密）</p><p>EIGamal的安全性证明便基于此类的不可区分性小于$1/2+negl(n)$,而其证明又依赖于DDH assumption。</p><p>安全证明就略了。（😋）</p><h2 id="RSA-attacks">RSA attacks</h2><p>回顾一下“课本”上的RSA：</p><p>$Gen()$:选择两个大素数p，q，N=pq，均匀选择e，$1&lt;e&lt;\phi(N)$且$gcd(e,\phi(N))=1$.计算$d,ed=1\quad \phi(N)$<br>$Enc(pk,m): c=m^e\quad mod N$<br>$Dec(sk,c): m=c^d \quad mod N$</p><div class="admonition missing"><p class="admonition-title">RSA in our class</p><p>课本上的RSA是不能够直接使用的。</p></div><p>RSA假设中，m是随机均匀选择的，但其本质上而言，消息并不满足这一条件。同时，RSA加密过程是确定性的，因此必定不是安全的。</p><p>具体攻击方法略。反正很容易构造捏。</p><hr><p>由上，RSA在实际使用过程中需要进行预处理等过程，才能够真正作为加密算法进行公钥加密。</p><p>RSA-OAEP便用了哈希函数，使得RSA-OAEP是CCA Secure的（证明过程中用到了随机函数，其用SHA-256进行实例化。）</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Crypto </tag>
            
            <tag> Public key </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Modern-CryptoⅩ Key management and public key revolution</title>
      <link href="/2023/02/16/modern-cryptox-key-management-and-public-key-revolution/"/>
      <url>/2023/02/16/modern-cryptox-key-management-and-public-key-revolution/</url>
      
        <content type="html"><![CDATA[<p>在此之前，我们讨论了私钥密码学的安全性，但没有解决一点：如何分发密钥？</p><p>Perfect Secret中的OTP可以采用线下的交换密钥，但如今的网络无法这样做。同时，私钥密码还需要保证密钥管理的安全性，并且也不适用于开放的系统中安全通信的需求。</p><h2 id="Partial-Solution：Key-Distribution-Centers-KDC">Partial Solution：Key-Distribution Centers(KDC)</h2><p>在封闭系统中，能够构造出这样一种密钥管理方案，系统中KDC服务器来分配密钥，每一个用户都保存和KDC安全通信的长期密钥，而KDC按需返回用户短期密钥。</p><div class="admonition info"><p class="admonition-title">符号说明</p><p>$S$:KDC Server$A,B$,用户。$K_{AS},K_{BS}$，$A,B$保存的长期密钥。$\{M\}_K$被K加密且认证的消息M，可以采用任何的AE scheme，$K=(K_0,K_1)$,并采用Encrypt-then-MAC。</p><hr><p>P.S. 用户A，B在密码学论文中又可以叫做Alice，Bob，没有特殊的含义，只是约定俗称的叫法:-)，本文在之后也会出现$A$,Alice等混用的情况。</p></div><h3 id="toy-protocol-First">toy protocol(First)</h3><p>很容易的，我们可以构造出这样一个方案：</p><ol><li>$A$试图与B建立联系，向$S$发送$(A,B)$</li><li>$S$随机选择密钥$K$,并发送$\{K\}_{K_{ AS} }\{K\}_{ K_{ BS} }$<br>$\{K\}_{K_{ BS} }$可以认为是S发送的ticket。</li><li>$A$向$B$发送$\{K\}_{K_{BS} },A$，建立联系。</li></ol><p>可以看到，其满足CPA-Secure。然而，其无法抵御中间人攻击：进行第三步时，中间人敌手截获A发送的信息，并向B发送$\{K\}_{K_{BS} },Eve$。</p><h3 id="Second：suffer-from-replay-attack">Second：suffer from replay attack</h3><p>很容易想到，若中间人可以截获身份并顶替，那么将身份信息也随之加密发送即可。于是将上述方案中$\{K\}_{K_{?S} }$转为$\{K,?\}_{K_{otherS} }$</p><p>然而，该方法同样也可以遭受重放攻击。敌手可以存储KDC发送的值并重放，这样便可以使其复用密钥，导致不安全性。</p><h3 id="Third-Needham-Schreoder-1972">Third: Needham Schreoder 1972</h3><p>因此，便有了$Nonce$概念。<br>$Nonce$的字面意义是“number used once”,一次性有效。一般而言，$Nonce$是随机选择的数，其在通信中用于证明该信息是全新生成而不是重放的。</p><p>于是，在上述过程的第一步中A将发送$N_A$,第二步中$\{K,B\}_{K_{AS} }$改为$\{K,B,N_A\}_{K_{AS} }$</p><hr><p>然而，该协议仍然存在缺陷。倘若敌手发送$\{K_{old},A\}_{K_{BS} }$ ,B无法判断该密钥是否重放。</p><h3 id="Kerboros">Kerboros</h3><p>（真实的Kerboros是很复杂的，这里随便写点了）</p><ol><li>$A$ 向$S$发送$(A,B,N_A,N_B)$</li><li>$S$选择随机密钥$K$，发送$\{K,B,N_A\}<em>{K</em>{AS} },\{K,A,N_B\}<em>{K</em>{BS} }$</li><li>$A$发送$\{K,A,N_B\}<em>{K</em>{BS} }$，$B$发送$(B,N_B)$。</li></ol><p>同时，Kerboros通过timestamps来保证key的freshness。</p><h3 id="conclusion">conclusion</h3><p>KDC能够保证封闭系统内的可扩展性，能够接纳更多的成员，用户只需要存储KDC keys，在通信的时候只需要KDC生成session keys 即可。</p><p>然而，其无法在开放系统如Internet中具有扩展性，并且其依赖于KDC的honesty、available。没有其他措施保证KDC的可信，KDC一旦故障也可能导致事故。</p><h2 id="Public-Key-Cryptography">Public-Key Cryptography</h2><p>现构造一个实验：</p><p>Alice、Bob想要构建EAV下安全的通信。（现在先讨论没有篡改下的纯EAV攻击）</p><p>选定一个素数q，生成q阶群，生成元为$g$。</p><p>有以下密钥生成：</p><ol><li>Alice生成$g^a$,$a\leftarrow \mathbb{Z}_q$，同理Boc生成$g^b$</li><li>两者直接互相发送$g^?$，并根据各自的生成数，生成密钥$(g^b)^a\quad (g^a)^b$</li></ol><hr><p>定义$\mathbf{KE}_{\mathcal{A},\prod}^{\mathbf{eav}}$实验：</p><p>在这里，安全参数为$\mathcal{G}$生成的$(G,q,g)$</p><ol><li>预言机生成(k,trans)，随机选择$b\leftarrow\{0,1\}$，若$b=0$，$k’=k$，否则$k’$从$G$中均匀选择,返回敌手$(k’,trans)$</li><li>敌手返回$b’$.</li></ol><hr><div class="admonition warning"><p class="admonition-title">key-exchange protocal $\prod$</p><p>it's secure in the EAV if for every PPT $\mathcal{A}$$$Pr[b=b']\leq 1/2+negl(n)$$</p></div><p>其安全性基于DDH问题。</p><div class="admonition info"><p class="admonition-title">DDH and Diffie-Hellman key-exchange protocol</p><p>若DDH是困难的，那么DH 密钥交换协议在EAV下是安全的。</p></div><p>需要注意的是，这里选取得是有限群里的元素，因此可以用键控函数转化为nbits string以保证安全性。具体转换略。</p><hr><p>DH密钥交换协议保证了EAV下的密钥交换是安全的，但其无法抵御中间人攻击。然而，其第一次证明了非对称技术，以及数论相关知识可以用于密码学的密钥分发问题。其仍然为标准密钥交换协议的核心。</p><h2 id="Public-Key-revolution">Public-Key revolution</h2><p>PPT无，不作为考纲，但觉得有趣就搬来了。</p><p>在Diffie-Hellman发布他们的密钥交换协议时，他们也提出了非对称的密码学。</p><p>在此基础上，出现了RSA等公钥加密方案，也出现了数字签名这一公钥密码学下的认证手段。</p><p>公钥加密有以下特征：</p><ol><li>公钥密码学允许通过公开(但经过身份验证)的通道进行密钥分发，其可以简化共享密钥的分发与更新。</li><li>公钥密码能够减少用户存储密钥的数量，例如在公司情境下，每个员工只需要存储自己的私钥和相对于其他所有员工公钥即可，公钥甚至不需要保密，可以存储在中央存储库中。</li><li>公钥密码更适用于开放环境，通信双方即使没有通信过也能够建立安全通信信道。</li></ol><p>可以说，公钥加密是对密码学的一次革命。在公钥密码学出现前，密码学一般属于情报等领域，而公钥技术出现后，便有了TLS、SSL这些使用。</p><hr><p>严格说来，公钥密码比私钥密码要更强，每个公钥密码方案都可以用作私钥密码加密方案（既然EAV无法在公钥公开的情况下破解，公钥若保密更无法破解），但私钥密码学的效率更高，可以和公钥密码学进行适当组合使用。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Crypto </tag>
            
            <tag> Public key </tag>
            
            <tag> Key management </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Modern-CryptoⅨ Public key and Pre knowledge</title>
      <link href="/2023/02/13/modern-cryptoix-public-key-and-pre-knowledge/"/>
      <url>/2023/02/13/modern-cryptoix-public-key-and-pre-knowledge/</url>
      
        <content type="html"><![CDATA[<p>信安数学爷们可以跳过这章（</p><p>同时，这章只是为了稍微有点数论基础的人恶补一下所需知识，没有接触过数论的还是稍微学学再来（</p><h2 id="math">math</h2><h3 id="Integers-mod-N">Integers mod N</h3><p>gcd，以及$\xi(N)$(欧拉函数)。</p><p>关于欧拉函数，可以看 <a href="https://oi-wiki.org/math/number-theory/euler/">OI-WIKI</a></p><p>需要了解其积性函数的性质。</p><h3 id="Division-Remainder-Modulo">Division Remainder Modulo</h3><p>数论基础的mod表示：$a \equiv b\quad mod\quad N$<br>其性质较为简单。</p><h3 id="Groups">Groups</h3><p>近世代数,其研究的是抽象意义上的代数运算，因此其运算规则需要重新定义。群这种代数结构满足以下性质：</p><ol><li>闭包：$\forall g,h\in G,g\cdot h\in G$.</li><li>单位元：$\exists e\in G\quad s.t. \forall g\in G,e\cdot g=g=g\cdot e$.</li><li>逆元：$\forall g\in G,\exists h\in G,g\cdot h=e=h\cdot g$</li><li>结合律：$\forall g,h,f\in G,(g\cdot h)\cdot f=g\cdot (h\cdot f)$</li></ol><p>群满足以下性质被称为交换群：</p><p>$\forall g,h\in G,g\cdot h=h\cdot g$<br>在密码学中，我们基本上只讨论交换群。</p><p>Example:<br>若N&gt;0，那么$G=\{a\cdot b mod N\}$是一个群。</p><h3 id="幂">幂</h3><p>简写$g^m=g\cdot g\cdot g…g$,加法群也是类似定义，于是有：</p><ol><li>$g^{i+j}=g^i\cdot g^j$</li><li>$g^{ij}=(g^i)^j=(g^j)^i$</li><li>$g^{-i}=(g^i)^{-1}=(g^{-1})^i$</li></ol><h3 id="order-of-a-Group">order of a Group</h3><p>若G是有限群，那么$m=|G|$为其阶。<br>则满足以下性质：$\forall g\in G,g^m=1$（单位元）<br>推论：$G$为有限群，那么$g^x=g^{x\quad mod\quad m}$</p><h3 id="求幂方式">求幂方式</h3><p>对于求$a^n$中n十分庞大的情况，可以通过快速幂的思想快速求解。关于快速幂，感觉是算法竞赛基本功了，搜搜就有（</p><h3 id="Cyclic-Groups">Cyclic Groups</h3><p>现定义$G=\{g_0,g_1,…\}$为有限群，其阶为m。</p><p>设$i\leq m$是能够满足以下性质的最小正整数：$g^i=1$,其可以构建这样一个群：$g^i=g^0,g^{i+1}=g^i,&lt; g &gt;=\{g^0,g^1,…g^{i-1}\}$</p><p>那么，我们叫i为元素$g$的阶，而$&lt; g &gt;$是G的子群，由g生成。</p><p>若由一个元素$g\in G$,其阶为$m=|G|$，那么G被称为循环群。</p><div class="admonition info"><p class="admonition-title">info</p><p>若G为m阶群，$g\in G$有阶$i$ ，则$i|m$</p></div><p>若p是素数，则$Z^*_{p}=\{1,2,3,4,…p-1\}$是阶为p-1的循环群。</p><h3 id="Generating-random-primes">Generating random primes</h3><div class="admonition info"><p class="admonition-title">Bertrand’s postulate</p><p>$\forall n&gt;1$,the fraction of n-bit integers that are prime is at least $1/3n$.</p></div><p>有算法能够生成随机的素数，但实现其算法的要点在于如何判断一个数为素数。于是有素性测试。</p><h3 id="Probabilistic-primality-test（素性测试）">Probabilistic primality test（素性测试）</h3><p>确定性的测试一个素数思路很简单，但用概率测试能够更有效率的解决。其对于所有的素数，都会输出正确的结果，但可能会误判合数为素数。</p><p>素性测试采用 <a href="https://oi-wiki.org/math/number-theory/fermat/">费马小定理</a>，而素性测试可以见 <a href="https://oi-wiki.org/math/number-theory/prime/#%E7%B4%A0%E6%80%A7%E6%B5%8B%E8%AF%95">这里</a></p><h3 id="因数">因数</h3><p>对于一个数而言，若其只有大的质因数，那么分解它是很难的；但找到任意给定的N的较小因数是较为简单的：$Pollard~rho$算法。关于Pollard rho算法，可以在OI WIKI中找到。</p><p>定义GenModule实验：</p><hr><p>事先给定安全参数n</p><ol><li>预言机生成（$N,p,q$），返回敌手$N$，其中$N=pq$，$pq$为nbits 素数.</li><li>敌手发送$p’,q’$，若$N=p’q’$，返回1，否则返回0.</li></ol><hr><div class="admonition warning"><p class="admonition-title">Definition Factoring hard</p><p>Factoring is hard 这一结论基于以下性质：对任意PPT 敌手$Pr[Factoring_{\mathcal{A,\mathbf{GenModulus}}}=1]\leq negl(n)$</p></div><h2 id="RSA-assumption">RSA assumption</h2><p>定义GenRSA实验：</p><hr><p>事先给定安全参数n。</p><ol><li>预言机生成（$N,e,d$）返回敌手$N,e,y$，其中$N=pq,gcd(e,\phi(N))=1,ed=1\quad mod \phi(N)$,y为均匀选择。</li><li>敌手返回x，若$x^e=y\quad mod N$ 返回1，否则返回0.</li></ol><hr><p>定义RSA是困难的，类似上方Factoring 定义方式。</p><p>RSA的经典构造方式，就不用细讲了罢）网上一搜都有的。</p><p>需要说明的是，RSA算法基于的假设并不是“大整数因式分解是困难的”，其基于的是上方的RSA问题。即使现基于RSA的攻击基本上都是基于大整数因式分解。</p><p>实际上，RSA的难度不可能比Factoring更难，但RSA问题的难易程度是否由Factoring所决定，也是一个悬而未决的问题。一般而言，RSA问题可能可以在PPT内完成，但Factoring则不能。</p><hr><p>同时，普通教材上的RSA实际上不太可能在实际方案中出现，实际方案的RSA已经经过修改，但仍基于最基本的RSA算法。</p><h2 id="Generators">Generators</h2><div class="admonition info"><p class="admonition-title">info</p><p>若G为q阶循环群，q&gt;1,其生成元为g，那么G一共有$\phi(q)$个生成元。</p></div><p>推论：若G为q阶群，q为素数，那么G为循环群；同时，除了单位元，任何G的元素都是生成元。</p><hr><p>若G为q阶群，q可以表示为 $\prod p_i^{e_i}$，则选择$q_i=q/p_i$，当且仅当$h\in G,h^{q_i}\neq 1$时h为G的生成元。</p><h2 id="Discrete-logarithms">Discrete logarithms</h2><p>现选择q阶循环群，那么可以定义DL problem：</p><hr><p>DL problem：给定$h=g^x$去寻找x。</p><p>让$\mathcal{G}$为群生成器，其输入为$1^n$,输出一个循环群 $(G,q,g)$,其中$|q|=n$。</p><p>则有：$DLOG_{\mathcal{A},\mathcal{G}}$:</p><ol><li>运行 $\mathcal{G}(1^n)$.</li><li>均匀选择元素$h\in G$</li><li>敌手被给定：$G,q,g,h$并返回预言机$x\in \mathbb{Z}_q$</li><li>若$g^x=h$输出1，否则返回0。</li></ol><hr><div class="admonition warning"><p class="admonition-title">Discrete-logarithm</p><p>定义离散对数问题是难的，其依赖于上述实验对任意PPT敌手：$$Pr[DLOG_{\mathcal{A},\mathcal{G}}=1]\leq negl(n)$$</p></div><p>基于DL problem，现讨论以下较为弱的问题</p><h3 id="computational-Diffie-Hellman-CDH">computational Diffie-Hellman(CDH)</h3><p>让$DH_g(h_1,h_2)=g^{log_g(h_1)\cdot log_g(h_2)}$<br>若$h_1=g^{x_1},h_2=g^{x_2}$,那么$DH_g(h_1,h_2)=g^{x_1x_2}=h_1^{x_2}=h_2^{x_1}$</p><p>CDH problem: Given $G,q,g,h_1,h_2$，计算  $DH_g(h_1,h_2)$</p><p>其概率定义类似上节。</p><h3 id="Decision-Diffie-Hellman-DDH">Decision Diffie-Hellman(DDH)</h3><p>给定$(G,q,g)$并均匀随机选择$h_1,h_2\in G$区分$DH_g(h_1,h_2)$的结果和随机选择的元素$h’\in G$、</p><p>其类似的定义也是上方的概率定义。</p><hr><h3 id="conclusion">conclusion</h3><p>若能解决DH问题，自然也能解决DDH和CDH问题，DDH是比CDH更强的假设；但也有groups满足CDH更难，DDH是简单的性质。</p><p>在实际问题中，由于素数阶的群生成元更容易找到，且DL Problem的强度是最高的，同时还有其他的性质（这里不讨论），一般而言选择素数阶的群。</p><h2 id="Elliptic-curves-椭圆曲线">Elliptic curves(椭圆曲线)</h2><p>这里要引入域的概念。关于域，一般而言是满足两类运算的代数结构，具体可见OI WIKI。</p><p>在密码学中，为了让DLP更难，需要选择大素数阶的群（子群）。而对于椭圆曲线群的阶，则有以下讨论：</p><p>定义二次剩余(quadratic residue,QR),选择$y\in \mathbb{Z}_p$，其为模p的二次剩余时，满足：$\exists x\in \mathbb{Z}_p,x^2=y\quad mod p$.</p><p>对于大于2的素数p。有一半的$\mathbb{Z}_p$,且每个QR都有两个square roots。</p><p>emmm，剩下的真看不懂了，似乎是构造了一个素数等式，若满足有该素数表达式的点，则有p+1个 point of infinite？而这个等式似乎和构造二次剩余的交点个数有关？</p><p>直接上结论了。</p><div class="admonition info"><p class="admonition-title">Hasse bound</p><p>p为素数，E为$\mathbb{Z}_p$的椭圆曲线，则有：$$p+1-2\sqrt{p}\leq |E(\mathbb{Z}_p)|\leq p+1+2\sqrt{p}$$</p></div><p>选择椭圆曲线是，一般而言是随机选择，其便可以极其接近“均匀”分布在Hasse bound所确定的区间。需要注意的是要排除弱椭圆曲线。</p><p>通过椭圆曲线，还可以定义椭圆曲线上的DLP(ECDLP)，相对应的也可以定义CDH,DDH。</p><h3 id="Application">Application</h3><p>我觉得很重要，说明了一些有关椭圆曲线的攻击、后门，以及新型应用，但不想翻译，直接贴原文了。</p><p>Although curves standardized decades ago are still widely used, there happened a lot in the last decades.<br>Starting with Kocher’99, side-channel attacks and their couter-measures have become extremely sophisticated.<br>Decades of new research yielding faster, simpler and safer ways to do ECC.<br>Suspicion surrounding previous standards: snowden leaks, dual EC-DRBG backdoor, etc., lead to conjectured.weaknesses in the NIST curves.<br>Other specific classes of curves enable secure cryptographic pairings.<br>And thus interesting applications such as practical identity-and attribute-based cryptography.</p><hr><p>基于椭圆曲线的双线性映射，这里略。</p><h2 id="碎碎念">碎碎念</h2><p>笑死，原PPT这里是极短的，老师似乎两节课就结束了，但要理解这些概念对于初学者而言还是不太够。只能看之后自己能不能补上了。</p><p>三刷密码学！</p><p><img src="/images/paimon.png" alt="三刷密码学！"></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Crypto </tag>
            
            <tag> Number theory </tag>
            
            <tag> Public key </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Modern-CryptoⅧ Practical Construction of symmetric key primitives</title>
      <link href="/2023/02/13/modern-cryptoviii-practical-construction-of-symmetric-key-primitives/"/>
      <url>/2023/02/13/modern-cryptoviii-practical-construction-of-symmetric-key-primitives/</url>
      
        <content type="html"><![CDATA[<p>本节所探讨的一系列问题许多都是基于启发式的，也就是无法基于任何较弱的假设证明安全性。但若假设成立，例如大整数因式分解、AES是伪随机排列等，可以通过理论证明和实践证明来表明其安全性。</p><p>另外，本节不进行过多的对加密方案细节的描述。</p><h2 id="Stream-cipher">Stream cipher</h2><h3 id="RC4">RC4</h3><p>虽然在普通的密码学教材中，流密码一般具有代码短、速度快的特点，实际上RC4也满足这个性质；但近年来已经证明RC4有着密码学意义上的缺陷，实际中不应该继续使用。</p><h3 id="Trivium">Trivium</h3><p>（略）</p><h3 id="ChaCha20">ChaCha20</h3><p>ChaCha20作为流密码，可以和Poly1305这种消息认证组合成 AE scheme，并被广泛用于TLS。</p><h2 id="Block-ciphers">Block ciphers</h2><p>典，在之前的章节中已有部分介绍。这里放一些相关数据罢。</p><p>n(分组长度)，k(密钥长度)<br>$DES:n=64\quad bits,k=56\quad bits$<br>$AES:n=128\quad bits,k=128,192,256\quad bits$</p><h3 id="Iteration">Iteration</h3><p>轮函数在DES中用于迭代生成密文。</p><table><thead><tr><th>分组密码</th><th>轮函数迭代次数</th></tr></thead><tbody><tr><td>DES</td><td>16</td></tr><tr><td>AES-128</td><td>10</td></tr><tr><td>AES-192</td><td>12</td></tr><tr><td>AES-256</td><td>14</td></tr></tbody></table><h3 id="Designed-goals">Designed goals</h3><p>分组密码应该表现为伪随机排列，因此有以下性质：</p><ol><li>The number of permutation for n bits is $(2^n)!\approx n2^n$</li><li>Construct set of permutations with concise description(short key)</li><li>Similar to security property of PRP.</li></ol><p>(懒，随便抄了)</p><p>分组密码的安全性是最重要的，而判断其的依据是：其输出无法和随机排列输出区分开。</p><p>另外，分组密码还有一个重要性质：<strong>改变输入的1bit 也能影响所有输出位</strong>。确切而言，1bit的影响不是改变所有位，而是大致上让每一位有一般的概率被改变。</p><p>香农提出了混淆扩散范式（confusion-diffusion paradigm），通过密钥构建排列，再通过轮函数来构建简洁、伪随机的排列。</p><p>于是，有两种手段去构造分组密码：Substitution Permutation Network 和Feistel Network</p><h2 id="Substitution-Permutation-Network">Substitution Permutation Network</h2><p>为了阐明具体细节，现假设block length=n，代换块长度为L，于是便有个n/L代换块。具体如何操作见下：</p><hr><ol><li>key mixing：输入$x=x\oplus k$，其中k是该轮次的子密钥。</li><li>Substitution： $x=S_1(x_1)||…||S_8(x_{n/L})$，使用S-box这种排列置换方式。</li><li>Permutation 排列x的位来获得轮函数的输出。</li></ol><hr><p>每一轮的输出都作为下一轮的输入，最后通过密钥混合来得到最后的输出.<br>S-box和mixing permutation是公开的,因此，若没有key mixing，剩余步骤都是确定性的，无密钥参与，也因此不提供额外的安全性。</p><p>每一轮的子密钥都是通过实际密钥(master key)key schedule来派生的。</p><p>因此，一个r轮SPN有 r轮key mixing等步骤，但最后的密钥混合导致需要(r+1)个子密钥。</p><h3 id="avalanche-effect">avalanche effect</h3><p>改变输入的一位会导致S box中至少两位输出的改变。</p><p>mixing permutation也保证任何一个S box的输出都会作为下一轮多个S box的输入。</p><p>由此的影响被称为“雪崩效应”。</p><h2 id="Feistel-Network">Feistel Network</h2><p>具体细节的就。。不讲了，网上一搜一大堆。讲点别的。</p><p>但还是要有基本形式不是？</p><p>分组block分为左右两块：L,R。</p><p>$$L_i=R_{i-1}$$</p><p>$$R_i=L_{i-1}\oplus f_i(R_{i-1})$$</p><p>在该类构造方式中，处理的子函数$f_i$是公开的，且每一轮的子密钥也是从主密钥中派生而来，且是秘密的。因此，不像Feistel Network的结果是可逆的，$f_i$是不可逆的。</p><div class="admonition info"><p class="admonition-title">Luby-Rackoff'85</p><p>若$f$（输入密钥的函数）是安全的PRF，那么3轮的Feistel F便可为一个安全的PRP。</p></div><h2 id="DES">DES</h2><p>DES采用16轮的Feistel Network构造，但其子函数$f_i(x)=F(k_i,x)$，构造方式是类似 Substitution permutation Network的.</p><h3 id="S-boxes-and-P-boxes">S-boxes and P-boxes</h3><p>DES的构造方式具有S-boxes和P-boxes，S-boxes的输出是“P-box替换”的输入。P-boxes将每一输入位都映射到一个输出位。</p><p>若随机选取S/P-box，会导致分组密码不安全。其应该具有以下性质：</p><ol><li>任何输出位输出分布都不应该接近输入位的线性组合（函数）</li><li>S boxes的每4位输入都应该映射为1位输出位。</li><li>若你查过S-boxes的表格，可以看到其输出是按照2-4位的表格来映射到4位输出的。DES的S-box要求表格中每一行（2位对应的一行或一列）的4 bits output string都应该只出现一次。</li><li>改变S box输入的一位都会改变输出的2位。</li></ol><h3 id="double-DES">double DES</h3><p>DES的56位密钥过短，从而导致可以通过暴力搜索来破解，人们试图通过加长密钥长度、重复使用DES来修复，于是就有了熟知的3 DES。</p><p>double DES:$2E(k_1,E(k_2,m))$采用112 位密钥，看起来应该安全性翻倍。但实际上，其并没有加强多少安全性。</p><h4 id="meet-in-the-middle-attack">meet in the middle attack</h4><ol><li>建表，对第一层的加密可能结果$E(k_i,M)$进行穷举，并通过密钥来排序，时间复杂度$O(2^{56}log(2^{56}))$</li><li>穷举搜索密钥空间$k\in \{0,1\}^{56}$，检索$D(k,C)$是否在表中，检索可用二分。若找到，有：$D(k_i,M)=D(k,C)-&gt;(k_i,k)=(k_2,k_1)$</li></ol><p>总时间复杂度为$O(2^{56}log^{56})+O(2^{56}log^{56})=O(2^{63})&lt;&lt;2^{112}$，远远达不到预期安全性。</p><h3 id="Triple-DES-3-DES">Triple DES(3 DES)</h3><p>构造方式类似 double DES，其也可以通过以上类似方法来攻破，虽然也达不到预期的安全性，但大致需要$O(2^{118})$才能攻破，因此仍然可以使用。</p><p>然而，其3倍于普通DES的时间，以及被日后的机器攻破的可能性，促使AES的诞生。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Crypto </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Modern-CryptoⅦ Cryptographic Hash Functions</title>
      <link href="/2023/02/09/modern-cryptovii-cryptographic-hash-functions/"/>
      <url>/2023/02/09/modern-cryptovii-cryptographic-hash-functions/</url>
      
        <content type="html"><![CDATA[<p>计算机科学上到处都是哈希函数，得益于哈希函数可以作为一种“压缩”的方式，进行诸如哈希表的构建。密码学上的哈希函数则要满足更多的性质。</p><h2 id="Collision-resistance">Collision resistance</h2><p>形式化：<br>对于$H:\{0,1\}^m\rightarrow \{0,1\}^n,m\geq n$对任何的PPT算法，无法找到一个碰撞，或者说对 $x\neq x’,H(x)\neq H(x’)$,那么该函数抗碰撞。</p><p>$m&gt;n$，则哈希函数必定会产生碰撞。只是对PPT敌手而言，只有极小概率能够找到碰撞。<br>可以看到，这里定义的哈希函数是<strong>unkeyed</strong>的，也因此是确定性的。然而，实际运用中，若要攻破这一哈希函数，便需要去找到一对碰撞，而碰撞的寻找是十分困难的。实际上，这里的unkeyed只是指$H(k,x)$中的k为公开常量，而非随机选定的意思。</p><p>在密码学中的证明里，若结果依赖抗碰撞性，形式上我们考虑使用keyed哈希函数，实际上通常使用unkeyed哈希函数，并且同样能够满足抗碰撞。</p><h3 id="Definition">Definition</h3><div class="admonition warning"><p class="admonition-title">Definition: Hash Functions</p><p>A hash Function with output length $l$ is a pair of PPT algorithm (Gen,H) satisfying</p><ol><li>$s\leftarrow Gen(1^n),|s|\geq n$,作为k,并为所有人可知。</li><li>For a key s and $x\in\{0,1\}^*,H(s,x)$output a string in $\{0,1\}^{l(n)}$if the input x  is restricted to $|x|= l'(n),l'(n)\geq l(n)$，Gen，H)is a fixed-length hash Function.</li></ol></div><hr><p>collision-finding experiment</p><ol><li>生成密钥s。</li><li>敌手被给定密钥$s$，输出信息$x$，$x’$保证两者长度相同并符合上述定义。</li><li>若$H(x)=H(x’)$，则返回1，否则返回0.</li></ol><div class="admonition warning"><p class="admonition-title">Definition:collision resistant in orcacle</p><p>(Gen,H) is a collision resistant if for every PPT $\mathcal{A}$$$Pr_{s\leftarrow Gen(1^n)}[\mathcal{A}(s)\rightarrow(x\neq x')\land H(s,x)=H(s,x')]\leq negl(n)$$</p></div><hr><h3 id="weaker-notions-of-security">weaker notions of security</h3><ol><li>第二原象性(Second-preimage or target-collision resistance)：对于给定的s和随机的x，找到$x’\neq x,H(s,x)=H(s,x’)$是极其困难的，</li><li>单向性(Preimage resistance or one-wayness) 给定s和y，y是$H(s,x)$的结果，找到$x’$（不一定非要$x\neq x’$），$H(s,x’)=y$</li></ol><p>这是在更弱意义上的安全性。有了collision-resistance，这两个性质便都有了。若满足这两个小性质，便可以构造出单向函数。</p><h2 id="Domain-extension-for-CRHFs">Domain extension for CRHFs</h2><p>如同先前一般，这里介绍通过操作模式进行扩展。</p><div class="admonition warning"><p class="admonition-title">The Merkle Damgard transform</p><p>Chop input x with length $L=|x|$ into $B=\lceil \frac{L}{n}\rceil$,并在最后一块添加0以填充。$x_{B+1}=L$有以下形式化：$z_0=IV,z_i=h(z_{i-1},x_i)$$h_{B+1}=H(x)$</p></div><p>在这里，由于原消息填充后有被碰撞的可能，例如111||000和1110||00填充后相同，因此最后一块设为L用于防碰撞。<br>这种构造方式是十分普遍的。在实际的哈希构造方案中基本都用到了该构造方式：MD5,SHA-1,SHA-2。</p><div class="admonition info"><p class="admonition-title">MD transform collision resistant</p><p>if $h$ is collision resistant, so is $H$.</p></div><p>对上述性质的证明过程，可以通过反证法，若H不满足该性质，则h也不满足抗碰撞。</p><p>顺带一提，王小云院士的一大工作便是找到杂凑(hash)函数的碰撞，也因她的工作，采用MD transform的MD5,SHA-1被证明是不安全的。实际运用中，最好采用SHA-2,或者不是MD transform形式的SHA-3算法。</p><h2 id="Hash-and-MAC">Hash-and-MAC</h2><p>有了hash函数后，对<strong>任意长度</strong>的明文m进行认证，可以采用“先对m进行hash，再对hash值进行mac计算”。MAC保证了攻击者无法对任何新的哈希值进行认证，而抗碰撞使攻击者无法找到对应的明文。</p><hr><p>构造认证方案：<br>$\prod’=(Gen’,Mac’,Vrfy’)$<br>$Gen’(1^n)\rightarrow &lt;s(Gen_H(1^n)),k(Gen)&gt;$<br>$Mac_{&lt;s,k&gt;}'(m)=Mac_k(H^s(m))$<br>$Vrfy$满足canonical条件。</p><hr><div class="admonition info"><p class="admonition-title">New Construct</p><p>若原$\prod$是安全的MAC，且$H$是抗碰撞的，则$\prod'$对任意长度的明文都是安全的MAC方案。</p></div><p>证明过程需要用到归约性证明，证明若敌手要攻破构造的方案，要么攻破MAC要么找到碰撞。</p><h3 id="using-Hash-functions-as-MACs">using Hash functions as MACs</h3><p>在许多场合中，人们会错误的直接把密码学意义上的hash函数用于认证<s>谁会去学密码学啊</s>,这实际上是十分危险的。</p><p>$Naive$<s>y**ng</s> MAC：$Mac_k(m)=H(k||m)$</p><p>但用hash函数构造MAC是可行的：</p><p>$Nested$ MAC（两密钥），若采用的哈希函数是PRF，则NMAC也是PRF，从而就是MAC。</p><p>顺带一提，NMAC原论文的h哈希函数默认直接带有PRF属性，所以直接使用了；但一般而言，h只是具有抗碰撞性质的哈希函数。<br>然而，现代的哈希函数基本都明确要求具有PRF属性，所以歪打正着，NMAC也能够保证安全性。</p><p>HMAC则是较为著名的一个方案了。它可以用于任意长度的消息，并用任意的哈希函数构造，较NMAC更加实用。</p><p>在HMAC之前，许多人不喜欢用CBC-MAC（太慢）而自己构造MAC，不能不说是一种安全性缺失。HMAC填补了这一漏洞。</p><h2 id="Generic-attacks-on-hash-Functions">Generic attacks on hash Functions</h2><h3 id="Birthday-bound">Birthday bound</h3><p>看上去，对于哈希函数的攻击是十分困难的,最坏情况下要对所有的可能进行蛮力遍历才能得到一对碰撞。然而，<strong>生日悖论</strong>使攻击可能大大增强：</p><div class="admonition info"><p class="admonition-title">Birthday bound</p><p>若有q个独立均匀随机选取的元素从集合S中选取，$|S|=N$，则有：$$\frac{q(q-1)}{4N}\leq Pr[\exists i\neq j,y_i=y_j]\leq\frac{q^2}{2N}$$对于不均匀的选取，第一个不等式成立。</p></div><p>因此，要保证对于q(n)问询的敌手，$q(n)^2/2^\ell&lt;&lt;1$，即$\ell&gt;2log(q(n))$</p><h3 id="meaningful-collisions">meaningful collisions</h3><p>由于有意义的句子里有许多固定格式，理论上而言，可以通过调整较少数量的词来达到缩小搜索空间，从而使攻击更加容易成立。</p><h3 id="Small-space-birthday-attacks">Small space birthday attacks</h3><p>相比普通生日攻击，该方法通过两倍的查询来换取存储空间的$O(1)$复杂度。</p><h2 id="Applications">Applications</h2><h3 id="random-oracle-model-随机预言机">random oracle model(随机预言机)</h3><p>有几种基于密码学上的哈希函数的构造方案，单凭哈希函数的抗碰撞、单向性是无法完成安全的。<br>对此，如果想要重新寻找基于底层哈希函数的可证明安全方案，那么找到这类方案前便无法使用；而如果使用现有的密码系统，除了设计者试图攻击未果这一事实外没有任何理由证明其安全性，这是不可接受的。</p><p>于是，便有一种看起来“取巧”的方案，在严格的可证明安全和没有任何证明中的一种方法：引入一个理想化的模型来证明密码的安全性，而这就是<strong>随机预言机</strong>。</p><p><s>有证明总比没有好对吧</s></p><p>随机预言机的定义：假设一个随机函数$H:\{0,1\}^*\rightarrow\{0,1\}^n$，其只能够被任何人<strong>查询</strong>计算，即输入$x$返回$H(x)$。</p><p>用另一种更加玄乎的话来说，在你给定输入前，随机预言机看起来像是完全均匀随机的函数(黑盒啊嗯)，原文甚至将随机预言机比作“in the sky”,但你朝天空喊一句$x$，它就会给你确定的回应$H(x)$,并且$H(x)$确定下来，无论你后面怎么输入给定的$x$，$H(x)$都是唯一的回应。</p><p><s>什么b比喻</s></p><p>在构造方案时，证明使用<strong>RO</strong>(随机预言机),而实际构建方案时，RO用密码学意义上的哈希函数实例化。</p><p>可以看到，这是一种启发式的证明，但在实际出乎意料的好用。</p><p>另外，随机预言机满足“可编程性”，在归约性证明中可以选定均匀的输出值。</p><h4 id="pseudorandom-generator">pseudorandom generator</h4><p>设随机预言机$H=\{0,1\}^{n/2}\rightarrow \{0,1\}^n$<br>则有$Pr_{y\leftarrow \{0,1\}^n}[\mathcal{A}^{H(\cdot)}(y)=1]-Pr_{x\leftarrow \{0,1\}^{n/2} }[\mathcal{A}^{H(\cdot) }(H(x))=1]=negl(n)$</p><p>则H便是PRG。</p><h4 id="pseudorandom-Function">pseudorandom Function</h4><p>$H=\{0,1\}^{2n}\rightarrow\{0,1\}^n$<br>$F_k(x)=H(k||x)$</p><p>则F便是PRF。</p><h4 id="Collision-resistant-Hash-Function">Collision resistant Hash Function</h4><p>$H=\{0,1\}^*\rightarrow\{0,1\}^n$</p><p>其本身便可作为抗碰撞的哈希函数实例化。</p><p>以上所有的构造都用到了H(x)是uniform的性质，但没有可编程性。</p><div class="admonition missing"><p class="admonition-title">RO</p><p>需要注意的是，RO的使用直至现在都存在着争议，有人认为它并不能代表完全的安全，也有人认为我们并没有完全了解RO的性质，可能会有隐藏的问题。</p></div><h3 id="Fingerprinting-and-deduplication">Fingerprinting and deduplication</h3><p>哈希函数可用于病毒检测，另外，也可以用于云存储等。</p><h4 id="Merkle-tree">Merkle tree</h4><p>上文提到哈希可以用于云存储。用户只要保存了哈希值，便可以通过哈希值来查询得到对应的云文件，从而对文件进行下载验证等操作。若要高效进行，可以采用Merkle tree这种数据结构。</p><p>其构造方法通俗而言，Merkle tree除了叶子节点的tag是对文件的哈希值，其余节点的tag都是对子节点的哈希值。</p><div class="admonition info"><p class="admonition-title">Merkle tree</p><p>若其底层的哈希函数是抗碰撞的，那么具有固定文件数量的Merkle Tree也是抗碰撞的。</p></div><p>客户端存储根节点的哈希值，而服务器维护Merkle Tree以及文件。若客户端需要对应的文件，服务器可以将文件和其Merkle Tree路径外的其他子节点上的所有哈希值(空间复杂度$O(log(n))$发向客户端，以让客户端验证文件完整性。</p><h3 id="MAC-and-Hash-for-message-authentication">MAC and Hash for message authentication</h3><p>MAC和Hash都可以用于认证，区别为：</p><p>MAC要求通信双方在通信前共享密钥，而哈希函数虽然不用密钥的存储，但要求能够安全存储哈希值。</p><h3 id="basic-password-protocol">basic password protocol</h3><p><s>谁的密码明文存储啊？</s></p><p><s>哦，CSDN啊，没事了</s></p><p>感觉现实中对密码进行哈希操作已经是稀松平常了。具有抗碰撞性的哈希就是好用。</p><p>然而，由于许多人采用弱密码，可以用在线字典攻击(攻击者对用户清单统一尝试较少密码)，也可以离线字典攻击(暴力查找H(w)=storaged password).<br>而batch离线字典攻击则假设敌手获取一整个存储密码的文件$F$，用事先准备的字典集合$Dict$对其进行离线字典攻击，这种方式更容易攻破其密码,时间复杂度为$|Dict|+|F|$</p><p>于是就有了public salt，也就是我们说的<strong>加盐</strong>，即使在密码文件中公开存储盐值，也可以保证其时间复杂度大幅上升，攻击者必须遍历密码文件才能完成一次攻击尝试，于是时间复杂度为$O(|Dict|\times|F|)$</p><hr><p>回到对于密码的哈希：如果哈希函数，例如SHA1执行过快，也就是单步执行过快，计算机也能在可接受的时间内完成计算。</p><p>于是就有“慢”哈希函数，或者多次应用哈希函数来减慢速度；或者如之前已经叙述过的“加盐”，抑或是服务器辅助的方法（密码学老师似乎就是搞这方向的，还搞了两篇自己的论文放在PPT，乐）。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Crypto </tag>
            
            <tag> hash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Modern-CryptoⅥ CCA-Security＆Authenticated Encryption</title>
      <link href="/2023/02/05/modern-cryptovi-cca-security-authenticated-encryption/"/>
      <url>/2023/02/05/modern-cryptovi-cca-security-authenticated-encryption/</url>
      
        <content type="html"><![CDATA[<h2 id="Chosen-ciphertext-attacks-CCA">Chosen ciphertext attacks(CCA)</h2><p>本章之前所讨论的都是CPA、EAV等敌手。而CCA相比CPA而言，不仅能够访问$Enc_korcale$,也可以访问$Dec_korcale$.</p><h3 id="Padding-orcale-attacks">Padding-orcale attacks</h3><p>比如，CBC模式下，明文长度必为分组长度的倍数。因此，便需要扩充。假设分组长度16bytes。<br>$b=16-(|m|mod 16)$<br>则在明文后填充b个值：b。比如HelloWorld666666.若b=0，填充16个0.</p><p>$Dec_k(\cdot)$的访问导致了可以通过对CBC模式的密文替换学习到b的值是什么，从而得出更多的信息。</p><h3 id="CCA-Definition">CCA Definition</h3><p>还是采取预言机定义。事前敌手和预言机给定安全参数$n\in N$</p><ol><li>预言机生成密钥$k\leftarrow Gen(1^n)$和随机选取的$b\leftarrow\{0,1\}$</li><li>敌手既可以发送明文$m\in\{0,1\}’$，预言机返回$Enc_k( m)$；也可以发送密文$c\in\{0,1\}’$,预言机返回$Dec_k( c)$.可不断进行。</li><li>最后，发送明文$m_0,m_1\in \{0,1\}’,|m_0|=|m_1|$，预言机返回$c’=Enc_k(m_b)$，其不可以被解密预言机解密。</li></ol><p>其具体的CCA下不可区分性，或者说CCA-Secure的概率性定义和之前一样。</p><div class="admonition info"><p class="admonition-title">Is CCA-secure unnecessarily strong?</p><p>Since we don’t know what information an attacker might be able to learn when a ciphertext it sends is decrypted by a receiver, in reality we make the worst-case assumption that the attacker learns everything, where the adversary is stronger than whom in padding-oracle attack.</p></div><h2 id="CCA-schemes">CCA schemes</h2><p>到如今，我们没有构造出任何一个CCA secure的加密方案。</p><p>据个例子。最简单的一个scheme：$Enc_k(m)=&lt;r,F_k( r)\oplus m&gt;$<br>那么，在上面的CCA定义中最后一条中，敌手会收到预言机的回应：$&lt;r,s=F_k( r)\oplus m_b&gt;$，则他可以随机选取一个x，访问Dec预言机：$s\oplus x\oplus F_k( r)=Dec_k(&lt;r,s\oplus x&gt;)$<br>从而学习到$m_b\oplus x$.</p><p>CCA Security 需要不可延展性:$ non-malleability$.这种性质导致，若敌手对给定的密文进行任何修饰。它解密出来的明文不应该和原明文有任何联系。</p><h3 id="unforgeable-encryption">unforgeable encryption</h3><p>首先先试图把Secrecy和authenticated合起来。</p><hr><p>预言机定义unforgeable：<br>（简略写了）</p><p>事先给定安全参数n。</p><ol><li>预言机生成k。</li><li>敌手发送$m\in\{0,1\}^*$,预言机维护$G\cup=m$,返回$Enc_k(m)$</li><li>不断进行第二步，最后敌手发送$c\in \{0,1\}^*$,预言机解密$m’=Dec_k( c)$，若$(m’\neq \bot)\land(m’\notin G)$返回1，否则返回0.</li></ol><p>其中的垂直符号表示invalid。</p><hr><p>需要注意的是，关于unforgeability for encryption，从弱到强共三阶：</p><ol><li>Random Plaintext Unforgeability</li><li>Chosen Plaintext Unforgeability.</li><li>Existential Unforgeability.</li></ol><p>这里采用最强的第三种。</p><div class="admonition warning"><p class="admonition-title">Definition</p><p>该方案若满足以下性质，对任何的PPT敌手$\mathcal{A}$，都是unforgeable的：$$Pr[Enc-Forge_{\mathcal{A},\prod}(n)=1]\leq negl(n)$$</p></div><div class="admonition warning"><p class="admonition-title">Definition AE(1)</p><p>A private-key encryption schemes is an Authenticated Encryption scheme if it is CCA-secure and unforgeable.</p></div><h2 id="Authenticated-Encryption-AE-Definition">Authenticated Encryption(AE) Definition</h2><p>预言机定义AE：</p><p>事先给定n。</p><ol><li>预言机生成k，b。</li><li>敌手可访问两种预言机：<br>(1) 如果b=0，访问$Enc_k(m),Dec_k(m)$.<br>(2) 如果b=1,访问$Enc_k^0(m)=Enc_k(0^{|m|})$和$Dec_\bot( c)$,Dec永远返回error标志。</li><li>敌手猜测b’，若b=b’，返回1，否则返回0.</li></ol><div class="admonition warning"><p class="admonition-title">Definition AE(2)</p><p>A private-key encryption scheme is an authenticated encryption (AE) scheme if for all PPT adversaries $\mathcal{A}$ there is a negligible function negl such that:$$Pr[Priv_{\mathcal{A},\prod}^{ae}=1]\leq \frac{1}{2}+negl(n)$$</p></div><p>以上两个AE定义等价。</p><p>另外，若AE schemes能够接受额外的数据，被称为authenticated encryption with associated data (AEAD).</p><h3 id="CCA-and-AE">CCA and AE</h3><p>需要注意的是，<strong>任何AE scheme都满足CCA-secure，反过来则不满足。</strong></p><p>密钥交换协议就无需AE但需要CCA。</p><p>AE需要满足Secrecy和integrity，但CCA-security只需要满足在CCA敌手下的安全性。</p><h2 id="AE-schemes">AE schemes</h2><p>由上讨论，我们想要构建一个兼具secrecy和integrity的方案。但两者的结合方式会造成不一样的结果。即使每个原语都是安全的，结合起来也可以是不安全的。</p><p>另外，安全性依靠其底部构建的细节是危险的。我们一般而言讨论安全性的时候，都是着重于通常的安全性。</p><h3 id="Generic-Constructions">Generic Constructions</h3><h4 id="Encrypt-and-authenticate">Encrypt-and-authenticate</h4><p>选定两个独立的密钥，分别生成$Enc_{k_E}(m)$和$Mac_{k_M}(m)$<br>这种方式不能保证任何的secrecy，因为tag便可以暴露m。无法保证CPA security，若MAC是确定性的，比如CBC-MAC，则相同的m便会生成相同的tag。</p><h4 id="Authenticate-then-Encrypt">Authenticate-then-Encrypt</h4><p>选定两个独立的密钥，序列生成：<br>$t\leftarrow Mac_{k_M}(m),c’=Enc_{k_E}(m,t)$</p><p>回想一下先前的padding attack，假设Enc是CBC-mode，则先验证再加密存在着两个错误来源：填充不正确，或tag无法Vrfy。</p><p>因此构造出$Dec’_{k_E,k_M}( c)$：</p><ol><li>计算$m’=Dec_{k_E}$,若padding error发生，则返回“bad padding”。</li><li>将m’解析为$m||t$，若$Vrfy_{k_M}(m,t)=1$，返回m，否则返回“authentication failure”</li></ol><p>若敌手可以区分两种错误信息返回，则便可以通过Padding attack中的方式获取整个明文。</p><p>实际运用中，SSL试图修复这一点，它只返回一种错误消息，但要保证无法区分不同的错误还是十分困难的。因此，微小的时间差别使该版本的SSL被成功攻破。</p><h4 id="Encrypt-then-Authenticate">Encrypt-then-Authenticate</h4><p>选定两个独立的密钥，序列生成：</p><p>$c\leftarrow Enc_{k_E}(m),t\leftarrow Mac_{k_M}( c)$</p><p>若MAC是strong MAC，那么该AE满足strongly unforgeable。</p><p>若采用的模块分别能满足strong MAC和CPA-secure，那么该加密方案满足AE。<br>（证明思路，大约是证明Dec是无用的。）</p><h3 id="Independent-keys">Independent keys</h3><div class="admonition warning"><p class="admonition-title">密钥的独立性</p><p>所有的密码学原语都应该采用独立的密钥！</p></div><p>假设：$Enc_k(m)=F_k(m||r)$，F是strong PRP，则该加密方案满足CPA-secure。</p><p>$Mac_k( c)=F_k^{-1}( c)$这也能满足strong secure。</p><p>但，若用Enc-then-Authen，则有：</p><p>$Enc_k(m),Mac_k(Enc_k(m))=F_k(m||r),F_k^{-1}(F_k(m||r))=F_k(m||r),m||r$<br>这不就暴露力？</p><h3 id="standard-schemes">standard schemes</h3><ol><li>GCM<br>the encrypt-then-authenticate paradigm with CTR mode and GMAC</li><li>CCM<br>the authenticate-then-encrypt approach with CTR mode and CBC-MAC</li><li>ChaCha20-Poly1305<br>the encrypt-then-authenticate approach with ChaCha20 and Poly1305</li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Crypto </tag>
            
            <tag> CCA </tag>
            
            <tag> AE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Modern-CryptoⅤ Secret-Key Authentication:Message Authentication Codes</title>
      <link href="/2023/02/02/modern-cryptov-secret-key-authentication-message-authentication-codes/"/>
      <url>/2023/02/02/modern-cryptov-secret-key-authentication-message-authentication-codes/</url>
      
        <content type="html"><![CDATA[<h2 id="消息认证">消息认证</h2><p>至今为止，我们所讨论的安全都是secrecy，即保证EAV、CPA下不泄露任何除明文长度外的明文信息。本章要讨论的便是另一方面的安全：消息认证。即：保证消息的完整性，或保证消息来源身份的可靠性。</p><p>之前在群里和群友讨论过这类话题，群友似乎认为MAC（消息认证码）能够加密信息）所以说加密和认证是十分容易搞混的。</p><div class="admonition warning"><p class="admonition-title">Encryption and Message Authentication</p><p>Secrecy保证秘密性，和authenticity认证性是两个<strong>完全不同</strong>的性质。Encryption不能保证任何的authenticity，而message authentication也不能保证任何的secrecy。</p></div><p>举个例子，即使你加密了信息传给另一方，敌手截获了你的信息，改了下你的密文转发给目标，解密出来的可能是完全不同的东西。如果你对OFB，CTR这类模式加密的密文进行异或某些位的操作，可以直接改变明文特定位的信息。</p><h2 id="Message-Authentication-Codes-MAC">Message Authentication Codes(MAC)</h2><p>这个MAC和设备的物理地址（Media Access Control Address）不是一个东西）</p><h3 id="Definition">Definition</h3><div class="admonition warning"><p class="admonition-title">Definition</p><p>MAC is a tuple($Gen,Mac,Vrfy$) of PPT algorithm:</p><ol><li>$Gen(1^n)\rightarrow k,|k|\geq n$,典型的k保证uniform。</li><li>$Mac_k( m)\rightarrow t$,计算认证标签tag。</li><li>$Vrfy_k(m,t)\rightarrow b$ b=1表示有效，否则认证失败。</li></ol><hr><p>$Gen$ and possibly $Mac$ are <strong>probabilistic</strong>，and if $|m|$ is restricted to $l(n)$:fixed-length MAC</p></div><p>Correctness:<br>虽然Gen和Mac有概率性，但有：<br>$$Pr[Vrfy_k(m,Mac_k( m))=1|k\leftarrow Gen(1^n)]=1$$</p><p>Canonical verification：一般而言，Mac是确定性的，则Vrfy可被顺理成章的定义为：<br>$$Vrfy_k(m,t)=1&lt;=&gt; Mac_k(m)=t$$</p><h3 id="Security-of-MACs">Security of MACs</h3><p>假设情景：两方互相通信（使用明文M和标签T），敌手在通信信道中截取信息，他的目标是伪造出一组$M’,T’$，使得$Vrfy_k ( M’,T’)=1$</p><p>搬出预言机来形式化定义罢！</p><hr><p>Message authentication experiment $Mac-forge_{\mathcal{a},\prod(n)}$</p><p>事前，敌手和预言机都已知安全参数n，k也由预言机的Gen生成。</p><ol><li>敌手向预言机发送信息$m\in \{0,1\}'$.</li><li>预言机维护一个集合$\mathcal{Q}=Q\cup m$,并返回$Mac_k( m)$.</li><li>不断重复1.2.（PPT敌手嘛）,最后，敌手发送$(m’,t’),\mathcal{A}$wins if $Vrfy(m’,t’)=1,m’ \notin \mathcal{Q}$</li></ol><hr><div class="admonition warning"><p class="admonition-title">Definition</p><p>A MAC $\prod=(Gen,Mac,Vrfy)$ is existentically unforgeable under an adaptive Chosen-message attack if for all PPT adversaries $\mathcal{A}$:$$Pr[\mathcal{A}~win]=Pr[Mac-forge_{\mathcal{A},\prod}(n)=1]\leq negl(n)$$</p></div><p>existentically unforgeable(存在不可伪造性)：A wins if he manages to find any message。<br>Chosen-message：允许 A选择任何的消息进行相关信息学习。</p><p>以上定义算是较强的一个MAC定义了，但其仍然无法阻挡重放攻击：敌手若选取了$m \in \mathcal{Q}$进行攻击，则直接获胜,因为这里的MAC是无状态的。<br>除此之外，还无法阻挡调整次序，甚至删除message一部分。这些则可以通过序列号，以及time-stamps等调整解决。</p><h2 id="Strong-MACs">Strong MACs</h2><p>上述预言机中，$Mac$并不一定是确定性算法，因此一个 $m$ 可以对应多个 $t$ ,这让敌手有了另一种攻击方式：伪造出不同于$Mac_k(m)$的tag $t’$，满足$Vrfy_k(m,t’)=1$.因此，加上前面所提到的canonical Mac性质，便可以定义出Strong MAC。</p><h3 id="verification-queries">verification queries</h3><p>理论上而言可以定义更强性质的MAC，可以让敌手除了访问上述的预言机外，还可以让敌手适应性地访问$Vrfy$预言机：发送$(m’,t)$,预言机返回$Vrfy_k(m’,t)$。<br>但实际上，若采用canonical MAC，这并不能使定义更强。我们在接下来的部分也只讨论canonical Mac。</p><h2 id="A-potential-timing-attack">A potential timing attack</h2><p>换个思路：<br>若攻击者能够在上述的方案中获得除了最后发送的消息是否Vrfy成功外，还能得到<strong>时间信息</strong>：这里的时间信息是指Vrfy这个决策过程中所花费的时间。<br>比方说，Canonical Mac（之后直接用Mac代指了）的Vrfy过程是逐位比较tag是否相同，若遇到不同位直接提前返回结果。那么，这和Vrfy过程成功，比较完所有位的时间花费相比，必定短了一些。</p><p>于是：比如，对于一个16-byte长度的tag，敌手对于第一个byte的判断，向预言机发送$(m,t_0),(m,t_1),…(m,t_{255})$，遍历所有可能性，后面全部置0.这样便可以通过时间比较来检测$t_j$含有正确的一块，这样不断循环下一步，便可以通过$256\times 16$来寻找到该tag的正确信息。</p><p>实际上，这种攻击方式已经获得成功过。</p><h2 id="Constructions：MAC">Constructions：MAC</h2><h3 id="Fixed-length-MAC">Fixed-length MAC</h3><p>可以用PRF来构造出一个MAC方案：</p><div class="admonition info"><p class="admonition-title">PRF-&gt;MAC</p><p>Every PRF $F:\{0,1\}^{l_{key}^n}\times \{0,1\}^{l_{in}^n}\rightarrow \{0,1\}^{l_{out}^n}$ 可以用来构造一个消息空间为$\{0,1\}^{l_{in}^n}$的MAC（$\{0,1\}^{l_{out}^n}\in \omega(log(n))$）</p></div><p>Constructions:</p><p>$Gen(1^n)\rightarrow k$：like PRF F：generate k.<br>$Mac_k( m)=F_k( m),|m|=\{0,1\}^{l_{in}^n}$<br>$Vrfy_k(m,t)&lt;=&gt;Mac_k( m)=t$</p><p>证明安全性可以用PRF的安全性+反证法。</p><h3 id="Arbitrary-length-MAC">Arbitrary length MAC</h3><p>很容易往<strong>复用fix-length MAC</strong><br>方向去构造任意长度的MAC，但这里仍然会出现问题：</p><p>假设$Mac_k( m)=&lt;t_1,…t_d&gt;,t_i=Mac’_k(m_i)$</p><ol><li>重排次序：比如$&lt;t_1,t_2&gt;,&lt;m_1,m_2&gt;$，调换1，2位置照样通过$Vrfy$。<br>方法：加上序列号，$t_i=Mac’_i(i,m_i)$</li><li>截断，截取一部分t，m进行vrfy。<br>方法：$t_i=Mac’_i(l,i,m_i),l=|m|$</li><li>混合调换。假设两条相同长度的消息，可以将其各取一部分进行混合，可以通过Vrfy<br>方法：加上一个message identifier $r$，一般而言是随机数：$t_i=Mac’_k(r,l,i,m_i)$.</li></ol><p>基本满足需要了。具体构造略（</p><h3 id="CBC-MAC">CBC-MAC</h3><p>回忆一下上一章CBC模式：</p><p>$c_0=IV$,<br>$c_i=F_k(m_i\oplus c_{i-1})$</p><p>CBC-MAC省去选取IV并异或的一步，并且只生成tag t。<br>形式化而言：</p><hr><p>$t_1=F_k(m_1)$<br>$t_i=F_k(m_i\oplus t_{i-1})$<br>$t_{output}=t_{last}$</p><hr><div class="admonition info"><p class="admonition-title">CBC-MAC</p><p>for any polynomial $l$,if F is a PRF,then the CBC-MAC for message of length $l(n)\cdot n$ is secure.</p></div><p>若不是选定的长度，CBC-MAC是不安全的。所以，发送者和接收者都需要事先约定好发送消息的长度。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Crypto </tag>
            
            <tag> MAC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Modern-CryptoⅣ Private key Encryption</title>
      <link href="/2023/01/31/modern-cryptoiv-private-key-encryption/"/>
      <url>/2023/01/31/modern-cryptoiv-private-key-encryption/</url>
      
        <content type="html"><![CDATA[<h2 id="对上节的补充说明">对上节的补充说明</h2><p>上接 <a href="https://zzzremake.github.io/2023/01/03/modern-cryptoiii-computational-security/#Stronger-security-notions-CPA-Security">Ⅲ</a>。</p><p>我们目前已经拥有的加密方案，只有one-time pad以及其Ⅲ里头的改进型。改进型的加密方案是在单消息意义下的EAV不可区分性。<br>在多消息的情况下，由于one-time pad本质是<strong>确定性</strong>的，所以不能保证安全性。由此可以导出：</p><p>!!!<br>若一个加密方案中Enc为确定性的，则在EAV下无法保证多消息加密的不可区分性。</p><p>因此，需要概率意义上的Enc，也因此可以导出CPA-Security。</p><p>另外，多消息加密的、固定明文长度的加密方案，理论上进行重复便可以加密任意长的消息，但在这章的后续部分中，将介绍更为有效率的加密任意长度的消息方式。</p><hr><p>在开始本节构造CPA加密方案前，有必要对伪随机性进行深入讨论。</p><h2 id="Pseudorandom-functions">Pseudorandom functions</h2><p>注意与PRG（Pseudorandom generator）区分。<br>PRG是将作为种子的随机序列进行扩展长度，使其无法与相同长度的uniformly随机序列区分；PRF则是一类以密钥key作为输入的多项式可计算函数，其无法与随机函数进行区分。</p><div class="admonition warning"><p class="admonition-title">Definition:PRF</p><p>$$F:\{0,1\}^{l_{key}} \times \{0,1\}^{l_{in}} \rightarrow \{0,1\}^{l_{out}}$$</p><ol><li>Efficient:$$l_{key}(n)=l_{in}(n)=l_{out}(n)^a$$实际上的PRF可以不等长，但在接下来的讨论中，可以</li><li>Secure: $F(k,\cdot)$with a random key $\mathcal{k} \in \{0,1\}^{n}$ 和随机函数$\{0,1\}^{n}\rightarrow\{0,1\}^{n} $无法区分。</li></ol></div><p>实际上的PRF可以不等长，但在接下来的讨论中，可以认为上面的$l_?(n)=n$.</p><p>我们知道，函数本质是一种一一映射，因此可以将所有可能的函数看作一个函数集合$Func_n$,则有：$|Func_n|=2^{2^n\cdot n}$。<br>描述随即均匀选取的$f\in Func_n$则需要$2^n\cdot n$bits 的空间去建立映射。于是在多项式的算法下无法有效的读取f的所有可能的取值，也因此无法使用多项式算法直接定义与随机函数的不可区分性。<br>于是，可以通过试图区分 $f$ 和随机函数的区分者$\mathcal{D}$访问<strong>预言机</strong>来形式化PRF的安全定义。</p><h3 id="PRF-Definition-oracle">PRF Definition(oracle)</h3><p>Definition：</p><ol><li>敌手（$\mathcal{D}$）向oracle发送<strong>单个</strong>信息x。</li><li>预言机行为与之前相似，随机生成密钥k和b。<strong>不一样的</strong>：如果$b=0$，则用$F_k(x)$返回，否则则用$f\leftarrow Func_n $生成$f(x)$返回。f为均匀随机选择的函数。</li><li>敌手返回b’，oracle行为与之前的预言机行为相同。</li></ol><p>于是，上方的Definition中secure可以改为：</p><div class="admonition warning"><p class="admonition-title">Definition:PRF(2)</p><p>Secure：for every PPT $\mathcal{D}$:$$|Pr[b'=1|b=0]-Pr[b'=1|b=1]|= \\|Pr_{k\leftarrow \{0,1\}^{n}}[D^{F(k,\cdot)}=1]-Pr_{f\leftarrow Func_n}[D^{f(\cdot)}]|\leq negl(n)$$</p></div><h2 id="Pseudorandom-permutations（PRP）">Pseudorandom permutations（PRP）</h2><p>现定义$Perm_n\subset Func_n$,表示所有在$\{0,1\}^n$上的排列集合。于是：<br>$$|Perm_n|=2^n!$$<br>我们可以用几乎和PRFs相同的定义方式定义伪随机性排列PRPs：</p><div class="admonition warning"><p class="admonition-title">Definition:Pseudorandom permutations</p><p>$$F:\{0,1\}^{l_{key}} \times \{0,1\}^{l_{in}} \rightarrow \{0,1\}^{l_{out}}$$是PRP，则有：</p><ol><li>Efficient: 同PRF</li><li>$F_k(\cdot)$是排列。</li><li>Secure：for every PPT $\mathcal{D}$:$$|Pr_{k\leftarrow \{0,1\}^{l_{key}(n)}}[D^{F(k,\cdot)}=1]-Pr_{f\leftarrow Perm_{l_{in}(n)}}[D^{f(\cdot)}]|\leq negl(n)$$</li></ol></div><p>需要指出的是，由于是PRP，要求多项式时间内计算函数与逆函数，所以要求$l_{in}(n)=l_{key}(n)$.</p><div class="admonition info"><p class="admonition-title">PRP and PRF</p><p>如果F是PRP且$l_{in}(n)\geq n$,那么F同样也是PRF。</p></div><p>上述情况在渐进意义上成立，但具体安全性仍然可能受到影响。</p><h3 id="Strong-PRPs">Strong PRPs</h3><p>PRP在实际使用中，逆函数同样也被honest parties 所需。因此，需要考虑更高的安全性。</p><div class="admonition warning"><p class="admonition-title">Definition Strong PRP</p><p>F为有效的、具有key输入的、长度固定的（n的多项式）排列。若为Strong PRPs，则有：$$Pr[\mathcal{D}^{F(k,\cdot),F^{-1}(k,\cdot)}=1]-Pr[\mathcal{D}^{f(\cdot),f^{-1}(\cdot)}=1]\leq negl(n)$$</p></div><div class="admonition missing"><p class="admonition-title">block-ciphers(分组密码)</p><p>实际上，像DES,AES这类我们熟悉的<strong>分组密码</strong>，其最初始的目的就是作为strong PRPs进行使用。其区别仅仅在于分组以及密钥的长度固定（而非渐进意义上），以及认为暴力破解才是最佳的破解方式。因此，<strong>分组密码不是加密方案</strong>。</p></div><h3 id="CPA-Secure">CPA-Secure</h3><p>通过PRFs/PRPs，我们现在可以很好的定义CPA-secure的加密方案。</p><p>$F:\{0,1\}^n\times \{0,1\}^n\rightarrow \{0,1\}^n$<br>$Enc(k,m\in \{0,1\}^n )$ 选取$r\leftarrow\{0,1\}^n$<br>$$c\leftarrow &lt;r,m\oplus F_k( r)&gt;$$<br>$Dec(c=&lt;r,s&gt;):m\leftarrow F_k( r)\oplus s$</p><div class="admonition info"><p class="admonition-title">info</p><p>如果F是PRF,上述构造为 CPA-secure 的固定明文长度的私钥加密方案。</p></div><h2 id="Modes-of-Operation-操作模式">Modes of Operation(操作模式)</h2><p>在实际应用中，PRGs更多用于初始化流密码，而PRPs则用于分组密码。实际上，分组密码的另一个名字就是PRP。</p><h3 id="Stream-ciphers-流密码">Stream ciphers(流密码)</h3><h4 id="basic-definition">basic definition</h4><p>在此之前，我们定义的加密方案都对明文有明确的长度限制，不够有扩展性。流密码则提供了更高的延展性。</p><p>流密码在形式上，提供了以下确定性的算法作为基本部件：</p><ol><li>$Init$: 输入种子$s$和选定的初始向量$IV$,输出初始状态$st$.</li><li>$Next$：以状态作为输入，输出a bit $y$ 并且更新状态 $st’$.</li></ol><p>则可以定义带有密钥输入的函数：<br>$$F_s^l(IV)=GetBits_1(Init(s,IV),1^l)$$<br>若$F^l$为为随机函数，则该流密码是安全的。</p><h4 id="流密码の操作模式">流密码の操作模式</h4><p>略。分同步和异步两种方式。</p><h3 id="Block-cipher-modes-of-operation">Block-cipher modes of operation</h3><p>具体的操作模式形式就不在本节介绍了，一搜都有。</p><p>操作模式可以看作一种构造，这种构造将一个密码学上的模块（或者，原语？）（PRF,PRP/分组密码抑或是日后要介绍的hash function）转变为一种useful的密码学方案（加密方案，或是日后介绍的认证方案）。</p><h4 id="ECB">ECB</h4><p>最最基本的模式，但这种模式<strong>绝对</strong>不能继续使用了。ECB的模式是确定性的，因此并不是CPA-secure的。</p><p><s>老师甚至在课堂讲如果有人毕设在安全部份用ECB被他逮到直接毙了</s></p><h4 id="CBC">CBC</h4><p>若CBC用到的带有密钥输入的函数F为PRP，则CBC是CPA-Secure的。</p><p>CBC的主体部分是作为一个链条进行的，所以只能序列性的进行加密，无法有效的并行化处理从而加速加密过程。</p><h5 id="Chain-CBC-mode">Chain CBC mode</h5><p>这种模式在SSL 3.0和TLS 1.0中使用，将其上一次加密的最后一个分组返回的密文块作为下一条明文加密的$IV$。看上去，这种方式能够加密更多的消息而不用重新生成新的$IV$.然而，这种方式不是CPA secure的。</p><p>感觉介绍这个案例的更多原因是警醒别人不要随意改动原来已被证明安全的方案。即使只是很小的改动也无法保证能保持安全性。</p><h4 id="OFB">OFB</h4><p>相比于CBC：</p><ol><li>OFB的$F_k$不需要逆函数来作为Dec解密，因此$F_k$可以是PRF，而不是CBC因需要逆函数而选择的PRP。</li><li>OFB若采取上节的Chain CBC的形式选取$IV$，能够保证安全性。</li><li>虽然计算上。OFB仍然需要序列化的计算，但可以在加密前把序列化的部分完成，而加密便可以使用并行化进行加速。</li><li>明文长度无需是n的倍数。</li></ol><h4 id="CTR">CTR</h4><p>CTR对明文长度具有限制。这里详细介绍CTR。</p><p>$Enc_k(m_1,…,m_l)$,其中$m_i$表示明文块:</p><ol><li>random $IV\leftarrow\{0,1\}^{3n/4}$</li><li>$y_i=F_k(IV||i)$</li><li>$c_i=y_i\oplus m_i$</li><li>$c=&lt;IV,c_1,…c_l&gt;$</li></ol><p>$Dec©:m_i=c_i\oplus F_k(IV||i)$</p><p>可以看到，其限制了$l&lt;2^{n/4}$，初始向量长度也有变化，这里是因为CTR采用计数器模式，而计数器能够计数的部分只有3n/4bits空出来的n/4。</p><p>CTR的加密过程是完全的并行化的，并且可以直接查看密文的某一块解密结果，而无需解密整条信息。</p><h4 id="Concrete-Security">Concrete Security</h4><p>CTR,CBC,OFB基本上能够保证$q(n)$ 次查询下的$q(n)^2/2^n$优势，在具体安全中需要使用较大的blocks size，因此n要大。<br>CTR限制了长度，因此在n=64，比如采用DES时能够加密34GB的明文，换用n=128比如AES就基本差不多能满足各种需要了。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Crypto </tag>
            
            <tag> 操作模式 </tag>
            
            <tag> 随机数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Modern-CryptoⅢ  Computational Security</title>
      <link href="/2023/01/03/modern-cryptoiii-computational-security/"/>
      <url>/2023/01/03/modern-cryptoiii-computational-security/</url>
      
        <content type="html"><![CDATA[<h2 id="Computational-Security">Computational Security</h2><p>Perfect Security在拥有无限算力的eav窃听者情况下是可证明安全的，不会泄露任何有关明文的信息，因此被称为<strong>信息论安全</strong>。然而，该方法具有密钥长度必须和明文长度等长、密钥不能复用，且加密方案有着不必要的强安全性。因此，便有了更弱安全意义上的计算安全性。</p><p>计算安全性（Computational Security），这种安全性有着两个特点：</p><ol><li>它可以抵御任何拥有有限但庞大算力的敌手。</li><li>有着极其微小的可能性被攻破。</li></ol><p>因此，理想状况下，这种安全性的攻破方法只有暴力穷举所有的密钥。</p><p>有两种描述计算安全性的方法：具体/渐进方法。</p><h3 id="Concrete-Approach">Concrete Approach</h3><p>通过精确确定最大的被成功攻破的概率界限来描述计算安全性。敌手被认为是概率性的（randomized）。<br>形式化而言，有：</p><div class="admonition warning"><p class="admonition-title">$(t,\xi)-secure$</p><p>A scheme is $(t,\xi)-secure$ if any adversary running for time at most $t$ succeeds in breaking the scheme with probability at most $\xi$.</p></div><p>具体的安全性在实际问题十分重要，但在抽象讨论上的意义而言，精确的具体安全性很难进行讨论。<br>在直觉上，我们可以这样认为：$t$应当足够的大，且该方法是有效的（多项式而非指数）算法；$\xi$是一个渐进等于0的值。于是，我们将重点投向渐进安全性。</p><h3 id="Asymptotic-Approach">Asymptotic Approach</h3><p>涉及知识：图灵机，以及计算复杂性。</p><p>由之前Ⅰ里头的介绍，需要尽可能地构造出来图灵机（准确来讲是确定性图灵机）意义上的难解问题，从而构造出渐进意义上的计算安全性。</p><h4 id="Assumption-and-PPT（概率意义上多项式能力）">Assumption and PPT（概率意义上多项式能力）</h4><p>在计算复杂性上讨论渐进安全，需要有以下假设：</p><ol><li>安全参数 $n\in N$必须被任何人所知。安全参数就是具体密钥的长度。</li><li>Honest parties（非敌手）拥有可以进行概率意义上的多项式算法能力（PPT），概率意义是指所有的PPT算法都可以无条件获取无偏的、独立的序列，多项式则是：<br>$\exists ~ polunomial~p(n)$,所有的honest parties都可以run in time $p(n)$</li><li>efficient adversary也被定义为拥有PPT能力，被称为PPT adversary。</li></ol><div class="admonition info"><p class="admonition-title">Why PPT?</p><ol><li>获取无偏独立的序列数据是密码学所必需的（例如生成随机数），非敌手用此生成随机密钥，则敌手也应当具有该能力。</li><li>PPT敌手可能还有证明不了的、相较真实世界的敌手的附加能力。为了证明能够更加严谨完善，假定敌手具有PPT能力。</li></ol></div><h4 id="Strong-Church-Turing-Thesis">Strong Church-Turing Thesis</h4><p>用类似讨论计算复杂性的方法讨论渐进安全性的另一个原因便是Ⅰ中讨论的如小标题所示的理论。任何目前实际上的模型都可以划归到多项式的算法上，也因此我们可以讨论布尔表达式、图灵机、随机预言机等可以归约到多项式上的模型。</p><h4 id="Definition">Definition</h4><div class="admonition warning"><p class="admonition-title">Definition:negligible function</p><p>$\forall~polynomial~p(.),\exists N~s.t. \forall n&gt;N:$$$f(n)&lt;\frac{1}{p(n)}$$</p></div><p>即，随着n增加，f(n)下降的的较任意的1/p(n)更快。<br>接下里给出形式化的渐进安全定义：</p><div class="admonition warning"><p class="admonition-title">Definition: Asymptotic Approach</p><p>A scheme is secure if any PPT adversary succeeds in breaking scheme with at most <strong>negligible</strong> probability.</p></div><p>形式化一点？</p><div class="admonition warning"><p class="admonition-title">Definition: abstract</p><p>A scheme is secure that for every PPT adversary $\mathcal{A}$，其进行特定的攻击；for every positive polynomial $p$,there exists an integer $N$ such that when $n$（被选定的一个常数）&gt;$N$,the probability that $\mathcal{A}$ succeeds in the attack is less than $1/p(n)$。</p></div><p>因此，安全参数n的大小和渐进安全性息息相关。其中，honest parties一般而言运行的是固定的多项式算法，如$O(n^2)$，而防御的敌手需要针对所有多项式，也就是“有效的”算法。</p><h2 id="Computationally-secure-encryption">Computationally secure encryption</h2><h3 id="Definition-2">Definition</h3><p>$Gen(1^n)\rightarrow k,assume~~~~|k|\geq n$<br>$Enc_k(m)\rightarrow c(maybe~~probabilistic)$<br>$Dec_k( c)=m(deterministic)$</p><p>其中，Gen运行多项式时间，且若消息空间是固定的，可被称为fixed-length private-key encryption，与之后的操作模式相对应。<br>该定义是无状态的（无上下文的状态消息）<br>最后，该定义也满足之前类似的定义中的Correctness。</p><h3 id="EAV-security-experiment-oracle">EAV security experiment(oracle)</h3><p>讨论计算安全性时，有以下性质：<br>要求敌手具有有限算力，允许敌手有小概率获胜的机会，以及加密的消息长度可以任意长（与先前的perfect encryption区别）。<br>密钥仍然不可复用。</p><p>也因此，计算安全性相比于信息论安全性，具有以上的“松弛”。</p><p>oracle：</p><ol><li>敌手向预言机发送两条消息$m_0,m_1$.</li><li>预言机按定义生成k，随机选择$b\leftarrow \{0,1\}$并生成密文c返回敌手。</li><li>敌手采取策略，返回b’，若$b=b’,output~~1$，否则为0.</li></ol><p>其实预言机过程和完美加密很像，但其具体定义不同。</p><p>也因此，有以下定义：</p><div class="admonition warning"><p class="admonition-title">Definition: $PrivK_{\mathcal{A},\prod}^{eav}$</p><p>$\prod=(Gen,Enc,Dec)$在以上实验若具有以下性质，则在EAV（窃听者）存在的情况下具有不可区分性：$$Pr[PrivK_{\mathcal{A},\prod}^{eav}(n)=1]\leq1/2+negl(n)$$换句话而言：for every PPT 敌手$\mathcal{A}$:$$|Pr[out\mathcal{A}(PrivK_{\mathcal{A},\prod}^{eav}(n,0))=1]-Pr[out_\mathcal{A}(PrivK_{\mathcal{A},\prod}^{eav}(n,1))=1]|\leq negl(n)$$</p></div><p>第一和第二的定义虽然等价，但敌手获胜的概率不可能小于1/2（乱猜也能1/2对吧），而第二种定义是绝对值式的定义，因此特地点明。</p><p>在上面的定义过程中，oracle实验只进行了单个密文的过程，敌手除了单个密文外没有得到任何的信息。</p><h3 id="Plaintext-length">Plaintext length</h3><p>发送密文的过程中，基本肯定会泄露的信息除了密文被发送这个行为本身外，还有一个看上去不太敏感的地方：<strong>明文长度</strong>。很多情况下，明文长度的泄露不会造成什么影响，但仍然存在着攻击手段。例如：</p><p>Crime attack：很多明文在加密前会进行压缩，假设有两条信息X,Y，拼接后的字符串为X||Y,若X与Y相像，压缩算法会将其压缩，长度缩小从而暴露X,Y的相关信息。</p><p>遇到这种情况，一般而言需要对消息填充至固定长度，但无法完全避免长度消息的泄露。</p><h3 id="Semantic-Security（语义安全）">Semantic Security（语义安全）</h3><p>在这之前，我们讨论的computational security notion建立在不可区分性（indistinguishability）上。在上一节的讨论中，明文长度的泄露不可避免。因此，我们希望除此之外不再泄露任何消息。</p><p>也因此有了 <strong>Semantic Security（语义安全）</strong> 以及其<s>十分诡异的</s>定义：<br><s>偷懒贴PPT</s></p><div class="admonition warning"><p class="admonition-title">Definition Semantic Security</p><p>A private-key encryption scheme $Enc,Dec$ is semantical secure in the presence of an eavesdropper if for every PPT algorithm $\mathcal{A}$ there exists a PPT algorithm $\mathcal{A'}$ such that for any PPT algorithm $Samp$ and poly-time computable functions $f$ and $h$, the following is negligible:$$|Pr[\mathcal{A}(1^n,Enc_k(m),h(m))=f(m)]-Pr[\mathcal{A'}(1^n,|m|,h(m))=f(m)]|$$</p></div><p>其中的h(m)可以看作附加的信息以函数的方式展现；而f(m)可以看作进行验证所需的谓词（或者说行为）。<br>太绕了？所幸的是，有以下性质：</p><div class="admonition info"><p class="admonition-title">info</p><p><strong>private-key encryption scheme 的不可区分性和语义安全是等价的</strong>，该性质对于任意的威胁模型都成立。</p></div><h2 id="Pseudorandomness（伪随机性）">Pseudorandomness（伪随机性）</h2><p>真随机数的生成开销巨大（虽然是可以生成的），密码学的伪随机性意味着：该生成分布无法有效的（也就是有限算力）和真随机分布相区分。</p><div class="admonition warning"><p class="admonition-title">Definition: a Sequence of Pseudorandom Distributions</p><p>A sequence of distributions $\{Dist_n\}_{n\in N}$ where$\{Dist_n\}=l(n)$ for some  polynomial $l$ is pseudorandom, if for every PPT distinguisher $\mathcal{D}$:</p><p>$$|Pr[\mathcal{D}(U_{l(n)})=1]-Pr[\mathcal{D}(Dist_n)=1]|\leq negl(n)$$</p></div><p>也因此，可以将其作为上述加密方案中的Gen，用于生成密钥：</p><div class="admonition warning"><p class="admonition-title">Definition Pseudorandomness Generator(PRGs)</p><p>A (deterministic) poly-time algorithm$$G:\{0,1\}^n\rightarrow \{0,1\}^{l(n)}$$is a pseudorandom generator if:</p><ol><li>(<strong>Expansion</strong>)$\forall n,l(n)&gt;n$.</li><li>(<strong>Pseudorandomness</strong>)$\{G(U_N)\}_{n \in N} $ is a sequence of pseudorandom distributions.</li></ol></div><p>需要注意的是： PRG 的暴力破解方法具有以下被破解的优势：<br>$$|Pr[\mathcal{D}(U_{l(b)})=1]-Pr[\mathcal{D}(G(U_n))=1]|\geq 1-2^{n-l(n)}$$<br>虽然说PRG无法被有效的区分，但PRG的输出并不是uniform的。本质上，PRG可以看作从长度较小的uniform数据映射到长度较长的伪随机性密钥。</p><p>不做证明的：PRG存在当且仅当单向函数（暂时不做说明）存在。</p><h3 id="Encryption-where-mathcal-M-mathcal-K">Encryption where |$|\mathcal{M}|&gt;&gt;|\mathcal{K}|$|</h3><p>基于 One-time pad，这里提出一个加密方案。<br>using PRG $G:\{0,1\}^n\rightarrow \{0,1\}^{l(n)}$<br>选择安全参数 $n\in N,\mathcal{K}=\{0,1\}^n,\mathcal{M}=\mathcal{C}=\{0,1\}^{l(n)}$<br>Gen(非$G$) 生成随机性密钥k：<br>$$Enc_k(m)=m\oplus G(k)$$<br>$$Dec_k( c )=c\oplus G(k)$$<br>于是有：</p><div class="admonition info"><p class="admonition-title">info</p><p>在上述的加密方案中，若Gen是本节定义的PRG，则该fixed-length private-key encryption scheme 在EAV下具有不可区分性。</p></div><h2 id="Reduction（归约性证明）">Reduction（归约性证明）</h2><p><strong>归约</strong>的概念在计算机科学中十分重要。</p><p>其本质是对上述构造的加密方案进行证明，若要攻破其方案，必须要攻破其内置的已被证明安全性的模块。通过反证法即可证明构造的加密方案安全性。</p><p>而如何构建这种反证？既然我们将加密方案的安全性归约到了其<strong>底层构件的安全性</strong>，而如今我们所讨论过的证明安全性的方法只有<strong>预言机</strong>，那么答案呼之欲出：</p><p>构造一个敌手$\mathcal{A}$去攻破构建的加密方案。而攻破过程中，可以将通过一系列过程，将敌手输入转化为抽象的敌手$\mathcal{A’}$，其对底层的构件进行预言机实验，再将预言机输出转化后返回给$\mathcal{A}$.由于底层的构建已被证明安全性,那么便可以证明加密方案安全性。</p><p>需要注意的是模拟抽象敌手的过程。对于该归约过程而言，对敌手$\mathcal{A}$的唯一了解就是他期望与预言机进行挑战，那么归约过程必须模拟地和预言机行为一致。</p><p>具体而言还有许多算式，但这里略了。懒。</p><hr><p>本节实际上是对上节的warning进行证明，但由于其重要性单开一节，又因为懒了所以等之后有空了写博客里头。<br>本质上这份博客还是一份复习的，但写博客耗费的时间超出了我的预期。之后要尽可能简略写了。</p><h2 id="Stronger-security-notions-CPA-Security">Stronger security notions(CPA Security)</h2><p>之前讨论的都为单消息的加密过程，这里开始讨论选择明文攻击，即可以选择多个明文，得到对应的密文（<strong>都是用单个密钥加密</strong>）来试图获得相关信息，而选择明文攻击又可以分为适应性和非适应性攻击。</p><p><strong>非适应性CPA</strong>：在上述的预言机实验中，敌手第一步选择了一对明文进行实验；而这里的CPA则是在第一步将选择多个明文，和这一对明文同时发出，并获得用相同密钥加密的密文回应。敌手获得了多余的信息，并仍然对选定的一对明文进行甄别。</p><p><strong>适应性CPA</strong>：无需在意多个明文的选择是否需要在第一步就全部完成。敌手可以根据上一次的回应而改变下一次发送的明文，从而获得更多的信息，敌手的能力也因此较非适应性CPA增强。适应性攻击可以在发送选定的一对明文前进行发送/收到回应，也可以在之后进行发送/收到回应，且仍然需要对该选定的明文进行甄别。</p><p>需要注意的是，两种CPA发送的多余明文，其长度都必须和选定的一对明文长度一致。</p><p>这里还有一个Left-or-right Security，不做多余介绍。</p><div class="admonition warning"><p class="admonition-title">Definition</p><p>Private-key encryption scheme Π has indistinguishable multiple encryptions under a chosen-plaintext attack, or is CPA-secure for multiple encryptions, if for all probabilistic polynomial-time adversary A there is a negligible function negl such that$$Pr[PrivK_{\mathcal{A},\prod}^{LR-cpa}(n)=1]\leq 1/2+negl(n)$$where the probability is taken over the randomness used by A and the randomness used in the experiment.</p></div><div class="admonition info"><p class="admonition-title">info</p><p>Any private-key encryption scheme that is CPA-secure is also a CPA-secure for multiple encryptions.</p></div><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Crypto </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DevOps初探--一次不成功的招新经历</title>
      <link href="/2022/12/25/devops-chu-tan-yi-ci-bu-cheng-gong-de-zhao-xin-jing-li/"/>
      <url>/2022/12/25/devops-chu-tan-yi-ci-bu-cheng-gong-de-zhao-xin-jing-li/</url>
      
        <content type="html"><![CDATA[<p>无项目经历者不得入星辰DevOps。<br>半开玩笑，虽然笔试完成的自认为还行，但可能还有缺陷，这里就放下等之后有项目经历了来品鉴一下这坨答辩吧。DevOps看重项目经历当然是很正常的，但我没想到的是面试基本上只问这一点。评判标准明确了那被薄纱也是合情合理。</p><p>快进到经典笑话：<br>“你来星辰有项目经历吗”<br>“没有，但我得进了星辰才能有项目经历”<br>这就是大一摆没有搞项目的下场.jpg</p><p>过程截图就不放了，这里把部分题目放出来。</p><p>相关链接：</p><p><a href="https://docs.docker.com/">docker官方文档</a><br><a href="https://docs.gitlab.com">gitlab官方文档</a><br><a href="https://gitlab.com/">gitlab官网</a><br><a href="https://gitlab.com/ZzzRemake">我的gitlab主页</a></p><h2 id="命令行入门">命令行入门</h2><h3 id="思考题-与图形界面相比，命令行有什么优势？">思考题 与图形界面相比，命令行有什么优势？</h3><p>命令行相比图形界面消耗的资源更少，能够让用戶避开图形界面的杂乱（处理大量数据等场景）更专注操作命令、信息等本质需求，操作更加灵活；且在某些无法使用图形界面程序或相关设施的情况下，命令行必不可少。</p><p>顺带一提，这里可以去了解一下各大Shell。<br>来个知乎连接：<a href="https://www.zhihu.com/question/21418449/answer/2292448029">DavidZ的回答</a></p><p>之后搞一个专门的命令行分类学学罢。</p><h2 id="Linux安装软件">Linux安装软件</h2><h3 id="docker">docker</h3><p>docker官方文档提供了Docker desktop和Docker Engine的两种下载方式，我是安装了Docker Engine，并且基本按照官方文档的步骤进行的。<br>所有步骤附在以下代码块中，并以注释注明过程。</p><pre class="language-bash" data-language="bash"><code class="language-bash"># 第一步，卸载旧版本（然而我的Ubuntu根本没有）sudo apt-get remove docker docker-engine docker.io containerd runc# 第二部，由于是第一次装，需要建立新的Docker 仓库# 1.依赖项sudo apt-get updatesudo apt-get install ca-certificates curl gnupg lsb-release# 2.curl add GPGkeysudo mkdir -p /etc/apt/keyringscurl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg# 3. 建立仓库echo \"deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \$(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list &gt; / dev/null# 第三步，正常的用apt-get安装sudo apt-get updatesudo apt-get install docker-ce docker-ce-cli containerd.io docker-compose-plugin# 测试一下？sudo docker run hello-world</code></pre><h3 id="思考题-Linux下安装软件与Windows-macOS有什么区别？">思考题 Linux下安装软件与Windows/macOS有什么区别？</h3><p>Linux可以通过包管理工具方便的获取最新的软件并更新，apt等包管理工具在安装软件的时候可以安装依赖项，大大简化了安装软件的过程。Windows则是通过下载可执行文件(exe)等方式进行安装，无法解决依赖问题，Linux当然也有类似的安装包直接安装，不解决依赖的方式，apt等包管理便改善了这一点。</p><p><strong>后来修订部分</strong><br>当然，这里可以扩展开讲。dpkg，deb之类的。。emmm，归linux档？和先前那个命令行一起。</p><h2 id="网络相关">网络相关</h2><h3 id="思考题-OSI七层模型的数据处理过程">思考题 OSI七层模型的数据处理过程</h3><p>应用层：将数据呈现给用戶；表示层：将接收到的数据编码解码成应用层能读取的格式，也可以对数据加密解密；会话层：再两台主机间建立会话以传输数据。<br>以上层的PDU都为数据（data），都是和应用本身相关的数据、消息报文等。<br>而传输层将PDU分段为segment（TCP）或者数据报datagram（UDP），两者大小都是有限的。分段前进行数据封装，加上TCP或UDP等有关信息。<br>网络层将数据头加上IP信息，包含了逻辑寻址的信息，之后将处理后的PDU：包（Packet）传输给数据链路层。<br>数据链路层的PDU形式为帧（frame），其中加上了LLC头（与硬件无关）和MAC头（寻址等硬件相关）；物理层则将数据处理为二进制流数据位（bit）</p><h3 id="实践题-Linux配置路由访问外网">实践题 Linux配置路由访问外网</h3><p>NAT模式下的linux虚拟机无法完成任务，因此将虚拟机切换成桥接模式。<br>然而，桥接模式下的虚拟机的默认路由是没有任何多余设置的，因此，在取消NAT的设置后，网卡的路由无法改变，在宿主机切换WIFI的时候便因为没有合法IP地址而无法联网。（大概。。符合题目要<br>求？）<br>于是在<code>/etc/netplan</code>文件夹（新版的Ubuntu网络配置文件与其他系统不同）找到yaml并修改：</p><pre class="language-yaml" data-language="yaml"><code class="language-yaml">network:     version: 2    renderer: NetworkManager    ethernets:        ens33:            dhcp4: true            dhcp6: true</code></pre><p>这里用dhcp动态配置ip，ens33表示网卡。emmm，其他的还是需要查一下的。</p><p>之后虚拟机和主机能够ping通，也能够访问外网。</p><h3 id="选做题-请简述二层交换机、三层交换机、路由器之间的区别，以及它们一般被部署在网络的哪些位置上">选做题 请简述二层交换机、三层交换机、路由器之间的区别，以及它们一般被部署在网络的哪些位置上</h3><p>二层交换机位于OSI第二层，可以用MAC地址转发数据（可传输到单一主机，与集线器的广播区分），可以用于VLAN等方式划分广播域；三层交换机在加上了路由模块，从而加速转发数据包的过程（一次路由，多次转发）。<br>然而，三层交换机只能部分实现路由器的功能。连接WAN的路由器所需维护的表项十分庞大且存在刷新的可能，这对三层交换机来说任务过于繁重，且大量的数据也对其加速转发的性能有较大影响，因而这部分由路由器承担。同时，路由器可以提供网络安全、除TCP/IP外的网络协议等功能，这些都是三层交换机所无法做到的。</p><p><strong>二次修订</strong>:<br>实际上，这里的二层、三层交换机可以和很多概念挂钩。关于交换机的区别，可以看这个博客：<br><a href="https://blog.csdn.net/dog250/article/details/8219141">Vlan/Trunk以及三层交换</a><br>关于vlan，可以看这个<a href="https://blog.csdn.net/phunxm/article/details/9498829">原理详解</a>.</p><div class="admonition info"><p class="admonition-title">推荐书籍</p><p>就是你电课本，大黑皮是真不错。<strong>《计算机网络：自顶向下方法》</strong></p></div><h3 id="附加题">附加题</h3><p>实际上这个附加题不是DevOps里头的，我从网管会那里搬一个放在这，感觉是很好玩的。</p><p><strong>DH42网络配置</strong><br><a href="https://lantian.pub/article/modify-website/dn42-experimental-network-2020.lantian/">lantian’s blog</a><br>咕咕咕，等有时间搞。</p><h2 id="docker容器">docker容器</h2><h3 id="实践题-在docker中运行phpmyadmin容器">实践题 在docker中运行phpmyadmin容器</h3><div class="admonition info"><p class="admonition-title">提示</p><p>phpmyadmin是一个Web端的数据库可视化界面，它需要指定MySQL服务器的IP地址，通过设置容器的环境变量<code>PMA_HOST</code>来指定。如果你是在Linux环境，那么docker会有一个子网，一般是<code>172.16.0.0/16</code>网段，刚才运行的mariaDB容器会得到一个IP地址，你可以通过<code>docker ps</code>命令查看当前运行的容器信息，然后通过<code>docker inspect</code> 容器ID查看容器的IP地址。如果你是在macOS上运行docker，需要注意由于macOS不具备docker所需要的namespace和cgroup，所以macOS上的docker实际是运行在VirtualBox虚拟机中的，而且它的网络与宿主机网络并不直接连通，好在容器之间的网络是连通的，但是对于phpmyadmin，你可能需要将它的Web端口（80）映射到本机的其他端口上，可以用参数 <code>-p</code> 宿主机端口:容器端口 指定。</p></div><pre class="language-bash" data-language="bash"><code class="language-bash"># docker 创建网络sudo docker network create my-mariadb# 创建mariadb，指定环境变量MYSQL_ROOT_PASSWORD、端口映射、命名卷和网络别名sudo docker run -d \--restart always \--network my-mariadb --network-alias mariadb \-e MYSQL_ROOT_PASSWORD=123456 \-p 3306:3306 \-v mariadb-data:/var/lib/mysql \mariadb# 创建phpmyadmin，指定环境变量PMA_HOST、端口映射和网络别名sudo docker run -d \--restart always \--network my-mariadb --network-alias phpmyadmin \-p 8081:80 \-e PMA_HOST=mariadb \phpmyadmin</code></pre><h3 id="思考题-docker和虚拟机有什么不同？">思考题 docker和虚拟机有什么不同？</h3><p>docker通过docker守护进程来管理docker容器，通过linux的namespace组合和cgroups来隔离docker内外和管理所用资源。docker可以将应用程序所运行存储的数据通过分层来隔离，push和pull镜像的时候不会影响，通过数据卷挂载来持久化数据。然而其隔离性无法比拟虚拟机。<br>而虚拟机是通过Hypervisor管理虚拟机系统，直接访问硬件资源，并较docker需要更多的存储空间等硬件资源。虚拟机在运行的时候需要运行各种依赖，相较docker可以专注单个应用而言更可能发生冲突，启动时间也比拟不了docker的快捷。</p><p><strong>二次修订</strong>:<br>关于docker相关，除了最上方的官方文档教程（新人友好），还有相关的<a href="https://www.lixl.cn/books/Docker/1-Overview/#docker_7">介绍</a></p><h2 id="GitLab-CI-CD">GitLab CI/CD</h2><p>git操作这里就不放了（</p><h3 id="实践题-使用GitLab-CI-CD功能，实现Docker镜像自动发布">实践题 使用GitLab CI/CD功能，实现Docker镜像自动发布</h3><p><a href="https://gitlab.com/ZzzRemake/hello_devops">看看项目</a><br>具体已经写readme里头了。</p><h3 id="思考题-如何将Docker镜像实际在服务器上运行？">思考题 如何将Docker镜像实际在服务器上运行？</h3><p>似乎是一个蛮深奥的问题，但我没有项目开发经验（这就是大一摆没有搞项目的下场.jpgx2），这里只能放网上查到的玩意儿了。</p><p>创建镜像后已经发布到了docker hub，因此可以让服务器删除原有的可能冲突的镜像，然后从docker hub拉取所需镜像运行容器。</p><h3 id="实践题-搭建博客罢">实践题 搭建博客罢</h3><p><a href="https://zzzremake.gitlab.io/">博客链接</a></p><p><a href="https://gitlab.com/ZzzRemake/zzzremake.gitlab.io">仓库链接</a></p><p>之前已经在windows环境下写过一次github page部署hexo博客（就是你现在看到的博客）了，但<code>node_modules/</code>以及相关的包由于都是js等文件，理论上是可以跨平台的，因此我直接试了下copy，还真行，乐（<br>于是便把相关文件copy到了虚拟机中，且在gitlab网⻚里新建了创建page的project。接下来的步骤和之前用<code>gitlab CI/CD</code> 功能部署docker镜像相似。编写<code>.gitlab-ci.yml</code>时，发现gitlab有提供hexo的模板<br>yml，copy后由于node版本不同修改了模板的image信息，提交后便可通过pipeline生成博客。</p><p><strong>problems</strong>:<br>在注册gitlab-runner的时候，我原本以为需要再在本地创建一个gitlab-runner的docker来搭配博客仓库的流水线，但注册后查看配置文件，发现是在配置文件中新添加了关于博客仓库配置runner的信息.</p><p>另外，copy后发现使用的主题文件夹<code>theme/hexo-theme-matery</code>里面是有<code>git</code>子仓库的，如果不删除其中的<code>.git</code>文件夹，push到gitlab上会无法打开其中的文件（无url），流水线创建的过程也会失败。由于博客项目本身不是一个复杂项目（？，因此删去这里的子仓库，用主仓库直接管理。</p><p><strong>二次修订</strong>:<br>没错，这就是个简单的复制粘贴，含金量其实就只有<code>.gitlab-ci.yml</code>编写，然而这个我也是抄模板的（这就是大一摆没有搞项目的下场.jpgx3）</p><h2 id="碎碎念">碎碎念</h2><p>嗯，在这里二次修订的意义是为了之后的学习计划。我目前只是初步了解docker，git，gitlab，linux这些的运用，距离用好还有很大的差距。这里的学习计划也是督促罢。<br>列出来的就已经蛮多了。</p><ol><li>命令行操作学习</li><li>Linux（也许之后专门搞个双系统？）</li><li>计算机网络相关</li><li>DH42</li><li>Docker</li><li>gitlab CI/CD</li><li>第二个博客</li></ol><p>恁🐎，这么多。慢慢消化罢。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> DevOps </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DevOps </tag>
            
            <tag> docker </tag>
            
            <tag> CI/CD </tag>
            
            <tag> GitLab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Modern CryptoⅡ Perfect Encryption</title>
      <link href="/2022/12/02/modern-cryptoii-perfect-encryption/"/>
      <url>/2022/12/02/modern-cryptoii-perfect-encryption/</url>
      
        <content type="html"><![CDATA[<h2 id="Something-ahead">Something ahead</h2><p>概率论啊嗯，但确实不用多少相关知识，概率论一二两章学学就行。</p><p>条件概率公式：$Pr[B|A]=Pr[A\land B]/Pr[AB]$。<br>贝叶斯公式：$Pr[B|A]=\frac{Pr[A|B]\cdot Pr[B]}{Pr[A]}$<br>全概率公式$Pr[A]=\sum_i^nPr[A|B_i]\cdot Pr[B_i]$</p><p>怎么样，都会吧（</p><h2 id="random-number">random-number</h2><p>密码学中，随机数的生成是很重要的，例如加密方案中生成密钥的$Gen$便需要以此保证随机性。然而，这里不讨论如何生成，以及怎么判定随机数，留在第四章进行<s>咕咕咕</s></p><p>现在这里所进行的是一些概念的讨论：<br>随机数生成大约需要：</p><ol><li>收集高熵数据，这里的高熵是指高不确定性，但并不是密码学中我们所需要的随机。</li><li>以数据为依据，生成一系列几乎独立的(independent),无偏的(unbiased)位序列。</li></ol><p>可以看到，我们所需要的数据仍然是有要求的：uniform。而关于随机性，随机的概率性等等，不在这里讨论。这里只是说明，随机数或者伪随机数是可以生成的。</p><p>P.S.这里还提了一句C里头那个<code>rand()</code>函数无法达到密码学意义上的随机性，乐。</p><h2 id="回顾知识以及修订">回顾知识以及修订</h2><p>我们现在明白了：<br>$$<br>\begin{split}<br>\mathcal{K}:&amp; keyspace  \\<br>\mathcal{M}:&amp; plaintext\quad space \\<br>\mathcal{C}:&amp; ciphertext\quad space \\<br>Gen:&amp; \rightarrow \mathcal{K} \\<br>Enc:&amp; \mathcal{K}\times \mathcal{M}\rightarrow C \\<br>Dec:&amp; \mathcal{K}\times \mathcal{C}\rightarrow M<br>\end{split}<br>$$<br>其中，$Gen，Enc$是概率性的。Gen需要随机生成密钥来保证安全性，Enc我们允许随机，但Dec需要满足以下性质：<br>$$Correctness:\forall k \in \mathcal{K},m\in\mathcal{M}:Dec_k(Enc_k(m))=m$$<br>即解密正确性。<br>在这里，可以用<strong>概率</strong>的方式来看待$K,M,C$,作为其取值空间的随机变量。$K$肯定是随机生成了，而在攻击者看来，$M$(随机变量)是在消息空间中的概率分布，而采集到的$m$信息是其的采样。也因此，$C$也是概率分布。这和我们平常认为两者是确定的不同。</p><p>理论上而言，明文应该和加密策略，也就是K无关，两者相互独立。</p><p>那么我们再回顾一下之前对安全目标的定义，假设现在通信双方正在通过对称密钥的方式进行通信，敌手能够观察到的就是通信的密文内容。并且，敌手还可以做到：</p><ol><li>可以知道所有可能的发送的消息，以及消息空间的概率分布</li><li>同时攻击者也知道加密方案本身，但敌手不知道密钥 $k$。<br>那么，Perfect Secrecy便有两种表述方式：</li></ol><div class="admonition info"><p class="admonition-title">攻击者无法通过观察密文来获得任何和明文相关的信息。</p><p>$$\forall m\in\mathcal{M},c\in\mathcal{C},Pr[M=m|C=c]=Pr[M=m]\qquad(Pr[C=c]&gt;0)$$密文和明文的随机变量是相互独立的。</p></div><div class="admonition info"><p class="admonition-title">密文的分布和加密的明文信息相互独立。</p><p>$$\forall m.m'\in\mathcal{M},c\in\mathcal{C},Pr[Enc_K(m)=c]=Pr[Enc_K(m')=c]$$</p></div><p>这两种表达是相互等价的，这里不给出证明过程（但确实可以证，只是我懒不想写，证明过程需要用到上面所给的概率论基础）<br>然而证明过程还是很好玩的，也许等之后补上？<s>再次咕咕咕</s></p><h2 id="indistinguishability">indistinguishability</h2><p><strong>寒假更新咯！</strong></p><p>可以对上述的过程进行另一种表述，这种表述是通过experiment实现的。攻击者试图被动的观察密文，并给定两条明文，判断该密文是哪一条明文加密的。</p><p>于是便引入了一个密码学上十分重要的模型：<strong>预言机（oracle）</strong>，目前可以把其理解为一个执行指定操作的黑箱。它总是能正确的给你所设定好的目标答案。</p><p>上述观察过程，可以表示为$Priv_{\mathcal{A}\prod}^{eav}$，表示在窃听者$eav$下的不可区分性experiment，敌手为A，该不可区分性experiment为block符号,类似加密方案。</p><ol><li>$eav\quad generate\quad m_0,m_1\in \mathcal{M}$<br>敌手生成两条明文，传递给Oracle。</li><li>$Oracle：k\leftarrow Gen \\<br>b\leftarrow {0,1}(random) \\<br>c:=Enc_k(m_b)<br>$<br>oracle生成密钥，随机选择明文进行加密，得到密文c。</li><li>$c-&gt;eav$,eav判断$b$为0还是1，也就是猜测是自己生成的哪一条明文，并将猜测结果$b’$返回oracle。<br>$Priv_{\mathcal{A}\prod}^{eav}=1\quad if b=b’,else\quad Priv_{\mathcal{A}\prod}^{eav}=0$。</li></ol><div class="admonition warning"><p class="admonition-title">Definition</p><p>$(Gen,Enc,Dec)$ is Perfectly indistinguishable if for every $\mathcal{A}$ it holds that$$Pr[Priv_{\mathcal{A}\prod}^{eav}=1]=\frac{1}{2}$$</p></div><p>攻击者无法区分两者消息。这种perfectly indistinguishable的表述和前两个通过概率的描述是相同的。</p><h2 id="The-One-Time-pad">The One-Time pad</h2><p>密码学是螺线上升的，很多刚开始的加密方案并没有完善的理论基础，例如这里要讲的<strong>OTP</strong>在1917年提出，而那时还没有可证明安全的概念。</p><p>加密过程：<br>设长度为$l\in N,\mathcal{M}=\mathcal{K}=\mathcal{C}={0,1}^l$.<br>$Gen\rightarrow k\in\mathcal{K}$,uniformly at random<br>$Enc_k(m)=m\oplus k,Dec_k ( c ) =c\oplus k$<br>其为Perfect secret。证明过程：</p><p>$Pr[Enc_k(m)=c]=Pr[m\oplus k=c]=Pr[k=c\oplus m]=|\mathcal{K}|^{-1}=2^{-l}$</p><p>当然你也可以用群的方式写写。</p><p>需要特别指出的是，这里的密钥、明文、密文的长度都是等长的，因此生成密钥、加密过程以及泄露消息等都有一些缺点。OTP并不是好用的加密方案。<br>并且，OTP不能够复用密钥。一旦复用，攻击者可以通过</p><p>$$Enc_k(m)\oplus Enc_k(m’)=m\oplus m’$$</p><p>去除密钥，使密钥丧失作用而暴露明文的相关信息，OTP便失去作用。</p><h2 id="Limitations">Limitations</h2><div class="admonition info"><p class="admonition-title">Theorem</p><p>若加密方案为完美加密，那么密钥空间大小必须大于明文空间大小。</p></div><p>反证法稍微证一下就行了。</p><h3 id="Shannon’s-Theorm">Shannon’s Theorm*</h3><p>PPT无，这里补充下。</p><div class="admonition info"><p class="admonition-title">Shannon's Theorm</p><p>若$(Gen,Enc,Dec)，and|\mathcal{M}|=|\mathcal{K}|=|\mathcal{C}|$</p><ol><li>$\forall k\in\mathcal{K},Pr(k~is~~chosen)=\frac{1}{|\mathcal{K}|}$</li><li>$\forall m\in\mathcal{M},c\in\mathcal{C}，\exists k(unique)\in \mathcal{K},Enc_k(m)=c$</li></ol><p>那么这个加密方案为Perfect secret。这是充要条件。</p></div><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Crypto </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Modern CryptoⅠ Introduction</title>
      <link href="/2022/11/26/modern-cryptoi-introduction/"/>
      <url>/2022/11/26/modern-cryptoi-introduction/</url>
      
        <content type="html"><![CDATA[<p>该博客。。大约是学校课程的一个小小的复习。</p><p>另有本博客附加说明：</p><div class="admonition info"><p class="admonition-title">说明框</p><p>这种格式一般而言是对性质、构造等的说明。</p></div><div class="admonition warning"><p class="admonition-title">定义框</p><p>这种格式一般是对加密方案等定义的说明。</p></div><div class="admonition missing"><p class="admonition-title">注意框</p><p>这种格式是对尤其需要注意的地方的说明。</p></div><p>话不多说，摆个📕先。</p><div class="admonition info"><p class="admonition-title">book</p><p>name：Introduction To Modern Cryptography</p><p>author：Jonathan Katz, Yehuda Lindell</p></div><h2 id="一些先导概念">一些先导概念</h2><p>传统的密码学被称为 <abbr title="编码">Codes</abbr> 或是 <abbr title="加密">Ciphers</abbr>，如凯撒密码等这些构造方式；而现代密码学提供的与之对应的概念被称为 <abbr title="加密方案">Encryption Scheme</abbr>，并有严格的安全证明。两者的具体差别后面就会提到。</p><h3 id="密钥相关">密钥相关</h3><p>在刚学密码学的时候，我们认为密钥能够安全共享，避开对安全传递密钥过程的讨论（因为目前的知识无法对其进行讨论），并且假设用户能够妥善保护密钥。</p><h3 id="基本记号">基本记号</h3><p>$$<br>\begin{split}<br>K:&amp; key\quad space\\<br>M:&amp; plaintext\quad space\\<br>C:&amp; ciphertext\quad space<br>\end{split}<br>$$</p><p>类似于取值空间的概念。<br>M在传统密码学中可能是一些字母（编码）表，但现代密码学将其设定为二进制字符串，对应现实中传递的信息。<br>加密方案（Encryption scheme）由以下部分组成：<br>$Gen-&gt;K(probabilistic，概率性)$ 密钥生成算法<br>$Enc:K\times M\rightarrow C$ 加密算法<br>$Dec:K\times C\rightarrow M$ 解密算法<br>正确性：$\forall k \in K,m \in M:Dec_k(Enc_k(m))=m $</p><p>现代密码学和传统密码学的一个重要区别是Kerckhoffs principle：</p><div class="admonition info"><p class="admonition-title">Kerckhoffs principle</p><p>The cipher method must not be required to be secret, and it must be able to fall into the hands of the enemy without inconvenience.加密的方法必不能被要求是秘密的，并且这种加密的方法必定能够被敌手获取。</p></div><p>现代密码学放弃了对加密方案的保密性，因此你可以在网络上找到加密库，例如OpenSSL的加密方案具体如何操作。密码学认为，唯一应该保密的是密钥本身，而加密方案应当公开。(同时，这个原则也隐含了一点：不要用自己实现的加密方案)</p><p>为什么有这么第一眼看的蛮奇怪的要求捏？</p><div class="admonition warning"><p class="admonition-title">warning</p><p>1.对<strong>加密方案保密</strong>是<strong>不切实际</strong>的，诸如逆向工程、渗透攻破等方式便可以得到加密方案。即，你无法预计敌手会采取什么方式获取到你的加密方案；也因此，不能够认为对加密方案进行保密措施便能够确保更好的安全性。</p><p>2.相比而言，相较加密方案而言，<strong>更小的</strong>密钥更易保存，更改密钥也比更改方案更加容易</p><p>3.能够更好的在公开场合下讨论加密方案的安全性，从而促进加密方案的标准化。</p></div><h2 id="传统加密（非古典密码学）">传统加密（非古典密码学）</h2><p>这里就简略了。</p><p>传统密码学更多意义上可以看作一种“艺术”，是一种智力上的比拼；但其也可以通过诸如暴力破解、频次分析、词法分析等方式破解，暴力破解的原因就是因为密钥空间不够大。因此，你可以看到如今的加密方案密钥空间越来越大，DES为$2^{56}$，比特币采用$2^{90}$大小的密钥空间加密方案，AES的密钥空间已经扩展到了$2^{128},2^{256}$.</p><p>然而DES现在早就不安全了，令人感叹。不是因为算法本身有问题，而是密钥空间太小了。据说上个世纪的计算机就能攻破捏。</p><h2 id="现代密码学">现代密码学</h2><p>现代密码学的安全定义由两部分组成：<br><strong>安全目标</strong>和<strong>威胁模型</strong>。</p><p>可证明性安全（归约安全）：</p><ol><li>提供形式化的安全定义。</li><li>精确的给定假设。</li><li>在假设的基础上，提供一个你构造的加密方案的安全性证明，安全性基于安全定义。</li></ol><h3 id="安全目标">安全目标</h3><p>对此，有一个对安全加密的强定义：</p><div class="admonition info"><p class="admonition-title">info</p><p><strong>不管攻击者有了多少信息。密文都不能泄露给敌手任何额外的关于明文的信息。</strong></p></div><p>实际上，这种定义比想象中的要强。该加密方案不会泄露密钥、不会泄露明文信息，加密者也无法获取除了明文外的别的信息。因此，理论上，这种强定义便可阻绝一切可能的攻击。</p><h3 id="威胁模型">威胁模型</h3><p>可以看看<a href="https://www.cnblogs.com/xdyixia/p/11610091.html">这里</a>的威胁模型。</p><p>密码学中，认为由四种威胁模型，这些威胁模型代表了敌手的能力（但你无从得知敌手会做什么，这在实际应用中是合理的）</p><ol><li><strong>Ciphertext-only attack</strong>,获取密文攻击，敌手仅能获取到传递的密文。</li><li><strong>Known-plaintext attack</strong>,获取明文攻击，敌手可以得到明文、密文对，他的攻击目标是攻破用相同密钥加密的密文。</li><li><strong>Chosen-plaintext attack</strong>(CPA)，选择明文攻击，敌手任意选择明文，能够得到明文/密文对。CPA安全性是很重要的（后面的章节有讨论）</li><li><strong>Chosen-ciphertext attack</strong>(CCA)，选择密文攻击，敌手能够得到任何密文的解密结果。</li></ol><p>可以发现，由上到下的威胁模型，敌手越来越强。<br>当然，选择威胁模型时并不是越强越好，在实际方案中自己选择罢！</p><p>另外，需要点明的一点是，这里的attack便已经为之后的预言机模型打下某些基础。预言机的概念暂且不表。</p><h3 id="相关假设">相关假设</h3><h4 id="Turing-Machine">Turing Machine</h4><p>图灵机模型在计算机科学中占有极为重要的地位，以其为基础建立的图灵机模型成为可计算性理论、计算复杂度理论中重要的一环。<br>在之后的学习中，将会学习到以下定理：</p><div class="admonition info"><p class="admonition-title">Strong Church-Turing Thesis</p><p>Every physically realisable computation can be simulated on a Turing Machine with at most polynomial slowdown. Probably only true if we exclude quantum computers.</p></div><p><s>相信大家都懂计算复杂度相关吧</s><br>也就是说，任何多项式算法，无论在现实中采用什么物理模型，都可以归约到图灵机模型，并且时间复杂度也同样是多项式。（当然还没有出来的量子计算机不在讨论范围内）</p><p>我觉得这块蛮重要的，就移到这里了,<s>然而这是第三章的内容</s>.</p><h4 id="NP">NP</h4><p><s>你一定已经知道$P$和$NP$问题吧</s></p><p>有了图灵机模型，才能够讨论$NP$问题。实际上，密码学大部分的原语(大约是基本组成部分的意思)都建立在$NP\neq P$的基础上，这样才能讨论计算复杂性安全（后面的博客来讲）</p><p>公钥密码学中的很多结构，例如因式分解的难解性就基于$NP$问题捏。</p><p>🧐课件中特地强调了这里介绍的precise assumption的重要性，例如数学证明的安全性需要这个，或者加密方案的比较(用弱假设限制的加密方案肯定更好嘛),以及构建加密方案的安全性。</p><p>😇这里介绍一下模块化的加密方案吧</p><p>实际上，密码学也是一个自底而上的不断构建的过程，构建复杂加密方案的时候需要之前验证过的简单的密码学部分。这样，即使部分出现问题，换一个component就行了；若加密方案出现问题，则认为是加密方案组织的问题，不是component的问题。两全其美啊嗯。</p><h4 id="安全性">安全性</h4><p>之前讨论的是可证明安全性，加密方案建立在安全目标和威胁模型的假设基础上证明其安全性。自然是和实际中的安全性是不一样的。</p><p>可证明安全性建立在安全目标、威胁模型的基础上，现实世界不会提供这么理想的模型的。同时，即使现实世界满足了可证明安全性的条件，也不能一定确保安全性，但这种方式自然是极难找到的。在密码学中不进行讨论。</p><h2 id="二次修订部分">----二次修订部分----</h2><p>有书就是不一样啊😋</p><h2 id="Principles">Principles</h2><h3 id="1-Formal-Definitions">1.Formal Definitions</h3><p>形式化定义，也就是形式化以上的安全加密方案。</p><p>作用：</p><ol><li>避免糊里糊涂的方案定义，能够提供一种方法去评估、证明安全性与否。</li><li>提供了方案比较的有效性。方案的安全性取决于具体的上下文环境，弱定义的安全方案可能比强定义更加有效。-&gt;模块化的可行性。</li></ol><p>这里给了形式化定义的一个例子，也就是上面的对于安全目标的定义。这里进行补充。<br>回顾一下定义：</p><div class="admonition info"><p class="admonition-title">info</p><p><strong>不管攻击者有了多少信息。密文都不能泄露给敌手任何额外的关于明文的信息。</strong></p></div><p>这里并没有定义信息的“meaningful”，而是直接定义没有任何信息被泄露，因此该定义可以满足其他潜在的需要。关于“不泄露任何关于明文的信息”，以及有关攻击手可能有的先验知识相关，在之后的第二、三章中便有涉及。</p><h3 id="2-Precise-Assumptions">2. Precise Assumptions</h3><p>除了安全性证明需要精确的假设，其还可以让我们能够进行方案间的比较。基于更弱的安全性假设，能够有更高的自由度去构建加密方案，因此相较而言，弱安全性假设下的安全性证明更受到人们的青睐。</p><p>同时，精确假设也提供了：若组成加密方案的block被攻破后，假设仍然成立下的衡量原加密方案安全性的方式。</p><p>这里解释了一堆为什么采用建立在假设上的安全方案，而不是直接认为安全方案是安全的原因，这里略了（书P19）。</p><h3 id="3-Proofs-of-Security">3. Proofs of Security</h3><p>若要构建加密方案，必须要建立在精确假设上的安全性证明上，这比启发式，或者没有假设的证明好。</p><p>关于启发式的证明：即使证明了对于一大批攻击下你的方案的安全性，也不能保证你的方案一定安全。</p><h3 id="4-Provable-Security-and-Real-world-Security">4. Provable Security and Real-world Security</h3><p>现实情况的不同，导致可能的安全目标、威胁模型、假设等不满足可证明安全所需，另外也有各种意想不到的方式攻破可证明安全下的加密方案。</p><hr><p><strong>碎碎念</strong>：哦完蛋，基础理论我也不太会，密码学要寄了😭</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Crypto </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker_first:基本指令</title>
      <link href="/2022/11/04/docker-first-ji-ben-zhi-ling/"/>
      <url>/2022/11/04/docker-first-ji-ben-zhi-ling/</url>
      
        <content type="html"><![CDATA[<p>本文记录指令信息供之后查询。</p><h2 id="begin">begin</h2><p>link:<a href="https://docs.docker.com/">docker-docs</a></p><h3 id="docker-build">docker build</h3><pre class="language-bash" data-language="bash"><code class="language-bash">docker build -t tag-name .</code></pre><p><code>build</code>: 用<code>dockerfile</code>来建立映像。<br><code>-t</code> flag your image,后面跟着名字。<br><code>.</code> current directory to find <code>Dockerfile</code></p><h3 id="docker-run">docker run</h3><pre class="language-bash" data-language="bash"><code class="language-bash">docker run -dp 3000:3000 tag-name</code></pre><p><code>run</code> 运行docker<br><code>-d</code> 分离“detached”mode运行。<br><code>-p</code> map from host’s port to container’s port</p><h3 id="update-code">update code</h3><pre class="language-bash" data-language="bash"><code class="language-bash">docker ps# swap out container-id with ID from docker psdocker stop container-iddocker rm container-id# or stop&amp;rm:docker rm -f container-id</code></pre><p><code>ps</code>：运行中容器list<br><code>stop</code> stop 运行<br><code>rm</code>：remove container（默认需要stop后）<br><code>-f</code>：强制。</p><p>以上仍然需要麻烦的持续性重头再来。</p><h3 id="push-docker-hub">push docker-hub</h3><p><code>docker-hub</code>:先创个仓库。后面会直接给你个代码：</p><pre class="language-bash" data-language="bash"><code class="language-bash">docker push namespace/tagname</code></pre><p>然而只有这个是不够的。</p><pre class="language-bash" data-language="bash"><code class="language-bash">docker login -u USER-NAMEdocker tag image-name USER-NAME/NEW-NAMEdocker push USER-NAME/NEW-NAME</code></pre><p>tag一下，才能找到正确的image捏。</p><h3 id="DB">DB</h3><p>一个容器运行的时候，他是用映像里头的多个层作为文件系统的，每个容器还有自己的暂存空间来创建/更新/删除文件，任何更改都不会在另一个容器看到。<br>比如：</p><pre class="language-bash" data-language="bash"><code class="language-bash">docker run -d ubuntu bash -c "shuf -i 1-10000 -n 1 -o /data.txt &amp;&amp; tail -f /dev/null"docker exec container-id cat /data.txt</code></pre><p>then, we can use volume!</p><h3 id="named-volumes">named volumes</h3><p>数据bucket，持久化指定位置的最后改动数据，</p><p>用卷持久化：</p><pre class="language-bash" data-language="bash"><code class="language-bash">docker volume create volume-namedocker run -dp 3000:3000 -v volume-name:&lt;where?&gt; &lt;container-name&gt;</code></pre><p>where is the volume?</p><pre class="language-bash" data-language="bash"><code class="language-bash">docker volume inspect volume-name</code></pre><h3 id="bind-mounts">bind mounts</h3><p>named volume持续化数据还是不错的。<br>这里讲的bind mounts，可以控制确切的挂载点。我们可以用其持久化数据，但它通常用于提供额外的数据给容器。用其可以立刻看到所需的更改。</p><div class="admonition info"><p class="admonition-title">various volume</p><p>当然，其中还是有别的volume的，这里只有bind mounts和named volumed。</p></div><pre class="language-bash" data-language="bash"><code class="language-bash">docker run -dp 3000:3000 \     -w /app -v "$(pwd):/app" \     node:12-alpine \     sh -c "yarn install &amp;&amp; yarn run dev"</code></pre><p><code>-w app</code>：set working directory<br><code>-v "$(pwd):/app"</code>bind mount the current（pwd？）directory into the <code>/app</code> directory in the container<br><code>node:12-alpline</code> image to use（base image）<br><code>sh -c....</code> alpine：shell running command。</p><p>查看docker日志：</p><pre class="language-bash" data-language="bash"><code class="language-bash">docker logs -f container-id</code></pre><h3 id="多应用：多容器">多应用：多容器</h3><h4 id="container-networking">container networking</h4><p>两种方式：</p><ol><li>开始的时候给你来个网</li><li>连接现成的container</li></ol><pre class="language-bash" data-language="bash"><code class="language-bash">docker network create network-name# create network，and then：docker run -d \     --network todo-app --network-alias mysql \     -v todo-mysql-data:/var/lib/mysql \     -e MYSQL_ROOT_PASSWORD=secret \     -e MYSQL_DATABASE=todos \     mysql:5.7</code></pre><p>可以看到，<code>-e</code>设置了环境变量.</p><div class="admonition info"><p class="admonition-title">new volume?</p><p>在这里,自动创建了个volume，因此出现了从未出现的卷名。</p></div><pre class="language-bash" data-language="bash"><code class="language-bash">docker run -it --network todo-app nicolaka/netshoot</code></pre><p>use dig tool,we could find the mysql <code>ip</code>，docker可以将名字和网络地址联系：use<code>--network-alias</code>flag。</p><h4 id="connect-mysql-with-app">connect mysql with app</h4><pre class="language-bash" data-language="bash"><code class="language-bash"># mysql version8.0 and higher:mysql&gt; ALTER USER 'root' IDENTIFIED WITH mysql_native_password BY 'secret';mysql&gt; flush privileges;mysql&gt; exit# docker:connectdocker run -dp 3000:3000 \   -w /app -v "$(pwd):/app" \   --network todo-app \   -e MYSQL_HOST=mysql \   -e MYSQL_USER=root \   -e MYSQL_PASSWORD=secret \   -e MYSQL_DB=todos \   node:12-alpine \   sh -c "yarn install &amp;&amp; yarn run dev"# operate, and show mysql imformationdocker exec -it &lt;mysql-container-id&gt; mysql -p todosmysql&gt; select * from todo_items; +--------------------------------------+--------------------+-----------+ | id                                   | name               | completed | +--------------------------------------+--------------------+-----------+ | c906ff08-60e6-44e6-8f49-ed56a0853e85 | Do amazing things! |         0 | | 2912a79e-8486-4bc3-a4c5-460793a575ab | Be awesome!        |         0 | +--------------------------------------+--------------------+-----------+</code></pre><h3 id="Docker-Compose">Docker Compose</h3><p><a href="https://docs.docker.com/compose/install/">install Docker Compose</a></p><p>and then: create <code>docker-compose.yml</code> in root directory.</p><div class="admonition info"><p class="admonition-title">不想写了，看连接吧</p><p>you can see detail in <a href="https://docs.docker.com/get-started/08_using_compose/">here</a></p></div><h3 id="addition">addition</h3><h4 id="扫描安全漏洞">扫描安全漏洞</h4><pre class="language-bash" data-language="bash"><code class="language-bash">docker scan --logindocker scanf image-name</code></pre><h4 id="查看Image-Layering">查看Image Layering</h4><pre class="language-bash" data-language="bash"><code class="language-bash">docker image histroy image-name#  可以看到Image-id,create-time,create-by,size,commentdocker image history --no-trunc getting-started# 忽略截断捏。</code></pre><div class="admonition warning"><p class="admonition-title">layer changes</p><p>Once a layer changes, all downstream layers have to be recreated as well</p></div><h4 id="dockerignore">.dockerignore</h4><p>.dockerignore文件中：</p><pre class="language-docker" data-language="docker"><code class="language-docker">node_modules</code></pre><p>使用缓存speed up。</p><h4 id="multi-stage-builds">multi-stage builds</h4><pre class="language-docker" data-language="docker"><code class="language-docker"># syntax=docker/dockerfile:1FROM maven AS buildWORKDIR /appCOPY . .RUN mvn packageFROM tomcatCOPY --from=build /app/target/file.war /usr/local/tomcat/webapps# react example# syntax=docker/dockerfile:1FROM node:12 AS buildWORKDIR /appCOPY package* yarn.lock ./RUN yarn installCOPY public ./publicCOPY src ./srcRUN yarn run buildFROM nginx:alpineCOPY --from=build /app/build /usr/share/nginx/html</code></pre><p>多阶段构建可以减少整体image size。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> DevOps </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> primary </tag>
            
            <tag> DevOpswork </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dp技巧1：四边形不等式</title>
      <link href="/2022/10/22/dp-ji-qiao-1-si-bian-xing-bu-deng-shi/"/>
      <url>/2022/10/22/dp-ji-qiao-1-si-bian-xing-bu-deng-shi/</url>
      
        <content type="html"><![CDATA[<p>区间dp中，我们可以见到以下式子：</p><p>$dp(i,j)=min_{i\leq k&lt; j}(dp(i,k)+dp(k+1,j)+~<s>w(i,j)</s>~)$</p><p>那么，对于这个 $w$ ，如果满足单调性：</p><p>$$(l\leq l’\leq r’\leq r)~~~w(l’,r’)\leq w(l,r)$$</p><p>满足四边形不等式：</p><p>$$(l\leq l’\leq r’\leq r)~~~w(l,r’)+w(l’,r)\leq w(l,r)+w(l’,r’)$$</p><p>那么有，对于上面的dp而言，满足四边形不等式。<br>证明：<br>对于$l=l’$或者$r=r’$，有：<br>$dp(l,r’)+dp(l’,r), ~~~ dp(l,r)+dp(l’,r’)$，我觉得你观察下就能整出来。。</p><p>那么，数学归纳法整个：对$len=r-l+1$归纳：</p><ol><li><p>$l\leq l’=r’\leq r$，此时$len=0$.</p><p>对于$dp(l,r’)+dp(l’,r)$有：</p><p>$原式=dp(l,r’)+dp(r’,r) \leq dp(l,r)+dp(l’,r’)=dp(l,r)$</p></li></ol><p>即证明该式成立。<br>则对$dp(l,r)$:<br>设$k=max{ x|dp(l,r)=dp(l,x-1)+dp(x,r)+w(l,r)}$<br>由对称性：不妨设$k\leq r’$.<br>有：<br>$$<br>\begin{aligned}<br>dp(l,r’)+dp(l’,r) &amp;\leq w(l,r’)+dp(l,k-1)+dp(k,r’)+dp(l’,r)\\<br>&amp; \leq w(l,r)+dp(l,k-1)+dp(k,r’)+dp(l’,r)\\<br>&amp; \leq w(l,r)+dp(l,k-1)+dp(k,r)=dp(l,r)<br>\end{aligned}$$<br>2. $l&lt;l’&lt; r’&lt; r$<br>对$dp(l,r’)+dp(l’,r)$而言：设<br>$y=max{x|dp(l,r’)=dp(l,x-1)+dp(x,r’)+w(l,r’) }$<br>$z=max{x|dp(l’,r)=dp(l’,x-1)+dp(x,r)+w(l’,r)}$<br>则：<br>不妨设：$y\leq z$,则有$l&lt;z\leq y \leq r$.<br>原式<br>$$\begin{aligned}<br>\leq dp(l,y-1)+dp(y,r’)+w(l,r’)+w(l’,r)+dp(l’,z-1)+dp(z,r)\\<br>\leq w(l,r)+w(l’,r’)+dp(l,y-1)+dp(l’,z-1)+dp(y,r’)+dp(z,r)\\<br>\leq w(l,r)+w(l’,r’)+dp(l,y-1)+dp(l’,z-1)+dp(y,r)+dp(z,r’)\\<br>= dp(l,r)+dp(l’,r’)<br>\end{aligned}<br>$$</p><p>这性质和区间$dp$有啥关系呢？<br>该性质能够证明单调性：对于满足四边形不等式的dp状态，定义$s(i,j)$为$dp(i,j)$决策过程的最大值。<br>因此有:$s(i,j)$单调，$s(i,j)\leq s(i,j+1)\leq s(i+1,j+1)$.<br>因此在dp过程中：<br>$$dp(i,j)=\begin{cases}<br>min_{s(i,j-1)\leq k \leq s(i+1,j)}{dp(i,k-1)+dp(k,j)+w(i,j)} &amp; i&lt;j \\<br>0 &amp;i=j \\<br>+\infty &amp;i&gt;j<br>\end{cases}$$</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区间dp </tag>
            
            <tag> 优化 </tag>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构板子</title>
      <link href="/2022/10/22/shu-ju-jie-gou-ban-zi/"/>
      <url>/2022/10/22/shu-ju-jie-gou-ban-zi/</url>
      
        <content type="html"><![CDATA[<h2 id="并查集">并查集</h2><p>判断集合，合并集合，比如图论中的kruskal，连通分支等。</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp">//int fa[N],siz[N];void init_set(int n){//初始化    for(int i=1;i&lt;=n;++i){        fa[i]=i,siz[i]=1;    }}int find(int x){//路径压缩    return fa[x]==x?x:(fa[x]=find(fa[x]));}void unionfa(int x,int y){//启发式合并    int parent_x=find(x),parent_y=find(y);    if(parent_x==parent_y){        return;    }    if(siz[parent_x]&gt;siz[parent_y]){        swap(parent_x,parent_y);    }//按照节点集合大小，保证小的和到大的里面。    fa[parent_x]=parent_y;    siz[parent_y]+=siz[parent_x];}</code></pre><h2 id="ST表">ST表</h2><p>$\Theta(nlogn)预处理，\Theta(1)查询$</p><p>可重复贡献———若对某种运算$opt$，有:$x<sub>opt</sub> x=x$，例如$gcd(x,x)=x,max(x,x)=x$，则类似的区间查询，比如区间gcd，区间最大值，且$opt$满足结合律$a<sub>opt</sub>(b<sub>opt</sub>c)=(a<sub>opt</sub>b)<sub>opt</sub>c$,则可以使用ST表进行区间查询。<br>但比如区间和，opt行为就会计算两次，还是不行捏。<br>DP:$f(i,j)=max[i,i+2^j-1]$<br>$f(i,0)=max[i,i]=i$<br>-&gt;<br>$f(i,j)=max(f(i,j-1),f(i+2^{j-1},j-1))$</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp">//以最大值为例//#define N 2000001const int maxlog=21;int st[N][maxlog],logn[N];void init_st(int n){    logn[1]=0;    logn[2]=1;    for(int i=3;i&lt;N;++i){        logn[i]=logn[i&gt;&gt;1]+1;    }}void st_process(int total){    init_st();    for(int i=1;i&lt;=n;++i){        cin&gt;&gt;st[i][0];    }}</code></pre><h2 id="树状数组">树状数组</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp">int tree[N],diff[N];int lowbit(int x){    return x&amp;-x;}void add(int x,int k,int n){    int tem=x*k;    while(x&lt;=n){        tree[x]+=k,diff[x]+=tem;        x+=lowbit(x);       }}void add_range(int,l,int r,int k){    add(l,k),add(r+1,-v);}long long int get_sum_range(intl,int r){    return (r+1ll)*getpre(r,tree)-1ll*l*getpre(l-1,tree)-    (getpre(r,diff)-getpre(l-1,diff));}int getpre(int x,int *tree){    int cnt=0;    while(x) {        cnt+=tree[x];        x-=lowbit(x);    }    return cnt;}</code></pre><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 板子 </tag>
            
            <tag> Data Structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串板子</title>
      <link href="/2022/10/22/zi-fu-chuan-ban-zi/"/>
      <url>/2022/10/22/zi-fu-chuan-ban-zi/</url>
      
        <content type="html"><![CDATA[<h2 id="字典树">字典树</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp">struct trie{    int nxt[N][26], cnt = 0;    bool vis[N]={0};//该节点结尾的字符串是否存在    //int repeat[N] = {0};    //两种重载版本    void insert(string &amp;s){        int now = 0;        for (int i = 0;i&lt;s.size();++i){            int tem = s[i] - 'a';            if(!nxt[now][tem]) nxt[now][tem] = ++cnt;            now = nxt[now][tem];        }        vis[now] = 1;    }    int find(string &amp;s){        int now = 0;        for (int i=0;i&lt;s.size();++i){            int tem = s[i] - 'a';            if(!nxt[now][tem]) return false;            now = nxt[now][tem];        }        /*if(vis[now]){            ++repeat[now];        }   return repeat[now];*/        return vis[now];    }};</code></pre><h2 id="前缀函数">前缀函数</h2><p>需要注意的是，前缀函数本身就是”跳转“，需要注意这个跳转的失配函数性质。</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp">int pre_len[N];void pre_len_process(string s){    //kmp:string s,string t;    //string last=s+"#"+t;    for(int i=0;i&lt;s.size();++i){        int j=pre_len[i-1];        while(j&gt;0&amp;&amp;s[i]!=s[j]){            j=pre_len[j-1];        }        if(s[i]==s[j]){            ++j;        }        pre_len[i]=j;    }}</code></pre><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 板子 </tag>
            
            <tag> String </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图论板子</title>
      <link href="/2022/10/22/tu-lun-ban-zi/"/>
      <url>/2022/10/22/tu-lun-ban-zi/</url>
      
        <content type="html"><![CDATA[<h2 id="基础">基础</h2><h3 id="建图">建图</h3><pre class="language-cpp" data-language="cpp"><code class="language-cpp">struct edge{    int u,v;};vector&lt;edge&gt; e;vector&lt;bool&gt; vis;//较为低效，若用时基本上是需要存边的消息以多次建图，//或者需要像kruskal那样对边权等进行直接操作。邻接表，同平常写法。链式前向星：int total=-1,head[]...;//需要全部初始化为-1。void add(int u,int v){    nxt[++cnt]=head[u];    head[u]=cnt;    to[cnt]=v;}//遍历时for(int i=head[u];~i;i=nxt[i]){    v=to[i];}</code></pre><h3 id="拓扑排序">拓扑排序</h3><p>Kahn算法：不断维护一个入度为0的集合（BFS）</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp">//struct node{ int now, val;};//第一种写法，采用结构体加以判断vector&lt;int&gt; graph[30];int intonow[30];//set&lt;int&gt; total;//现有节点vector&lt;int&gt; output;bool toposort(int n){    queue&lt;int&gt; q;    output.clear();    for (int i = 0; i &lt; n;++i)        if(!intonow[i])            q.push(i);    while(!q.empty()){//        int now = q.front();        q.pop();        output.push_back(now);        for (int i = 0; i &lt; graph[now].size();++i){            int nxt = graph[now][i];            if(--intonow[nxt]==0){                q.push(nxt);            }        }    }    if(output.size()==n){        cout&lt;&lt;....;        return true;    } else {        return false;    }    /*在这里保留的原因是因为这里的完全建立关系和拓扑排序还是有所不同，在这里就当拓展思路了。    if(maxs==n){        cout &lt;&lt; "Sorted sequence determined after " &lt;&lt; len &lt;&lt; " relations: ";//len为函数参数，自己看看要不要罢        for (int i = 0; i &lt; output.size();++i)            cout &lt;&lt; char('A' + output[i]);        cout &lt;&lt; ".";return true;    }     if(cnt!=total.size()){        cout &lt;&lt; "Inconsistency found after " &lt;&lt; len &lt;&lt; " relations.";        return true;    }    return false;*/}</code></pre><p>DFS：需要注意的就是最后的output是dfs序，需要reverse</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp">vector&lt;int&gt; graph[N],output;int marked[N];bool dfs(int now){    marked[now]=-1;    for(int nxt:graph[now]){        if(marked[nxt]&lt;0) return false;        if(!marked[nxt]&amp;&amp;!dfs(nxt)) return false;    }    marked[now]=1;    output.push_back(now);    return true;}bool toposort(){    output.clear(),memset(marked,0,sizeof(marked));    for(int i=0;i&lt;n;++i)   if(!marked[i]&amp;&amp;!dfs(i)) return false;    reverse(output.begin(),output.end());    return true;}</code></pre><h3 id="树链剖分">树链剖分</h3><p>下面是重链剖分，按照子树大小进行划分。其他如长链剖分，可以直接改改就行。</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp">int fa[N],dep[N],siz[N],hson[N];//父节点，深度，子树大小，重节点vector&lt;int&gt; a[N];int top[N],dfn[N],rnk[N],tot;//链顶，dfs序，rnk：逆函数，rnk[dfn[x]]=x;int dfs1(int u){//记录所需信息    hson[u]=-1;    siz[u]=1;    for(int i=0;i&lt;a[u].size();++i){        int v=a[u][i];        if(!dep[v]){            dep[v]=dep[u]+1;            siz[u]+=dfs(v,d+1);            fa[v]=u;            if(hson[u]==-1||siz[hson[u]]&lt;siz[v]){                hson[u]=v;            }        }    }    return siz[u];}void dfs2(int u,int nowtop){    top[u]=nowtop;    dfn[u]=++tot;    rnk[cnt]=u;    if(hson[u]==-1)return;    dfs2(hson[u],nowtop);    for(int i=0;i&lt;a[u].size();++i){        int v=a[u][i];        if(v!=hson[u]&amp;&amp;v!=fa[u]){            dfs2(v,v);        }    }}</code></pre><h2 id="树">树</h2><h3 id="树直径">树直径</h3><pre class="language-cpp" data-language="cpp"><code class="language-cpp">int fail[N],d[N];vector&lt;int&gt; a[N];int road[N],cnt=0;void dfs(int u,int fa,int &amp;last){    fail[u]=fa;    for(int v:a[u]){        if(v!=fa){            d[v]=d[u]+1;            if(d[v]&gt;d[last])  last=v;            dfs(v,u,last);        }    }}//使用：cnt=0;int begin=0,end=0;d[1]=0,dfs(1,0,begin);d[begin]=0;dfs(begin,0,end);for(int i=end;i;i=fail[i]){    road[cnt++]=i;}</code></pre><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Graph </tag>
            
            <tag> 板子 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Apriori</title>
      <link href="/2022/10/22/apriori/"/>
      <url>/2022/10/22/apriori/</url>
      
        <content type="html"><![CDATA[<p>先存着，乐。<br>捏麻麻滴图灵的项目和报告有点多，Apriori算法以及数据挖掘的相关概念倒是可以稍微总结下，毕竟我之后不会去看课本和ppt了。<br>谁看这些啊（暴论）</p><h2 id="来点概念">来点概念</h2><h3 id="basic-conception">basic conception</h3><p>首先要明白的一点是，这里的数据挖掘基本上是去寻找数据的关联性的。</p><p>项集：若干个项的集合，是数据挖掘种最基本的模式。<br>事务：每个事务都是非空项集，都拥有一个唯一表示TID。<br>数据集：事务的集合。<br>k项集：事务$|A|=k$</p><p>总体而言，给定了数据集后，我们需要通过分析来发现频繁项集。</p><p>呐，接下来整点数学。</p><h3 id="math">math</h3><p>支持度$Support(A,B)=P(AB)=\frac{|AB|}{|\Omega|}$</p><p>多个事物的支持度当然可以推了嘛。当然，这种东西不一定能够成为频繁项集的评判标准，接下来便有：</p><p>置信度$Confidence(A&lt;-B)=P(A|B)$</p><p>呐，条件概率！条件概率就能稍微整点和关联性了，但是还是不够。</p><p>提升度$Lift(A&lt;-B)=P(A|B)/P(AB)$</p><p>这就能一眼顶针了。若 $Lift$ 能够大于1，则该规则($A&lt;-B$)为有效强关联规则，而等于1就是我们概率论学过的相互独立事件：</p><p>$P(X|Y)=P(X)$</p><p>小于等于1就是无效的强关联规则了。<br>当然，可以自己定义标准，这里只是一些常用的形式。当我们自定义的标准算出的值大于某个阈值（看看之后能不能填坑解释下）,便可认为他是频繁k项集。</p><h2 id="来点性质">来点性质</h2><p>k维数据项集为频繁项集的必要条件是所有k-1子项集也为频繁项集。（先验原理）<br>似乎可以根据这个规则来线性递推？</p><p>具体似乎也补充不了太多，先放着🕊。</p><h2 id="来点实现">来点实现</h2><p>为了找出所有频繁k项集的集合$L_k$，需要逐层搜索。现在，对于生成$L_k$:</p><h3 id="连接步骤">连接步骤</h3><p>根据给的数据集，生成$C_k$（候选集合）罢！也就是多一项的问题！<br>但一眼TLE（错乱）</p><h3 id="剪枝步骤">剪枝步骤</h3><p>$C_k$是$(L_k)$的超集，所以$C_k$可以继续剪枝。<br>压缩$C_k $（利用前面讲的性质）,用非空子集是否是频繁项集（阈值之类的）做判断条件来剪枝，然后用阈值再次判断是否是频繁项集。</p><p>最后，若扫描k项集为空集，则k-1为最大频繁项集，算法结束。</p><p>当然，还有诸如极大频繁项集，这等之后填坑了。从中也可以看到，其实这方法蛮低效的，两剪枝在每层都要扫描数据集前面都是fw，其实和暴实差不多了。</p><h2 id="碎碎念">碎碎念</h2><p>感觉我写了一堆挖了一堆坑，乐。图灵👊😭。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据挖掘 </tag>
            
            <tag> 频繁项集 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
